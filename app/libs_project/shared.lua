-- Generated by Haxe 4.0.5
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["shared"] = _hx_exports["shared"] or _hx_e()
_hx_exports["shared"]["project"] = _hx_exports["shared"]["project"] or _hx_e()
_hx_exports["shared"]["project"]["utils"] = _hx_exports["shared"]["project"]["utils"] or _hx_e()
;_hx_exports["shared"]["project"]["tutorial"] = _hx_exports["shared"]["project"]["tutorial"] or _hx_e()
_hx_exports["shared"]["project"]["tutorial"]["tutorials"] = _hx_exports["shared"]["project"]["tutorial"]["tutorials"] or _hx_e()
;_hx_exports["shared"]["project"]["model"] = _hx_exports["shared"]["project"]["model"] or _hx_e()
_hx_exports["shared"]["project"]["model"]["units"] = _hx_exports["shared"]["project"]["model"]["units"] or _hx_e()
;_hx_exports["shared"]["project"]["enums"] = _hx_exports["shared"]["project"]["enums"] or _hx_e()
_hx_exports["shared"]["project"]["enums"]["_Intent"] = _hx_exports["shared"]["project"]["enums"]["_Intent"] or _hx_e()
;_hx_exports["shared"]["project"]["configs"] = _hx_exports["shared"]["project"]["configs"] or _hx_e()
_hx_exports["shared"]["project"]["configs"]["_GameConfig"] = _hx_exports["shared"]["project"]["configs"]["_GameConfig"] or _hx_e()
;_hx_exports["shared"]["base"] = _hx_exports["shared"]["base"] or _hx_e()
local Array = _hx_e()
local Date = _hx_e()
local DateTools = _hx_e()
__lua_lib_lrexlib_Rex = nil
local utf8name = "lua-utf8"
__lua_lib_luautf8_Utf8 = _G.require(utf8name)
local Lambda = _hx_e()
local Math = _hx_e()
local PCG32 = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
local Uuid = _hx_e()
__haxe_StackItem = _hx_e()
__haxe_CallStack = _hx_e()
__haxe_IMap = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe__Int32_Int32_Impl_ = _hx_e()
__haxe__Int64_Int64_Impl_ = _hx_e()
__haxe__Int64____Int64 = _hx_e()
__haxe_Json = _hx_e()
__haxe_Log = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_Resource = _hx_e()
__haxe_crypto_Adler32 = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_crypto_Base64 = _hx_e()
__haxe_crypto_BaseCode = _hx_e()
__haxe_ds_ArraySort = _hx_e()
__haxe_ds_IntMap = _hx_e()
__haxe_ds_List = _hx_e()
__haxe_ds__List_ListNode = _hx_e()
__haxe_ds__List_ListIterator = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_format_JsonParser = _hx_e()
__haxe_format_JsonPrinter = _hx_e()
__haxe_io_BytesBuffer = _hx_e()
__haxe_io_Input = _hx_e()
__haxe_io_BytesInput = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Eof = _hx_e()
__haxe_io_Error = _hx_e()
__haxe_zip_Compress = _hx_e()
__haxe_zip_Huffman = _hx_e()
__haxe_zip_HuffTools = _hx_e()
__haxe_zip__InflateImpl_Window = _hx_e()
__haxe_zip__InflateImpl_State = _hx_e()
__haxe_zip_InflateImpl = _hx_e()
__haxe_zip_Uncompress = _hx_e()
__jsoni18n_I18n = _hx_e()
__lua_Boot = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()
__lua_lib_luasocket_Socket = socket
__seedyrng_GeneratorInterface = _hx_e()
__seedyrng_Random = _hx_e()
__seedyrng_Xorshift128Plus = _hx_e()
__shared_Configs = _hx_e()
__shared_Shared = _hx_e()
__shared_base_Localization = _hx_e()
__shared_base_MatchWords = _hx_e()
__shared_base_NativeApi = _hx_e()
__shared_base_SpeechCommands = _hx_e()
__shared_base_event_EventHelper = _hx_e()
__shared_base_model_WorldBaseModel = _hx_e()
__shared_base_struct_ContextStruct = _hx_e()
__shared_base_utils_GameUtils = _hx_e()
__shared_base_utils_MathUtils = _hx_e()
__shared_base_utils_SpeechBuilder = _hx_e()
__shared_base_utils_SpeechBuilderSber = _hx_e()
__shared_project_analytics_AnalyticsHelper = _hx_e()
__shared_project_analytics_DtdAnalytics = _hx_e()
__shared_project_analytics_events_common_DtdAnalyticsBaseEvent = _hx_e()
__shared_project_analytics_events_common_DtdAnalyticsEvent = _hx_e()
__shared_project_analytics_events_GameLaunchEvent = _hx_e()
__shared_project_analytics_events_InputRequestRawEvent = _hx_e()
__shared_project_analytics_events_OutputResponseEvent = _hx_e()
__shared_project_analytics_events_OutputSpeechEvent = _hx_e()
__shared_project_analytics_events_ProcessErrorEvent = _hx_e()
__shared_project_analytics_events_ProcessIntentEvent = _hx_e()
__shared_project_analytics_events_common_TutorialCommon = _hx_e()
__shared_project_analytics_events_TutorialFinishEvent = _hx_e()
__shared_project_analytics_events_TutorialPartChangedEvent = _hx_e()
__shared_project_analytics_events_TutorialStartEvent = _hx_e()
__shared_project_analytics_events_predefined_GameSessionEvent = _hx_e()
__shared_project_analytics_events_predefined_PlayerInfoEvent = _hx_e()
__shared_project_analytics_events_predefined_TutorialEvent = _hx_e()
__shared_project_configs_GameConfig = _hx_e()
__shared_project_configs_UnitConfig = _hx_e()
__shared_project_configs_MageConfig = _hx_e()
__shared_project_enums_Intents = _hx_e()
__shared_project_enums__UnitType_UnitType_Impl_ = _hx_e()
__shared_project_enums__UnitType_MageType_Impl_ = _hx_e()
__shared_project_intent_processors_IntentSubProcessor = _hx_e()
__shared_project_intent_processors_IntentCheatsProcessor = _hx_e()
__shared_project_intent_processors_IntentLevelProcessor = _hx_e()
__shared_project_intent_processors_IntentModalProcessor = _hx_e()
__shared_project_intent_processors_IntentProcessor = _hx_e()
__shared_project_intent_processors_IntentTutorialProcessor = _hx_e()
__shared_project_model_EnemyModel = _hx_e()
__shared_project_model_IBasicUnit = _hx_e()
__shared_project_model_IBattleUnit = _hx_e()
__shared_project_model_LevelModel = _hx_e()
__shared_project_model_PlayerModel = _hx_e()
__shared_project_model_Restrictions = _hx_e()
__shared_project_model_World = _hx_e()
__shared_project_model_units_BattleUnitModel = _hx_e()
__shared_project_model_units_CastleUnitModel = _hx_e()
__shared_project_model_units_ResourceUnitModel = _hx_e()
__shared_project_storage_Storage = _hx_e()
__shared_project_timers_Timers = _hx_e()
__shared_project_tutorial_TutorialsModel = _hx_e()
__shared_project_tutorial_tutorials_TutorialBase = _hx_e()
__shared_project_utils_Base64 = _hx_e()
__shared_project_utils_TimeUtils = _hx_e()
__shared_project_utils_TranslationUtils = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = true
Array.prototype = _hx_a();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local _g3 = 0;
  while (_g3 < a.length) do 
    local i1 = a[_g3];
    _g3 = _g3 + 1;
    _g:push(i1);
  end;
  do return _g end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _gthis = self;
  local cur_length = 0;
  local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end});
  while (i:hasNext()) do 
    _G.table.insert(tbl, Std.string(i:next()));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    ret:push(self[_g - 1]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g2 = pos + len;
  local _g3 = self.length;
  while (_g2 < _g3) do 
    _g2 = _g2 + 1;
    local i1 = _g2 - 1;
    self[i1] = self[i1 + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  while (_g < len) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g2 = i;
      local _g11 = self.length - 1;
      while (_g2 < _g11) do 
        _g2 = _g2 + 1;
        local j = _g2 - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  while (_g < _end) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  local _gthis = self;
  local cur_length = 0;
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end}) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        self[_g - 1] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
Date.__name__ = true
Date.prototype = _hx_a();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getTime = function(self) 
  do return self.t * 1000 end
end
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end
Date.prototype.getDay = function(self) 
  do return self.d.wday - 1 end
end

Date.prototype.__class__ =  Date

DateTools.new = {}
DateTools.__name__ = true
DateTools.__format_get = function(d,e) 
  local e1 = e;
  if (e1) == "%" then 
    do return "%" end;
  elseif (e1) == "A" then 
    do return DateTools.DAY_NAMES[d:getDay()] end;
  elseif (e1) == "B" then 
    do return DateTools.MONTH_NAMES[d:getMonth()] end;
  elseif (e1) == "C" then 
    do return StringTools.lpad(Std.string(Std.int(d:getFullYear() / 100)), "0", 2) end;
  elseif (e1) == "D" then 
    do return DateTools.__format(d, "%m/%d/%y") end;
  elseif (e1) == "F" then 
    do return DateTools.__format(d, "%Y-%m-%d") end;
  elseif (e1) == "I" or (e1) == "l" then 
    local hour = _G.math.fmod(d:getHours(), 12);
    do return StringTools.lpad(Std.string((function() 
      local _hx_1
      if (hour == 0) then 
      _hx_1 = 12; else 
      _hx_1 = hour; end
      return _hx_1
    end )()), (function() 
      local _hx_2
      if (e == "I") then 
      _hx_2 = "0"; else 
      _hx_2 = " "; end
      return _hx_2
    end )(), 2) end;
  elseif (e1) == "M" then 
    do return StringTools.lpad(Std.string(d:getMinutes()), "0", 2) end;
  elseif (e1) == "R" then 
    do return DateTools.__format(d, "%H:%M") end;
  elseif (e1) == "S" then 
    do return StringTools.lpad(Std.string(d:getSeconds()), "0", 2) end;
  elseif (e1) == "T" then 
    do return DateTools.__format(d, "%H:%M:%S") end;
  elseif (e1) == "Y" then 
    do return Std.string(d:getFullYear()) end;
  elseif (e1) == "a" then 
    do return DateTools.DAY_SHORT_NAMES[d:getDay()] end;
  elseif (e1) == "b" or (e1) == "h" then 
    do return DateTools.MONTH_SHORT_NAMES[d:getMonth()] end;
  elseif (e1) == "d" then 
    do return StringTools.lpad(Std.string(d:getDate()), "0", 2) end;
  elseif (e1) == "e" then 
    do return Std.string(d:getDate()) end;
  elseif (e1) == "H" or (e1) == "k" then 
    do return StringTools.lpad(Std.string(d:getHours()), (function() 
      local _hx_3
      if (e == "H") then 
      _hx_3 = "0"; else 
      _hx_3 = " "; end
      return _hx_3
    end )(), 2) end;
  elseif (e1) == "m" then 
    do return StringTools.lpad(Std.string(d:getMonth() + 1), "0", 2) end;
  elseif (e1) == "n" then 
    do return "\n" end;
  elseif (e1) == "p" then 
    if (d:getHours() > 11) then 
      do return "PM" end;
    else
      do return "AM" end;
    end;
  elseif (e1) == "r" then 
    do return DateTools.__format(d, "%I:%M:%S %p") end;
  elseif (e1) == "s" then 
    do return Std.string(Std.int(d:getTime() / 1000)) end;
  elseif (e1) == "t" then 
    do return "\t" end;
  elseif (e1) == "u" then 
    local t = d:getDay();
    if (t == 0) then 
      do return "7" end;
    else
      do return Std.string(t) end;
    end;
  elseif (e1) == "w" then 
    do return Std.string(d:getDay()) end;
  elseif (e1) == "y" then 
    do return StringTools.lpad(Std.string(_G.math.fmod(d:getFullYear(), 100)), "0", 2) end;else
  _G.error(Std.string(Std.string("Date.format %") .. Std.string(e)) .. Std.string("- not implemented yet."),0); end;
end
DateTools.__format = function(d,f) 
  local r_b = ({});
  local p = 0;
  while (true) do 
    local startIndex = p;
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(f, "%", startIndex, true);
    local np = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if (np < 0) then 
      break;
    end;
    local len = np - p;
    local part;
    if (len == nil) then 
      local pos = p;
      local len1 = nil;
      len1 = __lua_lib_luautf8_Utf8.len(f);
      if (pos < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(f) + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      part = __lua_lib_luautf8_Utf8.sub(f, pos + 1, pos + len1);
    else
      local pos1 = p;
      local len2 = len;
      if ((len == nil) or (len > (pos1 + __lua_lib_luautf8_Utf8.len(f)))) then 
        len2 = __lua_lib_luautf8_Utf8.len(f);
      else
        if (len < 0) then 
          len2 = __lua_lib_luautf8_Utf8.len(f) + len;
        end;
      end;
      if (pos1 < 0) then 
        pos1 = __lua_lib_luautf8_Utf8.len(f) + pos1;
      end;
      if (pos1 < 0) then 
        pos1 = 0;
      end;
      part = __lua_lib_luautf8_Utf8.sub(f, pos1 + 1, pos1 + len2);
    end;
    _G.table.insert(r_b, part);
    local pos2 = np + 1;
    local len3 = 1;
    if (1 > (pos2 + __lua_lib_luautf8_Utf8.len(f))) then 
      len3 = __lua_lib_luautf8_Utf8.len(f);
    end;
    if (pos2 < 0) then 
      pos2 = __lua_lib_luautf8_Utf8.len(f) + pos2;
    end;
    if (pos2 < 0) then 
      pos2 = 0;
    end;
    _G.table.insert(r_b, Std.string(DateTools.__format_get(d, __lua_lib_luautf8_Utf8.sub(f, pos2 + 1, pos2 + len3))));
    p = np + 2;
  end;
  local len4 = __lua_lib_luautf8_Utf8.len(f) - p;
  local part1;
  if (len4 == nil) then 
    local pos3 = p;
    local len5 = nil;
    len5 = __lua_lib_luautf8_Utf8.len(f);
    if (pos3 < 0) then 
      pos3 = __lua_lib_luautf8_Utf8.len(f) + pos3;
    end;
    if (pos3 < 0) then 
      pos3 = 0;
    end;
    part1 = __lua_lib_luautf8_Utf8.sub(f, pos3 + 1, pos3 + len5);
  else
    local pos4 = p;
    local len6 = len4;
    if ((len4 == nil) or (len4 > (pos4 + __lua_lib_luautf8_Utf8.len(f)))) then 
      len6 = __lua_lib_luautf8_Utf8.len(f);
    else
      if (len4 < 0) then 
        len6 = __lua_lib_luautf8_Utf8.len(f) + len4;
      end;
    end;
    if (pos4 < 0) then 
      pos4 = __lua_lib_luautf8_Utf8.len(f) + pos4;
    end;
    if (pos4 < 0) then 
      pos4 = 0;
    end;
    part1 = __lua_lib_luautf8_Utf8.sub(f, pos4 + 1, pos4 + len6);
  end;
  _G.table.insert(r_b, part1);
  do return _G.table.concat(r_b) end;
end
DateTools.format = function(d,f) 
  do return DateTools.__format(d, f) end;
end

Lambda.new = {}
Lambda.__name__ = true
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do 
    if (x:next() == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.filter = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do 
    local x1 = x:next();
    if (f(x1)) then 
      _g:push(x1);
    end;
  end;
  do return _g end;
end
Lambda.count = function(it,pred) 
  local n = 0;
  if (pred == nil) then 
    local _ = it:iterator();
    while (_:hasNext()) do 
      _:next();
      n = n + 1;
    end;
  else
    local x = it:iterator();
    while (x:hasNext()) do 
      if (pred(x:next())) then 
        n = n + 1;
      end;
    end;
  end;
  do return n end;
end

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

PCG32.new = function() 
  local self = _hx_new(PCG32.prototype)
  PCG32.super(self)
  return self
end
PCG32.super = function(self) 
  self.state = __haxe__Int64____Int64.new(-2059646490, 1955588763);
  self.inc = __haxe__Int64____Int64.new(-633456181, -1799791653);
  self.MULTIPLIER = __haxe__Int64____Int64.new(1481765933, 1284865837);
  self:seed(Std.int(Sys.time() * 1000));
end
PCG32.__name__ = true
PCG32.prototype = _hx_a();
PCG32.prototype.state= nil;
PCG32.prototype.inc= nil;
PCG32.prototype.MULTIPLIER= nil;
PCG32.prototype.seed = function(self,rnd) 
  local x = _hx_bit.lshift(rnd,31);
  local high = __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.shr(x, 31), __haxe__Int32_Int32_Impl_.shr(rnd, 31));
  local low = __haxe__Int32_Int32_Impl_["or"](x, rnd);
  local x1 = _hx_bit.lshift(rnd,31);
  local high1 = __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.shr(x1, 31), __haxe__Int32_Int32_Impl_.shr(rnd, 31));
  local low1 = __haxe__Int32_Int32_Impl_["or"](x1, rnd);
  self.state = __haxe__Int64____Int64.new(0, 0);
  local a = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(high1,1)), _hx_bit.rshift(low1,31)), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(low1,1)));
  local high2 = __haxe__Int32_Int32_Impl_.shr(1, 31);
  self.inc = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_["or"](a.high, high2), __haxe__Int32_Int32_Impl_["or"](a.low, 1));
  self:pcg32Random();
  local a1 = self.state;
  local high3 = __haxe__Int32_Int32_Impl_.clamp(a1.high + high);
  local low2 = __haxe__Int32_Int32_Impl_.clamp(a1.low + low);
  if (__haxe__Int32_Int32_Impl_.ucompare(low2, a1.low) < 0) then 
    high3 = high3 + 1;
    high3 = __haxe__Int32_Int32_Impl_.clamp(high3);
  end;
  self.state = __haxe__Int64____Int64.new(high3, low2);
  self:pcg32Random();
end
PCG32.prototype.pcg32Random = function(self) 
  local a = self.state;
  local a1 = __haxe__Int64____Int64.new(_hx_bit.rshift(a.high,18), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a.high,14)), _hx_bit.rshift(a.low,18)));
  local b = self.state;
  local high = __haxe__Int32_Int32_Impl_.xor(a1.high, b.high);
  local low = __haxe__Int32_Int32_Impl_.xor(a1.low, b.low);
  local xorshifted = __haxe__Int64____Int64.new(_hx_bit.rshift(high,27), __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(high,5)), _hx_bit.rshift(low,27))).low;
  local rot = __haxe__Int64____Int64.new(0, _hx_bit.rshift(self.state.high,27)).low;
  self.state = __haxe__Int64_Int64_Impl_.mul(self.state, self.MULTIPLIER);
  local a2 = self.state;
  local a3 = self.inc;
  local high1 = __haxe__Int32_Int32_Impl_.shr(1, 31);
  local high2 = __haxe__Int32_Int32_Impl_["or"](a3.high, high1);
  local low1 = __haxe__Int32_Int32_Impl_["or"](a3.low, 1);
  local high3 = __haxe__Int32_Int32_Impl_.clamp(a2.high + high2);
  local low2 = __haxe__Int32_Int32_Impl_.clamp(a2.low + low1);
  if (__haxe__Int32_Int32_Impl_.ucompare(low2, a2.low) < 0) then 
    high3 = high3 + 1;
    high3 = __haxe__Int32_Int32_Impl_.clamp(high3);
  end;
  self.state = __haxe__Int64____Int64.new(high3, low2);
  do return __haxe__Int32_Int32_Impl_["or"](__haxe__Int32_Int32_Impl_.shr(xorshifted, rot), __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(xorshifted,(_hx_bit.band(__haxe__Int32_Int32_Impl_.clamp(_hx_bit.bnot(rot) + 1),31))))) end
end
PCG32.prototype.random = function(self,n) 
  if (n <= 0) then 
    _G.error("n must be positive",0);
  end;
  local bits = 0;
  local val = 0;
  while (true) do 
    bits = _hx_bit.rshift(self:pcg32Random(),1);
    val = _G.math.fmod(bits, n);
    if (not (((bits - val) + (n - 1)) < 0)) then 
      break;
    end;
  end;
  do return val end
end
PCG32.prototype.randomFromRange = function(self,min,max) 
  if (min >= max) then 
    _G.error("min must be less than max",0);
  end;
  do return self:random(max - min) + min end
end

PCG32.prototype.__class__ =  PCG32

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
    
      local _hx_1 = _hx_result
      local e = _hx_1
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if ((o ~= nil) and (o.__name__ == nil)) then 
      self_arg = true;
    end;
    if (self_arg) then 
      do return func(o, _hx_table.unpack(args, 0, args.length - 1)) end;
    else
      do return func(_hx_table.unpack(args, 0, args.length - 1)) end;
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    local _g = _hx_tab_array({}, 0);
    local f = __lua_Boot.fieldIterator(o);
    while (f:hasNext()) do 
      local f1 = f:next();
      _g:push(f1);
    end;
    do return _g end;
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.copy = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o, f);
  end;
  do return o2 end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return __lua_lib_luautf8_Utf8.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return __lua_lib_luautf8_Utf8.char(code) end;
end
String.prototype = _hx_a();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return __lua_lib_luautf8_Utf8.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return __lua_lib_luautf8_Utf8.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = __lua_lib_luautf8_Utf8.find(self, str, startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if ((p == -1) or (p > startIndex)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(delimiter) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(self, delimiter, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(self)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, newidx - 1));
      idx = newidx + __lua_lib_luautf8_Utf8.len(delimiter);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(self, idx, __lua_lib_luautf8_Utf8.len(self)));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = __lua_lib_luautf8_Utf8.len(self);
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return __lua_lib_luautf8_Utf8.sub(self, endIndex + 1, startIndex) end;
  else
    do return __lua_lib_luautf8_Utf8.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return __lua_lib_luautf8_Utf8.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(self)))) then 
    len = __lua_lib_luautf8_Utf8.len(self);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(self) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(self) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return __lua_lib_luautf8_Utf8.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return __lua_Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x, "^[ \t\r\n]*([%-+]*0[xX][%da-fA-F]*)");
  if (hexMatch ~= nil) then 
    local sign;
    local _g = __lua_lib_luautf8_Utf8.byte(hexMatch, 1);
    if (_g) == 43 then 
      sign = 1;
    elseif (_g) == 45 then 
      sign = -1;else
    sign = 0; end;
    local pos = (function() 
      local _hx_1
      if (sign == 0) then 
      _hx_1 = 2; else 
      _hx_1 = 3; end
      return _hx_1
    end )();
    local len = nil;
    len = __lua_lib_luautf8_Utf8.len(hexMatch);
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(hexMatch) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return (function() 
      local _hx_2
      if (sign == -1) then 
      _hx_2 = -1; else 
      _hx_2 = 1; end
      return _hx_2
    end )() * _G.tonumber(__lua_lib_luautf8_Utf8.sub(hexMatch, pos + 1, pos + len), 16) end;
  else
    local intMatch = _G.string.match(x, "^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  local pos = __lua_lib_luautf8_Utf8.len(digitMatch);
  local len = nil;
  if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(x)))) then 
    len = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(x) + len;
    end;
  end;
  if (pos < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(x) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos + 1, pos + len);
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  local pos1 = __lua_lib_luautf8_Utf8.len(decimalMatch);
  local len1 = nil;
  if ((len1 == nil) or (len1 > (pos1 + __lua_lib_luautf8_Utf8.len(x)))) then 
    len1 = __lua_lib_luautf8_Utf8.len(x);
  else
    if (len1 < 0) then 
      len1 = __lua_lib_luautf8_Utf8.len(x) + len1;
    end;
  end;
  if (pos1 < 0) then 
    pos1 = __lua_lib_luautf8_Utf8.len(x) + pos1;
  end;
  if (pos1 < 0) then 
    pos1 = 0;
  end;
  x = __lua_lib_luautf8_Utf8.sub(x, pos1 + 1, pos1 + len1);
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_a();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;

StringBuf.prototype.__class__ =  StringBuf

StringTools.new = {}
StringTools.__name__ = true
StringTools.isSpace = function(s,pos) 
  if (((__lua_lib_luautf8_Utf8.len(s) == 0) or (pos < 0)) or (pos >= __lua_lib_luautf8_Utf8.len(s))) then 
    do return false end;
  end;
  local c = __lua_lib_luautf8_Utf8.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local pos = r;
    local len = l - r;
    if ((len == nil) or (len > (pos + __lua_lib_luautf8_Utf8.len(s)))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    if (pos < 0) then 
      pos = __lua_lib_luautf8_Utf8.len(s) + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = __lua_lib_luautf8_Utf8.len(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do 
    r = r + 1;
  end;
  if (r > 0) then 
    local len = l - r;
    if ((len == nil) or (len > __lua_lib_luautf8_Utf8.len(s))) then 
      len = __lua_lib_luautf8_Utf8.len(s);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(s) + len;
      end;
    end;
    do return __lua_lib_luautf8_Utf8.sub(s, 1, len) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l) 
  if (__lua_lib_luautf8_Utf8.len(c) <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  l = l - __lua_lib_luautf8_Utf8.len(s);
  while (buf_length < l) do 
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + __lua_lib_luautf8_Utf8.len(str);
  end;
  _G.table.insert(buf_b, Std.string(s));
  do return _G.table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (__lua_lib_luautf8_Utf8.len(sub) > 0) then 
      newidx = __lua_lib_luautf8_Utf8.find(s, sub, idx, true);
    else
      if (idx >= __lua_lib_luautf8_Utf8.len(s)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, newidx - 1));
      idx = newidx + __lua_lib_luautf8_Utf8.len(sub);
    else
      ret:push(__lua_lib_luautf8_Utf8.sub(s, idx, __lua_lib_luautf8_Utf8.len(s)));
      idx = nil;
    end;
  end;
  do return ret:join(by) end;
end

Sys.new = {}
Sys.__name__ = true
Sys.time = function() 
  do return __lua_lib_luasocket_Socket.gettime() end;
end
_hxClasses["ValueType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
Type.__name__ = true
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o1 = o;
  if (__lua_Boot.__instanceof(o1, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o1, String)) then 
      do return String end;
    else
      local cl = o1.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do 
    local f = __lua_Boot.fieldIterator(p);
    while (f:hasNext()) do 
      local f1 = f:next();
      if (not Lambda.has(a, f1)) then 
        a:push(f1);
      end;
    end;
    local mt = _G.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end

Uuid.new = {}
Uuid.__name__ = true
Uuid.v4 = function(randBytes) 
  if (Uuid.rng == nil) then 
    Uuid.rng = PCG32.new();
  end;
  local buffer = __haxe_io_Bytes.alloc(16);
  local v = Uuid.rng:randomFromRange(0, 255);
  buffer.b[0] = _hx_bit.band(v,255);
  local v1 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[1] = _hx_bit.band(v1,255);
  local v2 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[2] = _hx_bit.band(v2,255);
  local v3 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[3] = _hx_bit.band(v3,255);
  local v4 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[4] = _hx_bit.band(v4,255);
  local v5 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[5] = _hx_bit.band(v5,255);
  local v6 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[6] = _hx_bit.band(v6,255);
  local v7 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[7] = _hx_bit.band(v7,255);
  local v8 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[8] = _hx_bit.band(v8,255);
  local v9 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[9] = _hx_bit.band(v9,255);
  local v10 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[10] = _hx_bit.band(v10,255);
  local v11 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[11] = _hx_bit.band(v11,255);
  local v12 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[12] = _hx_bit.band(v12,255);
  local v13 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[13] = _hx_bit.band(v13,255);
  local v14 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[14] = _hx_bit.band(v14,255);
  local v15 = Uuid.rng:randomFromRange(0, 255);
  buffer.b[15] = _hx_bit.band(v15,255);
  buffer.b[6] = _hx_bit.band((_hx_bit.bor(_hx_bit.band(buffer.b[6],15),64)),255);
  buffer.b[8] = _hx_bit.band((_hx_bit.bor(_hx_bit.band(buffer.b[8],63),128)),255);
  do return Uuid.unparse(buffer) end;
end
Uuid.unparse = function(data) 
  local hex = data:toHex();
  local len = 8;
  if (8 > __lua_lib_luautf8_Utf8.len(hex)) then 
    len = __lua_lib_luautf8_Utf8.len(hex);
  end;
  local uuid = Std.string(__lua_lib_luautf8_Utf8.sub(hex, 1, len)) .. Std.string("-");
  local len1 = 4;
  if (4 > (8 + __lua_lib_luautf8_Utf8.len(hex))) then 
    len1 = __lua_lib_luautf8_Utf8.len(hex);
  end;
  local uuid1 = Std.string(Std.string(uuid) .. Std.string(__lua_lib_luautf8_Utf8.sub(hex, 9, 8 + len1))) .. Std.string("-");
  local len2 = 4;
  if (4 > (12 + __lua_lib_luautf8_Utf8.len(hex))) then 
    len2 = __lua_lib_luautf8_Utf8.len(hex);
  end;
  local uuid2 = Std.string(Std.string(uuid1) .. Std.string(__lua_lib_luautf8_Utf8.sub(hex, 13, 12 + len2))) .. Std.string("-");
  local len3 = 4;
  if (4 > (16 + __lua_lib_luautf8_Utf8.len(hex))) then 
    len3 = __lua_lib_luautf8_Utf8.len(hex);
  end;
  local uuid3 = Std.string(Std.string(uuid2) .. Std.string(__lua_lib_luautf8_Utf8.sub(hex, 17, 16 + len3))) .. Std.string("-");
  local len4 = 12;
  if (12 > (20 + __lua_lib_luautf8_Utf8.len(hex))) then 
    len4 = __lua_lib_luautf8_Utf8.len(hex);
  end;
  do return Std.string(uuid3) .. Std.string(__lua_lib_luautf8_Utf8.sub(hex, 21, 20 + len4)) end;
end
_hxClasses["haxe.StackItem"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 

__haxe_CallStack.new = {}
__haxe_CallStack.__name__ = true
__haxe_CallStack.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end
__haxe_CallStack.toString = function(stack) 
  local b = StringBuf.new();
  local _g = 0;
  while (_g < stack.length) do 
    local s = stack[_g];
    _g = _g + 1;
    _G.table.insert(b.b, "\nCalled from ");
    b.length = b.length + __lua_lib_luautf8_Utf8.len("\nCalled from ");
    __haxe_CallStack.itemToString(b, s);
  end;
  do return _G.table.concat(b.b) end;
end
__haxe_CallStack.itemToString = function(b,s) 
  local tmp = s[1];
  if (tmp) == 0 then 
    _G.table.insert(b.b, "a C function");
    b.length = b.length + __lua_lib_luautf8_Utf8.len("a C function");
  elseif (tmp) == 1 then 
    _G.table.insert(b.b, "module ");
    b.length = b.length + __lua_lib_luautf8_Utf8.len("module ");
    local str = Std.string(s[2]);
    _G.table.insert(b.b, str);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 2 then 
    local _g4 = s[5];
    local _g1 = s[2];
    if (_g1 ~= nil) then 
      __haxe_CallStack.itemToString(b, _g1);
      _G.table.insert(b.b, " (");
      b.length = b.length + __lua_lib_luautf8_Utf8.len(" (");
    end;
    local str1 = Std.string(s[3]);
    _G.table.insert(b.b, str1);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str1);
    _G.table.insert(b.b, " line ");
    b.length = b.length + __lua_lib_luautf8_Utf8.len(" line ");
    local str2 = Std.string(s[4]);
    _G.table.insert(b.b, str2);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str2);
    if (_g4 ~= nil) then 
      _G.table.insert(b.b, " column ");
      b.length = b.length + __lua_lib_luautf8_Utf8.len(" column ");
      local str3 = Std.string(_g4);
      _G.table.insert(b.b, str3);
      b.length = b.length + __lua_lib_luautf8_Utf8.len(str3);
    end;
    if (_g1 ~= nil) then 
      _G.table.insert(b.b, ")");
      b.length = b.length + __lua_lib_luautf8_Utf8.len(")");
    end;
  elseif (tmp) == 3 then 
    local _g6 = s[2];
    local str4 = Std.string((function() 
      local _hx_1
      if (_g6 == nil) then 
      _hx_1 = "<unknown>"; else 
      _hx_1 = _g6; end
      return _hx_1
    end )());
    _G.table.insert(b.b, str4);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str4);
    _G.table.insert(b.b, ".");
    b.length = b.length + __lua_lib_luautf8_Utf8.len(".");
    local str5 = Std.string(s[3]);
    _G.table.insert(b.b, str5);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str5);
  elseif (tmp) == 4 then 
    _G.table.insert(b.b, "local function #");
    b.length = b.length + __lua_lib_luautf8_Utf8.len("local function #");
    local str6 = Std.string(s[2]);
    _G.table.insert(b.b, str6);
    b.length = b.length + __lua_lib_luautf8_Utf8.len(str6); end;
end

__haxe_IMap.new = {}
__haxe_IMap.__name__ = true
__haxe_IMap.prototype = _hx_a();
__haxe_IMap.prototype.get= nil;
__haxe_IMap.prototype.set= nil;
__haxe_IMap.prototype.exists= nil;
__haxe_IMap.prototype.iterator= nil;

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe_EntryPoint.new = {}
__haxe_EntryPoint.__name__ = true
__haxe_EntryPoint.processEvents = function() 
  while (true) do 
    local f = __haxe_EntryPoint.pending:shift();
    if (f == nil) then 
      break;
    end;
    f();
  end;
  local time = __haxe_MainLoop.tick();
  if (not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return time end;
end
__haxe_EntryPoint.run = function() 
  while (not (__haxe_EntryPoint.processEvents() < 0)) do 
  end;
end

__haxe__Int32_Int32_Impl_.new = {}
__haxe__Int32_Int32_Impl_.__name__ = true
__haxe__Int32_Int32_Impl_.mul = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp((a * (_hx_bit.band(b,65535))) + __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(a * (_hx_bit.rshift(b,16)),16))) end;
end
__haxe__Int32_Int32_Impl_["or"] = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.xor = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.bxor(a,b)) end;
end
__haxe__Int32_Int32_Impl_.shr = function(a,b) 
  do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit.arshift(a,b)) end;
end
__haxe__Int32_Int32_Impl_.ucompare = function(a,b) 
  if (a < 0) then 
    if (b < 0) then 
      do return __haxe__Int32_Int32_Impl_.clamp(_hx_bit_clamp(_hx_bit.bnot(b)) - _hx_bit_clamp(_hx_bit.bnot(a))) end;
    else
      do return 1 end;
    end;
  end;
  if (b < 0) then 
    do return -1 end;
  else
    do return __haxe__Int32_Int32_Impl_.clamp(a - b) end;
  end;
end
__haxe__Int32_Int32_Impl_.clamp = function(x) 
  do return _hx_bit_clamp(x) end;
end

__haxe__Int64_Int64_Impl_.new = {}
__haxe__Int64_Int64_Impl_.__name__ = true
__haxe__Int64_Int64_Impl_.mul = function(a,b) 
  local al = _hx_bit.band(a.low,65535);
  local ah = _hx_bit.rshift(a.low,16);
  local bl = _hx_bit.band(b.low,65535);
  local bh = _hx_bit.rshift(b.low,16);
  local p00 = __haxe__Int32_Int32_Impl_.mul(al, bl);
  local p10 = __haxe__Int32_Int32_Impl_.mul(ah, bl);
  local p01 = __haxe__Int32_Int32_Impl_.mul(al, bh);
  local low = p00;
  local high = __haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.mul(ah, bh) + (_hx_bit.rshift(p01,16))) + (_hx_bit.rshift(p10,16)));
  p01 = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(p01,16));
  low = __haxe__Int32_Int32_Impl_.clamp(p00 + p01);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, p01) < 0) then 
    high = high + 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  p10 = __haxe__Int32_Int32_Impl_.clamp(_hx_bit.lshift(p10,16));
  low = __haxe__Int32_Int32_Impl_.clamp(low + p10);
  if (__haxe__Int32_Int32_Impl_.ucompare(low, p10) < 0) then 
    high = high + 1;
    high = __haxe__Int32_Int32_Impl_.clamp(high);
  end;
  high = __haxe__Int32_Int32_Impl_.clamp(high + __haxe__Int32_Int32_Impl_.clamp(__haxe__Int32_Int32_Impl_.mul(a.low, b.high) + __haxe__Int32_Int32_Impl_.mul(a.high, b.low)));
  do return __haxe__Int64____Int64.new(high, low) end;
end

__haxe__Int64____Int64.new = function(high,low) 
  local self = _hx_new(__haxe__Int64____Int64.prototype)
  __haxe__Int64____Int64.super(self,high,low)
  return self
end
__haxe__Int64____Int64.super = function(self,high,low) 
  self.high = high;
  self.low = low;
end
__haxe__Int64____Int64.__name__ = true
__haxe__Int64____Int64.prototype = _hx_a();
__haxe__Int64____Int64.prototype.high= nil;
__haxe__Int64____Int64.prototype.low= nil;

__haxe__Int64____Int64.prototype.__class__ =  __haxe__Int64____Int64

__haxe_Json.new = {}
__haxe_Json.__name__ = true
__haxe_Json.parseFast = function(text) 
  do return __haxe_format_JsonParser.new(text):doParse() end;
end
__haxe_Json.parse = function(text) 
  do return __haxe_format_JsonParser.new(text):doParse() end;
end
__haxe_Json.stringify = function(value,replacer,space) 
  do return __haxe_format_JsonPrinter.print(value, replacer, space) end;
end

__haxe_Log.new = {}
__haxe_Log.__name__ = true
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v1 = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v1))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_MainEvent.new = function(f,p) 
  local self = _hx_new(__haxe_MainEvent.prototype)
  __haxe_MainEvent.super(self,f,p)
  return self
end
__haxe_MainEvent.super = function(self,f,p) 
  self.isBlocking = true;
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -_G.math.huge;
end
__haxe_MainEvent.__name__ = true
__haxe_MainEvent.prototype = _hx_a();
__haxe_MainEvent.prototype.f= nil;
__haxe_MainEvent.prototype.prev= nil;
__haxe_MainEvent.prototype.next= nil;
__haxe_MainEvent.prototype.isBlocking= nil;
__haxe_MainEvent.prototype.nextRun= nil;
__haxe_MainEvent.prototype.priority= nil;

__haxe_MainEvent.prototype.__class__ =  __haxe_MainEvent

__haxe_MainLoop.new = {}
__haxe_MainLoop.__name__ = true
__haxe_MainLoop.hasEvents = function() 
  local p = __haxe_MainLoop.pending;
  while (p ~= nil) do 
    if (p.isBlocking) then 
      do return true end;
    end;
    p = p.next;
  end;
  do return false end;
end
__haxe_MainLoop.sortEvents = function() 
  local list = __haxe_MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g = 0;
      local _g1 = insize;
      while (_g < _g1) do 
        _g = _g + 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
      end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
      end;
      p = q;
    end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
  end;
  list.prev = nil;
  __haxe_MainLoop.pending = list;
end
__haxe_MainLoop.tick = function() 
  __haxe_MainLoop.sortEvents();
  local e = __haxe_MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if (wt <= 0) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
  end;
  do return wait end;
end

__haxe_Resource.new = {}
__haxe_Resource.__name__ = true
__haxe_Resource.getString = function(name) 
  local _g = 0;
  local _g1 = __haxe_Resource.content;
  while (_g < _g1.length) do 
    local x = _g1[_g];
    _g = _g + 1;
    if (x.name == name) then 
      if (x.str ~= nil) then 
        do return x.str end;
      end;
      do return __haxe_crypto_Base64.decode(x.data):toString() end;
    end;
  end;
  do return nil end;
end

__haxe_crypto_Adler32.new = function() 
  local self = _hx_new(__haxe_crypto_Adler32.prototype)
  __haxe_crypto_Adler32.super(self)
  return self
end
__haxe_crypto_Adler32.super = function(self) 
  self.a1 = 1;
  self.a2 = 0;
end
__haxe_crypto_Adler32.__name__ = true
__haxe_crypto_Adler32.read = function(i) 
  local a = __haxe_crypto_Adler32.new();
  local a2a = i:readByte();
  local a2b = i:readByte();
  a.a1 = _hx_bit.bor(_hx_bit.lshift(i:readByte(),8),i:readByte());
  a.a2 = _hx_bit.bor(_hx_bit.lshift(a2a,8),a2b);
  do return a end;
end
__haxe_crypto_Adler32.prototype = _hx_a();
__haxe_crypto_Adler32.prototype.a1= nil;
__haxe_crypto_Adler32.prototype.a2= nil;
__haxe_crypto_Adler32.prototype.update = function(self,b,pos,len) 
  local a1 = self.a1;
  local a2 = self.a2;
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    a1 = _G.math.fmod((a1 + b.b[_g - 1]), 65521);
    a2 = _G.math.fmod((a2 + a1), 65521);
  end;
  self.a1 = a1;
  self.a2 = a2;
end
__haxe_crypto_Adler32.prototype.equals = function(self,a) 
  if (a.a1 == self.a1) then 
    do return a.a2 == self.a2 end;
  else
    do return false end;
  end;
end

__haxe_crypto_Adler32.prototype.__class__ =  __haxe_crypto_Adler32

__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
__haxe_io_Bytes.__name__ = true
__haxe_io_Bytes.alloc = function(length) 
  local a = Array.new();
  local _g = 0;
  while (_g < length) do 
    _g = _g + 1;
    a:push(0);
  end;
  do return __haxe_io_Bytes.new(length, a) end;
end
__haxe_io_Bytes.ofString = function(s,encoding) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _G.string.len(s);
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    _g:push(_G.string.byte(s, (_g1 - 1) + 1));
  end;
  do return __haxe_io_Bytes.new(_g.length, _g) end;
end
__haxe_io_Bytes.prototype = _hx_a();
__haxe_io_Bytes.prototype.length= nil;
__haxe_io_Bytes.prototype.b= nil;
__haxe_io_Bytes.prototype.blit = function(self,pos,src,srcpos,len) 
  if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local b1 = self.b;
  local b2 = src.b;
  if ((b1 == b2) and (pos > srcpos)) then 
    local i = len;
    while (i > 0) do 
      i = i - 1;
      b1[i + pos] = b2[i + srcpos];
    end;
    do return end;
  end;
  local _g = 0;
  while (_g < len) do 
    _g = _g + 1;
    local i1 = _g - 1;
    b1[i1 + pos] = b2[i1 + srcpos];
  end;
end
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end
__haxe_io_Bytes.prototype.toString = function(self) 
  do return self:getString(0, self.length) end
end
__haxe_io_Bytes.prototype.toHex = function(self) 
  local s_b = ({});
  local chars = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = __lua_lib_luautf8_Utf8.len("0123456789abcdef");
  while (_g < _g1) do 
    _g = _g + 1;
    chars:push(__lua_lib_luautf8_Utf8.byte("0123456789abcdef", (_g - 1) + 1));
  end;
  local _g2 = 0;
  local _g3 = self.length;
  while (_g2 < _g3) do 
    _g2 = _g2 + 1;
    local c = self.b[_g2 - 1];
    _G.table.insert(s_b, __lua_lib_luautf8_Utf8.char(chars[_hx_bit.arshift(c,4)]));
    _G.table.insert(s_b, __lua_lib_luautf8_Utf8.char(chars[_hx_bit.band(c,15)]));
  end;
  do return _G.table.concat(s_b) end
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes

__haxe_crypto_Base64.new = {}
__haxe_crypto_Base64.__name__ = true
__haxe_crypto_Base64.decode = function(str,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  if (complement) then 
    while (__lua_lib_luautf8_Utf8.byte(str, (__lua_lib_luautf8_Utf8.len(str) - 1) + 1) == 61) do 
      local len = -1;
      if (-1 > __lua_lib_luautf8_Utf8.len(str)) then 
        len = __lua_lib_luautf8_Utf8.len(str);
      else
        len = __lua_lib_luautf8_Utf8.len(str) + -1;
      end;
      str = __lua_lib_luautf8_Utf8.sub(str, 1, len);
    end;
  end;
  do return __haxe_crypto_BaseCode.new(__haxe_crypto_Base64.BYTES):decodeBytes(__haxe_io_Bytes.ofString(str)) end;
end

__haxe_crypto_BaseCode.new = function(base) 
  local self = _hx_new(__haxe_crypto_BaseCode.prototype)
  __haxe_crypto_BaseCode.super(self,base)
  return self
end
__haxe_crypto_BaseCode.super = function(self,base) 
  local len = base.length;
  local nbits = 1;
  while (len > (_hx_bit.lshift(1,nbits))) do 
    nbits = nbits + 1;
  end;
  if ((nbits > 8) or (len ~= (_hx_bit.lshift(1,nbits)))) then 
    _G.error("BaseCode : base length must be a power of two.",0);
  end;
  self.base = base;
  self.nbits = nbits;
end
__haxe_crypto_BaseCode.__name__ = true
__haxe_crypto_BaseCode.prototype = _hx_a();
__haxe_crypto_BaseCode.prototype.base= nil;
__haxe_crypto_BaseCode.prototype.nbits= nil;
__haxe_crypto_BaseCode.prototype.tbl= nil;
__haxe_crypto_BaseCode.prototype.encodeBytes = function(self,b) 
  local nbits = self.nbits;
  local base = self.base;
  local size = Std.int((b.length * 8) / nbits);
  local out = __haxe_io_Bytes.alloc(size + (function() 
    local _hx_1
    if ((_G.math.fmod(b.length * 8, nbits)) == 0) then 
    _hx_1 = 0; else 
    _hx_1 = 1; end
    return _hx_1
  end )());
  local buf = 0;
  local curbits = 0;
  local mask = (_hx_bit.lshift(1,nbits)) - 1;
  local pin = 0;
  local pout = 0;
  while (pout < size) do 
    while (curbits < nbits) do 
      curbits = curbits + 8;
      buf = _hx_bit.lshift(buf,8);
      pin = pin + 1;
      buf = _hx_bit.bor(buf,b.b[pin - 1]);
    end;
    curbits = curbits - nbits;
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.arshift(buf,curbits),mask)],255);
  end;
  if (curbits > 0) then 
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.lshift(buf,nbits - curbits),mask)],255);
  end;
  do return out end
end
__haxe_crypto_BaseCode.prototype.initTable = function(self) 
  local tbl = Array.new();
  local _g = 0;
  while (_g < 256) do 
    _g = _g + 1;
    tbl[_g - 1] = -1;
  end;
  local _g1 = 0;
  local _g2 = self.base.length;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    tbl[self.base.b[i]] = i;
  end;
  self.tbl = tbl;
end
__haxe_crypto_BaseCode.prototype.decodeBytes = function(self,b) 
  local nbits = self.nbits;
  if (self.tbl == nil) then 
    self:initTable();
  end;
  local tbl = self.tbl;
  local size = _hx_bit.arshift(b.length * nbits,3);
  local out = __haxe_io_Bytes.alloc(size);
  local buf = 0;
  local curbits = 0;
  local pin = 0;
  local pout = 0;
  while (pout < size) do 
    while (curbits < 8) do 
      curbits = curbits + nbits;
      buf = _hx_bit.lshift(buf,nbits);
      pin = pin + 1;
      local i = tbl[b.b[pin - 1]];
      if (i == -1) then 
        _G.error("BaseCode : invalid encoded char",0);
      end;
      buf = _hx_bit.bor(buf,i);
    end;
    curbits = curbits - 8;
    pout = pout + 1;
    out.b[pout - 1] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(buf,curbits),255),255);
  end;
  do return out end
end

__haxe_crypto_BaseCode.prototype.__class__ =  __haxe_crypto_BaseCode

__haxe_ds_ArraySort.new = {}
__haxe_ds_ArraySort.__name__ = true
__haxe_ds_ArraySort.sort = function(a,cmp) 
  __haxe_ds_ArraySort.rec(a, cmp, 0, a.length);
end
__haxe_ds_ArraySort.rec = function(a,cmp,from,to) 
  local middle = _hx_bit.arshift(from + to,1);
  if ((to - from) < 12) then 
    if (to <= from) then 
      do return end;
    end;
    local _g = from + 1;
    while (_g < to) do 
      _g = _g + 1;
      local j = _g - 1;
      while (j > from) do 
        if (cmp(a[j], a[j - 1]) < 0) then 
          __haxe_ds_ArraySort.swap(a, j - 1, j);
        else
          break;
        end;
        j = j - 1;
      end;
    end;
    do return end;
  end;
  __haxe_ds_ArraySort.rec(a, cmp, from, middle);
  __haxe_ds_ArraySort.rec(a, cmp, middle, to);
  __haxe_ds_ArraySort.doMerge(a, cmp, from, middle, to, middle - from, to - middle);
end
__haxe_ds_ArraySort.doMerge = function(a,cmp,from,pivot,to,len1,len2) 
  local first_cut;
  local second_cut;
  local len11;
  local len22;
  if ((len1 == 0) or (len2 == 0)) then 
    do return end;
  end;
  if ((len1 + len2) == 2) then 
    if (cmp(a[pivot], a[from]) < 0) then 
      __haxe_ds_ArraySort.swap(a, pivot, from);
    end;
    do return end;
  end;
  if (len1 > len2) then 
    len11 = _hx_bit.arshift(len1,1);
    first_cut = from + len11;
    second_cut = __haxe_ds_ArraySort.lower(a, cmp, pivot, to, first_cut);
    len22 = second_cut - pivot;
  else
    len22 = _hx_bit.arshift(len2,1);
    second_cut = pivot + len22;
    first_cut = __haxe_ds_ArraySort.upper(a, cmp, from, pivot, second_cut);
    len11 = first_cut - from;
  end;
  __haxe_ds_ArraySort.rotate(a, cmp, first_cut, pivot, second_cut);
  local new_mid = first_cut + len22;
  __haxe_ds_ArraySort.doMerge(a, cmp, from, first_cut, new_mid, len11, len22);
  __haxe_ds_ArraySort.doMerge(a, cmp, new_mid, second_cut, to, len1 - len11, len2 - len22);
end
__haxe_ds_ArraySort.rotate = function(a,cmp,from,mid,to) 
  if ((from == mid) or (mid == to)) then 
    do return end;
  end;
  local n = __haxe_ds_ArraySort.gcd(to - from, mid - from);
  while (true) do 
    n = n - 1;
    if (not ((n + 1) ~= 0)) then 
      break;
    end;
    local val = a[from + n];
    local shift = mid - from;
    local p1 = from + n;
    local p2 = (from + n) + shift;
    while (p2 ~= (from + n)) do 
      a[p1] = a[p2];
      p1 = p2;
      if ((to - p2) > shift) then 
        p2 = p2 + shift;
      else
        p2 = from + (shift - (to - p2));
      end;
    end;
    a[p1] = val;
  end;
end
__haxe_ds_ArraySort.gcd = function(m,n) 
  while (n ~= 0) do 
    local t = _G.math.fmod(m, n);
    m = n;
    n = t;
  end;
  do return m end;
end
__haxe_ds_ArraySort.upper = function(a,cmp,from,to,val) 
  local len = to - from;
  local half;
  local mid;
  while (len > 0) do 
    half = _hx_bit.arshift(len,1);
    mid = from + half;
    if (cmp(a[val], a[mid]) < 0) then 
      len = half;
    else
      from = mid + 1;
      len = (len - half) - 1;
    end;
  end;
  do return from end;
end
__haxe_ds_ArraySort.lower = function(a,cmp,from,to,val) 
  local len = to - from;
  local half;
  local mid;
  while (len > 0) do 
    half = _hx_bit.arshift(len,1);
    mid = from + half;
    if (cmp(a[mid], a[val]) < 0) then 
      from = mid + 1;
      len = (len - half) - 1;
    else
      len = half;
    end;
  end;
  do return from end;
end
__haxe_ds_ArraySort.swap = function(a,i,j) 
  local tmp = a[i];
  a[i] = a[j];
  a[j] = tmp;
end

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_IntMap.__name__ = true
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_a();
__haxe_ds_IntMap.prototype.h= nil;
__haxe_ds_IntMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_IntMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__haxe_ds_List.new = function() 
  local self = _hx_new(__haxe_ds_List.prototype)
  __haxe_ds_List.super(self)
  return self
end
__haxe_ds_List.super = function(self) 
  self.length = 0;
end
__haxe_ds_List.__name__ = true
__haxe_ds_List.prototype = _hx_a();
__haxe_ds_List.prototype.h= nil;
__haxe_ds_List.prototype.q= nil;
__haxe_ds_List.prototype.length= nil;
__haxe_ds_List.prototype.add = function(self,item) 
  local next = nil;
  local x = __haxe_ds__List_ListNode.new(item, next);
  if (self.h == nil) then 
    self.h = x;
  else
    self.q.next = x;
  end;
  self.q = x;
  self.length = self.length + 1;
end
__haxe_ds_List.prototype.remove = function(self,v) 
  local prev = nil;
  local l = self.h;
  while (l ~= nil) do 
    if (l.item == v) then 
      if (prev == nil) then 
        self.h = l.next;
      else
        prev.next = l.next;
      end;
      if (self.q == l) then 
        self.q = prev;
      end;
      self.length = self.length - 1;
      do return true end;
    end;
    prev = l;
    l = l.next;
  end;
  do return false end
end
__haxe_ds_List.prototype.iterator = function(self) 
  do return __haxe_ds__List_ListIterator.new(self.h) end
end

__haxe_ds_List.prototype.__class__ =  __haxe_ds_List

__haxe_ds__List_ListNode.new = function(item,next) 
  local self = _hx_new(__haxe_ds__List_ListNode.prototype)
  __haxe_ds__List_ListNode.super(self,item,next)
  return self
end
__haxe_ds__List_ListNode.super = function(self,item,next) 
  self.item = item;
  self.next = next;
end
__haxe_ds__List_ListNode.__name__ = true
__haxe_ds__List_ListNode.prototype = _hx_a();
__haxe_ds__List_ListNode.prototype.item= nil;
__haxe_ds__List_ListNode.prototype.next= nil;

__haxe_ds__List_ListNode.prototype.__class__ =  __haxe_ds__List_ListNode

__haxe_ds__List_ListIterator.new = function(head) 
  local self = _hx_new(__haxe_ds__List_ListIterator.prototype)
  __haxe_ds__List_ListIterator.super(self,head)
  return self
end
__haxe_ds__List_ListIterator.super = function(self,head) 
  self.head = head;
end
__haxe_ds__List_ListIterator.__name__ = true
__haxe_ds__List_ListIterator.prototype = _hx_a();
__haxe_ds__List_ListIterator.prototype.head= nil;
__haxe_ds__List_ListIterator.prototype.hasNext = function(self) 
  do return self.head ~= nil end
end
__haxe_ds__List_ListIterator.prototype.next = function(self) 
  local val = self.head.item;
  self.head = self.head.next;
  do return val end
end

__haxe_ds__List_ListIterator.prototype.__class__ =  __haxe_ds__List_ListIterator

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = true
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_a();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_StringMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_StringMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_format_JsonParser.new = function(str) 
  local self = _hx_new(__haxe_format_JsonParser.prototype)
  __haxe_format_JsonParser.super(self,str)
  return self
end
__haxe_format_JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
__haxe_format_JsonParser.__name__ = true
__haxe_format_JsonParser.prototype = _hx_a();
__haxe_format_JsonParser.prototype.str= nil;
__haxe_format_JsonParser.prototype.pos= nil;
local cjson_name = "cjson" 
local cjson = cjson or require(cjson_name)
cjson.decode_array_with_array_mt(true)
local function json_clear_null(t)
  if type(t) == "table" then
    for k,v in pairs(t)do
      if v == cjson.null then
        t[k] = nil
      end
      if type(v) == "table" then
        json_clear_null(v)
      end
    end
  end
  return t
end

local function json_decode(str)
  return json_clear_null(cjson.decode(str))
end

local parseJson
parseJson = function (table)
  local result
  --array
  if(getmetatable(table)==cjson.array_mt) then
result = _hx_tab_array({}, 0);
    for k, v in ipairs(table) do
      if(type(v) == "table") then
        result:push(parseJson(v))
   else
        result:push(v) 
   end
    end
  else
    result = {}
    for k, v in pairs(table) do
      if(type(v) == "table") then
        result[k] = parseJson(v)
      else
        result[k] = v
      end
    end
  end
  return result
end
__haxe_format_JsonParser.prototype.doParse = function(self)
  return parseJson(json_decode(self.str))
end

__haxe_format_JsonParser.prototype.parseRec = function(self) 
  while (true) do 
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local c = __lua_lib_luautf8_Utf8.byte(self.str, index + 1);
    if (c) == 9 or (c) == 10 or (c) == 13 or (c) == 32 then 
    elseif (c) == 34 then 
      do return self:parseString() end;
    elseif (c) == 45 or (c) == 48 or (c) == 49 or (c) == 50 or (c) == 51 or (c) == 52 or (c) == 53 or (c) == 54 or (c) == 55 or (c) == 56 or (c) == 57 then 
      local c1 = c;
      local start = self.pos - 1;
      local minus = c == 45;
      local digit = not minus;
      local zero = c == 48;
      local point = false;
      local e = false;
      local pm = false;
      local _end = false;
      while (true) do 
        local index1 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        c1 = __lua_lib_luautf8_Utf8.byte(self.str, index1 + 1);
        local c2 = c1;
        if (c2) == 43 or (c2) == 45 then 
          if (not e or pm) then 
            self:invalidNumber(start);
          end;
          digit = false;
          pm = true;
        elseif (c2) == 46 then 
          if ((minus or point) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          point = true;
        elseif (c2) == 48 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
            zero = true;
          end;
          digit = true;
        elseif (c2) == 49 or (c2) == 50 or (c2) == 51 or (c2) == 52 or (c2) == 53 or (c2) == 54 or (c2) == 55 or (c2) == 56 or (c2) == 57 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
          end;
          digit = true;
          zero = false;
        elseif (c2) == 69 or (c2) == 101 then 
          if ((minus or zero) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          e = true;else
        if (not digit) then 
          self:invalidNumber(start);
        end;
        self.pos = self.pos - 1;
        _end = true; end;
        if (_end) then 
          break;
        end;
      end;
      local _this = self.str;
      local pos = start;
      local len = self.pos - start;
      if ((len == nil) or (len > (start + __lua_lib_luautf8_Utf8.len(_this)))) then 
        len = __lua_lib_luautf8_Utf8.len(_this);
      else
        if (len < 0) then 
          len = __lua_lib_luautf8_Utf8.len(_this) + len;
        end;
      end;
      if (start < 0) then 
        pos = __lua_lib_luautf8_Utf8.len(_this) + start;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      local f = Std.parseFloat(__lua_lib_luautf8_Utf8.sub(_this, pos + 1, pos + len));
      local i = Std.int(f);
      if (i == f) then 
        do return i end;
      else
        do return f end;
      end;
    elseif (c) == 91 then 
      local arr = _hx_tab_array({}, 0);
      local comma = nil;
      while (true) do 
        local index2 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local c3 = __lua_lib_luautf8_Utf8.byte(self.str, index2 + 1);
        if (c3) == 9 or (c3) == 10 or (c3) == 13 or (c3) == 32 then 
        elseif (c3) == 44 then 
          if (comma) then 
            comma = false;
          else
            self:invalidChar();
          end;
        elseif (c3) == 93 then 
          if (comma == false) then 
            self:invalidChar();
          end;
          do return arr end;else
        if (comma) then 
          self:invalidChar();
        end;
        self.pos = self.pos - 1;
        arr:push(self:parseRec());
        comma = true; end;
      end;
    elseif (c) == 102 then 
      local save = self.pos;
      local tmp;
      local tmp1;
      local tmp2;
      local index3 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index3 + 1) == 97) then 
        local index4 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp2 = __lua_lib_luautf8_Utf8.byte(self.str, index4 + 1) ~= 108;
      else
        tmp2 = true;
      end;
      if (not tmp2) then 
        local index5 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp1 = __lua_lib_luautf8_Utf8.byte(self.str, index5 + 1) ~= 115;
      else
        tmp1 = true;
      end;
      if (not tmp1) then 
        local index6 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp = __lua_lib_luautf8_Utf8.byte(self.str, index6 + 1) ~= 101;
      else
        tmp = true;
      end;
      if (tmp) then 
        self.pos = save;
        self:invalidChar();
      end;
      do return false end;
    elseif (c) == 110 then 
      local save1 = self.pos;
      local tmp3;
      local tmp4;
      local index7 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index7 + 1) == 117) then 
        local index8 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp4 = __lua_lib_luautf8_Utf8.byte(self.str, index8 + 1) ~= 108;
      else
        tmp4 = true;
      end;
      if (not tmp4) then 
        local index9 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp3 = __lua_lib_luautf8_Utf8.byte(self.str, index9 + 1) ~= 108;
      else
        tmp3 = true;
      end;
      if (tmp3) then 
        self.pos = save1;
        self:invalidChar();
      end;
      do return nil end;
    elseif (c) == 116 then 
      local save2 = self.pos;
      local tmp5;
      local tmp6;
      local index10 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (__lua_lib_luautf8_Utf8.byte(self.str, index10 + 1) == 114) then 
        local index11 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp6 = __lua_lib_luautf8_Utf8.byte(self.str, index11 + 1) ~= 117;
      else
        tmp6 = true;
      end;
      if (not tmp6) then 
        local index12 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        tmp5 = __lua_lib_luautf8_Utf8.byte(self.str, index12 + 1) ~= 101;
      else
        tmp5 = true;
      end;
      if (tmp5) then 
        self.pos = save2;
        self:invalidChar();
      end;
      do return true end;
    elseif (c) == 123 then 
      local obj = _hx_e();
      local field = nil;
      local comma1 = nil;
      while (true) do 
        local index13 = (function() 
        local _hx_obj = self;
        local _hx_fld = 'pos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local c4 = __lua_lib_luautf8_Utf8.byte(self.str, index13 + 1);
        if (c4) == 9 or (c4) == 10 or (c4) == 13 or (c4) == 32 then 
        elseif (c4) == 34 then 
          if ((field ~= nil) or comma1) then 
            self:invalidChar();
          end;
          field = self:parseString();
        elseif (c4) == 44 then 
          if (comma1) then 
            comma1 = false;
          else
            self:invalidChar();
          end;
        elseif (c4) == 58 then 
          if (field == nil) then 
            self:invalidChar();
          end;
          obj[field] = self:parseRec();
          field = nil;
          comma1 = true;
        elseif (c4) == 125 then 
          if ((field ~= nil) or (comma1 == false)) then 
            self:invalidChar();
          end;
          do return obj end;else
        self:invalidChar(); end;
      end;else
    self:invalidChar(); end;
  end;
end
__haxe_format_JsonParser.prototype.parseString = function(self) 
  local start = self.pos;
  local buf = nil;
  local prev = -1;
  while (true) do 
    local index = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local c = __lua_lib_luautf8_Utf8.byte(self.str, index + 1);
    if (c == 34) then 
      break;
    end;
    if (c == 92) then 
      if (buf == nil) then 
        buf = StringBuf.new();
      end;
      local s = self.str;
      local len = (self.pos - start) - 1;
      local part;
      if (len == nil) then 
        local pos = start;
        local len1 = nil;
        len1 = __lua_lib_luautf8_Utf8.len(s);
        if (pos < 0) then 
          pos = __lua_lib_luautf8_Utf8.len(s) + pos;
        end;
        if (pos < 0) then 
          pos = 0;
        end;
        part = __lua_lib_luautf8_Utf8.sub(s, pos + 1, pos + len1);
      else
        local pos1 = start;
        local len2 = len;
        if ((len == nil) or (len > (pos1 + __lua_lib_luautf8_Utf8.len(s)))) then 
          len2 = __lua_lib_luautf8_Utf8.len(s);
        else
          if (len < 0) then 
            len2 = __lua_lib_luautf8_Utf8.len(s) + len;
          end;
        end;
        if (pos1 < 0) then 
          pos1 = __lua_lib_luautf8_Utf8.len(s) + pos1;
        end;
        if (pos1 < 0) then 
          pos1 = 0;
        end;
        part = __lua_lib_luautf8_Utf8.sub(s, pos1 + 1, pos1 + len2);
      end;
      _G.table.insert(buf.b, part);
      local buf1 = buf;
      buf1.length = buf1.length + __lua_lib_luautf8_Utf8.len(part);
      local index1 = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      c = __lua_lib_luautf8_Utf8.byte(self.str, index1 + 1);
      if ((c ~= 117) and (prev ~= -1)) then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
        local buf2 = buf;
        buf2.length = buf2.length + 1;
        prev = -1;
      end;
      local c1 = c;
      if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(c));
        local buf3 = buf;
        buf3.length = buf3.length + 1;
      elseif (c1) == 98 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(8));
        local buf4 = buf;
        buf4.length = buf4.length + 1;
      elseif (c1) == 102 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(12));
        local buf5 = buf;
        buf5.length = buf5.length + 1;
      elseif (c1) == 110 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(10));
        local buf6 = buf;
        buf6.length = buf6.length + 1;
      elseif (c1) == 114 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(13));
        local buf7 = buf;
        buf7.length = buf7.length + 1;
      elseif (c1) == 116 then 
        _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(9));
        local buf8 = buf;
        buf8.length = buf8.length + 1;
      elseif (c1) == 117 then 
        local _this = self.str;
        local pos2 = self.pos;
        local len3 = 4;
        if (4 > (pos2 + __lua_lib_luautf8_Utf8.len(_this))) then 
          len3 = __lua_lib_luautf8_Utf8.len(_this);
        end;
        if (pos2 < 0) then 
          pos2 = __lua_lib_luautf8_Utf8.len(_this) + pos2;
        end;
        if (pos2 < 0) then 
          pos2 = 0;
        end;
        local uc = Std.parseInt(Std.string("0x") .. Std.string(__lua_lib_luautf8_Utf8.sub(_this, pos2 + 1, pos2 + len3)));
        local tmp = self;
        tmp.pos = tmp.pos + 4;
        if (prev ~= -1) then 
          if ((uc < 56320) or (uc > 57343)) then 
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
            local buf9 = buf;
            buf9.length = buf9.length + 1;
            prev = -1;
          else
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(((_hx_bit.lshift(prev - 55296,10)) + (uc - 56320)) + 65536));
            local buf10 = buf;
            buf10.length = buf10.length + 1;
            prev = -1;
          end;
        else
          if ((uc >= 55296) and (uc <= 56319)) then 
            prev = uc;
          else
            _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(uc));
            local buf11 = buf;
            buf11.length = buf11.length + 1;
          end;
        end;else
      _G.error(Std.string(Std.string(Std.string("Invalid escape sequence \\") .. Std.string(__lua_lib_luautf8_Utf8.char(c))) .. Std.string(" at position ")) .. Std.string((self.pos - 1)),0); end;
      start = self.pos;
    else
      if (c == nil) then 
        _G.error("Unclosed string",0);
      end;
    end;
  end;
  if (prev ~= -1) then 
    _G.table.insert(buf.b, __lua_lib_luautf8_Utf8.char(65533));
    local buf12 = buf;
    buf12.length = buf12.length + 1;
  end;
  if (buf == nil) then 
    local _this1 = self.str;
    local pos3 = start;
    local len4 = (self.pos - start) - 1;
    if ((len4 == nil) or (len4 > (pos3 + __lua_lib_luautf8_Utf8.len(_this1)))) then 
      len4 = __lua_lib_luautf8_Utf8.len(_this1);
    else
      if (len4 < 0) then 
        len4 = __lua_lib_luautf8_Utf8.len(_this1) + len4;
      end;
    end;
    if (pos3 < 0) then 
      pos3 = __lua_lib_luautf8_Utf8.len(_this1) + pos3;
    end;
    if (pos3 < 0) then 
      pos3 = 0;
    end;
    do return __lua_lib_luautf8_Utf8.sub(_this1, pos3 + 1, pos3 + len4) end;
  else
    local s1 = self.str;
    local len5 = (self.pos - start) - 1;
    local part1;
    if (len5 == nil) then 
      local pos4 = start;
      local len6 = nil;
      len6 = __lua_lib_luautf8_Utf8.len(s1);
      if (pos4 < 0) then 
        pos4 = __lua_lib_luautf8_Utf8.len(s1) + pos4;
      end;
      if (pos4 < 0) then 
        pos4 = 0;
      end;
      part1 = __lua_lib_luautf8_Utf8.sub(s1, pos4 + 1, pos4 + len6);
    else
      local pos5 = start;
      local len7 = len5;
      if ((len5 == nil) or (len5 > (pos5 + __lua_lib_luautf8_Utf8.len(s1)))) then 
        len7 = __lua_lib_luautf8_Utf8.len(s1);
      else
        if (len5 < 0) then 
          len7 = __lua_lib_luautf8_Utf8.len(s1) + len5;
        end;
      end;
      if (pos5 < 0) then 
        pos5 = __lua_lib_luautf8_Utf8.len(s1) + pos5;
      end;
      if (pos5 < 0) then 
        pos5 = 0;
      end;
      part1 = __lua_lib_luautf8_Utf8.sub(s1, pos5 + 1, pos5 + len7);
    end;
    _G.table.insert(buf.b, part1);
    local buf13 = buf;
    buf13.length = buf13.length + __lua_lib_luautf8_Utf8.len(part1);
    do return _G.table.concat(buf.b) end;
  end;
end
__haxe_format_JsonParser.prototype.invalidChar = function(self) 
  self.pos = self.pos - 1;
  _G.error(Std.string(Std.string(Std.string("Invalid char ") .. Std.string(__lua_lib_luautf8_Utf8.byte(self.str, self.pos + 1))) .. Std.string(" at position ")) .. Std.string(self.pos),0);
end
__haxe_format_JsonParser.prototype.invalidNumber = function(self,start) 
  local _this = self.str;
  local pos = start;
  local len = self.pos - start;
  if ((len == nil) or (len > (start + __lua_lib_luautf8_Utf8.len(_this)))) then 
    len = __lua_lib_luautf8_Utf8.len(_this);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(_this) + len;
    end;
  end;
  if (start < 0) then 
    pos = __lua_lib_luautf8_Utf8.len(_this) + start;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  _G.error(Std.string(Std.string(Std.string("Invalid number at position ") .. Std.string(start)) .. Std.string(": ")) .. Std.string(__lua_lib_luautf8_Utf8.sub(_this, pos + 1, pos + len)),0);
end

__haxe_format_JsonParser.prototype.__class__ =  __haxe_format_JsonParser

__haxe_format_JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(__haxe_format_JsonPrinter.prototype)
  __haxe_format_JsonPrinter.super(self,replacer,space)
  return self
end
__haxe_format_JsonPrinter.super = function(self,replacer,space) 
  self.replacer = _hx_funcToField(replacer);
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
__haxe_format_JsonPrinter.__name__ = true
__haxe_format_JsonPrinter.print = function(o,replacer,space) 
  local printer = __haxe_format_JsonPrinter.new(replacer, space);
  printer:write("", o);
  do return _G.table.concat(printer.buf.b) end;
end
__haxe_format_JsonPrinter.prototype = _hx_a();
__haxe_format_JsonPrinter.prototype.buf= nil;
__haxe_format_JsonPrinter.prototype.replacer= nil;
__haxe_format_JsonPrinter.prototype.indent= nil;
__haxe_format_JsonPrinter.prototype.pretty= nil;
__haxe_format_JsonPrinter.prototype.nind= nil;
__haxe_format_JsonPrinter.prototype.write = function(self,k,v) 
  if (self.replacer ~= nil) then 
    v = self:replacer(k, v);
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _this = self.buf;
    _G.table.insert(_this.b, "null");
    _this.length = _this.length + __lua_lib_luautf8_Utf8.len("null");
  elseif (tmp) == 1 then 
    local _this1 = self.buf;
    local str = Std.string(v);
    _G.table.insert(_this1.b, str);
    _this1.length = _this1.length + __lua_lib_luautf8_Utf8.len(str);
  elseif (tmp) == 2 then 
    local v1 = (function() 
      local _hx_1
      if (Math.isFinite(v)) then 
      _hx_1 = Std.string(v); else 
      _hx_1 = "null"; end
      return _hx_1
    end )();
    local _this2 = self.buf;
    local str1 = Std.string(v1);
    _G.table.insert(_this2.b, str1);
    _this2.length = _this2.length + __lua_lib_luautf8_Utf8.len(str1);
  elseif (tmp) == 3 then 
    local _this3 = self.buf;
    local str2 = Std.string(v);
    _G.table.insert(_this3.b, str2);
    _this3.length = _this3.length + __lua_lib_luautf8_Utf8.len(str2);
  elseif (tmp) == 4 then 
    self:fieldsString(v, Reflect.fields(v));
  elseif (tmp) == 5 then 
    local _this4 = self.buf;
    _G.table.insert(_this4.b, "\"<fun>\"");
    _this4.length = _this4.length + __lua_lib_luautf8_Utf8.len("\"<fun>\"");
  elseif (tmp) == 6 then 
    local _g2 = _g[2];
    if (_g2 == String) then 
      self:quote(v);
    else
      if (_g2 == Array) then 
        local v2 = v;
        local _this5 = self.buf;
        _G.table.insert(_this5.b, __lua_lib_luautf8_Utf8.char(91));
        _this5.length = _this5.length + 1;
        local len = v2.length;
        local last = len - 1;
        local _g1 = 0;
        while (_g1 < len) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (i > 0) then 
            local _this6 = self.buf;
            _G.table.insert(_this6.b, __lua_lib_luautf8_Utf8.char(44));
            _this6.length = _this6.length + 1;
          else
            self.nind = self.nind + 1;
          end;
          if (self.pretty) then 
            local _this7 = self.buf;
            _G.table.insert(_this7.b, __lua_lib_luautf8_Utf8.char(10));
            _this7.length = _this7.length + 1;
          end;
          if (self.pretty) then 
            local v3 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
            local _this8 = self.buf;
            local str3 = Std.string(v3);
            _G.table.insert(_this8.b, str3);
            _this8.length = _this8.length + __lua_lib_luautf8_Utf8.len(str3);
          end;
          self:write(i, v2[i]);
          if (i == last) then 
            self.nind = self.nind - 1;
            if (self.pretty) then 
              local _this9 = self.buf;
              _G.table.insert(_this9.b, __lua_lib_luautf8_Utf8.char(10));
              _this9.length = _this9.length + 1;
            end;
            if (self.pretty) then 
              local v4 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
              local _this10 = self.buf;
              local str4 = Std.string(v4);
              _G.table.insert(_this10.b, str4);
              _this10.length = _this10.length + __lua_lib_luautf8_Utf8.len(str4);
            end;
          end;
        end;
        local _this11 = self.buf;
        _G.table.insert(_this11.b, __lua_lib_luautf8_Utf8.char(93));
        _this11.length = _this11.length + 1;
      else
        if (_g2 == __haxe_ds_StringMap) then 
          local v5 = v;
          local o = _hx_e();
          local k1 = v5:keys();
          while (k1:hasNext()) do 
            local k2 = k1:next();
            local ret = v5.h[k2];
            if (ret == __haxe_ds_StringMap.tnull) then 
              ret = nil;
            end;
            o[k2] = ret;
          end;
          local v6 = o;
          self:fieldsString(v6, Reflect.fields(v6));
        else
          if (_g2 == Date) then 
            self:quote(__lua_Boot.dateStr(v));
          else
            self:classString(v);
          end;
        end;
      end;
    end;
  elseif (tmp) == 7 then 
    local _this12 = self.buf;
    local str5 = Std.string(v[1]);
    _G.table.insert(_this12.b, str5);
    _this12.length = _this12.length + __lua_lib_luautf8_Utf8.len(str5);
  elseif (tmp) == 8 then 
    local _this13 = self.buf;
    _G.table.insert(_this13.b, "\"???\"");
    _this13.length = _this13.length + __lua_lib_luautf8_Utf8.len("\"???\""); end;
end
__haxe_format_JsonPrinter.prototype.classString = function(self,v) 
  self:fieldsString(v, Type.getInstanceFields(Type.getClass(v)));
end
__haxe_format_JsonPrinter.prototype.fieldsString = function(self,v,fields) 
  local _this = self.buf;
  _G.table.insert(_this.b, __lua_lib_luautf8_Utf8.char(123));
  _this.length = _this.length + 1;
  local len = fields.length;
  local last = len - 1;
  local first = true;
  local _g = 0;
  local _hx_continue_1 = false;
  while (_g < len) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local f = fields[i];
    local value = Reflect.field(v, f);
    if (Reflect.isFunction(value)) then 
      break;
    end;
    if (first) then 
      self.nind = self.nind + 1;
      first = false;
    else
      local _this1 = self.buf;
      _G.table.insert(_this1.b, __lua_lib_luautf8_Utf8.char(44));
      _this1.length = _this1.length + 1;
    end;
    if (self.pretty) then 
      local _this2 = self.buf;
      _G.table.insert(_this2.b, __lua_lib_luautf8_Utf8.char(10));
      _this2.length = _this2.length + 1;
    end;
    if (self.pretty) then 
      local v1 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
      local _this3 = self.buf;
      local str = Std.string(v1);
      _G.table.insert(_this3.b, str);
      _this3.length = _this3.length + __lua_lib_luautf8_Utf8.len(str);
    end;
    self:quote(f);
    local _this4 = self.buf;
    _G.table.insert(_this4.b, __lua_lib_luautf8_Utf8.char(58));
    _this4.length = _this4.length + 1;
    if (self.pretty) then 
      local _this5 = self.buf;
      _G.table.insert(_this5.b, __lua_lib_luautf8_Utf8.char(32));
      _this5.length = _this5.length + 1;
    end;
    self:write(f, value);
    if (i == last) then 
      self.nind = self.nind - 1;
      if (self.pretty) then 
        local _this6 = self.buf;
        _G.table.insert(_this6.b, __lua_lib_luautf8_Utf8.char(10));
        _this6.length = _this6.length + 1;
      end;
      if (self.pretty) then 
        local v2 = StringTools.lpad("", self.indent, self.nind * __lua_lib_luautf8_Utf8.len(self.indent));
        local _this7 = self.buf;
        local str1 = Std.string(v2);
        _G.table.insert(_this7.b, str1);
        _this7.length = _this7.length + __lua_lib_luautf8_Utf8.len(str1);
      end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  local _this8 = self.buf;
  _G.table.insert(_this8.b, __lua_lib_luautf8_Utf8.char(125));
  _this8.length = _this8.length + 1;
end
__haxe_format_JsonPrinter.prototype.quote = function(self,s) 
  local _this = self.buf;
  _G.table.insert(_this.b, __lua_lib_luautf8_Utf8.char(34));
  _this.length = _this.length + 1;
  local i = 0;
  while (true) do 
    i = i + 1;
    local c = __lua_lib_luautf8_Utf8.byte(s, (i - 1) + 1);
    if (c == nil) then 
      break;
    end;
    if (c) == 8 then 
      local _this1 = self.buf;
      _G.table.insert(_this1.b, "\\b");
      _this1.length = _this1.length + __lua_lib_luautf8_Utf8.len("\\b");
    elseif (c) == 9 then 
      local _this2 = self.buf;
      _G.table.insert(_this2.b, "\\t");
      _this2.length = _this2.length + __lua_lib_luautf8_Utf8.len("\\t");
    elseif (c) == 10 then 
      local _this3 = self.buf;
      _G.table.insert(_this3.b, "\\n");
      _this3.length = _this3.length + __lua_lib_luautf8_Utf8.len("\\n");
    elseif (c) == 12 then 
      local _this4 = self.buf;
      _G.table.insert(_this4.b, "\\f");
      _this4.length = _this4.length + __lua_lib_luautf8_Utf8.len("\\f");
    elseif (c) == 13 then 
      local _this5 = self.buf;
      _G.table.insert(_this5.b, "\\r");
      _this5.length = _this5.length + __lua_lib_luautf8_Utf8.len("\\r");
    elseif (c) == 34 then 
      local _this6 = self.buf;
      _G.table.insert(_this6.b, "\\\"");
      _this6.length = _this6.length + __lua_lib_luautf8_Utf8.len("\\\"");
    elseif (c) == 92 then 
      local _this7 = self.buf;
      _G.table.insert(_this7.b, "\\\\");
      _this7.length = _this7.length + __lua_lib_luautf8_Utf8.len("\\\\");else
    local _this8 = self.buf;
    _G.table.insert(_this8.b, __lua_lib_luautf8_Utf8.char(c));
    _this8.length = _this8.length + 1; end;
  end;
  local _this9 = self.buf;
  _G.table.insert(_this9.b, __lua_lib_luautf8_Utf8.char(34));
  _this9.length = _this9.length + 1;
end

__haxe_format_JsonPrinter.prototype.__class__ =  __haxe_format_JsonPrinter

__haxe_io_BytesBuffer.new = function() 
  local self = _hx_new(__haxe_io_BytesBuffer.prototype)
  __haxe_io_BytesBuffer.super(self)
  return self
end
__haxe_io_BytesBuffer.super = function(self) 
  self.b = Array.new();
end
__haxe_io_BytesBuffer.__name__ = true
__haxe_io_BytesBuffer.prototype = _hx_a();
__haxe_io_BytesBuffer.prototype.b= nil;
__haxe_io_BytesBuffer.prototype.getBytes = function(self) 
  local bytes = __haxe_io_Bytes.new(self.b.length, self.b);
  self.b = nil;
  do return bytes end
end

__haxe_io_BytesBuffer.prototype.__class__ =  __haxe_io_BytesBuffer

__haxe_io_Input.new = {}
__haxe_io_Input.__name__ = true
__haxe_io_Input.prototype = _hx_a();
__haxe_io_Input.prototype.bigEndian= nil;
__haxe_io_Input.prototype.readByte = function(self) 
  _G.error("Not implemented",0);
end
__haxe_io_Input.prototype.readBytes = function(self,s,pos,len) 
  local k = len;
  local b = s.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      while (k > 0) do 
        b[pos] = self:readByte();
        pos = pos + 1;
        k = k - 1;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    if( __lua_Boot.__instanceof(_hx_1,__haxe_io_Eof) ) then 
      local eof = _hx_1
    else _G.error(_hx_1)
    end
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return len - k end
end
__haxe_io_Input.prototype.read = function(self,nbytes) 
  local s = __haxe_io_Bytes.alloc(nbytes);
  local p = 0;
  while (nbytes > 0) do 
    local k = self:readBytes(s, p, nbytes);
    if (k == 0) then 
      _G.error(__haxe_io_Error.Blocked,0);
    end;
    p = p + k;
    nbytes = nbytes - k;
  end;
  do return s end
end
__haxe_io_Input.prototype.readUInt16 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  if (self.bigEndian) then 
    do return _hx_bit.bor(ch2,_hx_bit.lshift(ch1,8)) end;
  else
    do return _hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)) end;
  end;
end

__haxe_io_Input.prototype.__class__ =  __haxe_io_Input

__haxe_io_BytesInput.new = function(b,pos,len) 
  local self = _hx_new(__haxe_io_BytesInput.prototype)
  __haxe_io_BytesInput.super(self,b,pos,len)
  return self
end
__haxe_io_BytesInput.super = function(self,b,pos,len) 
  if (pos == nil) then 
    pos = 0;
  end;
  if (len == nil) then 
    len = b.length - pos;
  end;
  if (((pos < 0) or (len < 0)) or ((pos + len) > b.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  self.b = b.b;
  self.pos = pos;
  self.len = len;
  self.totlen = len;
end
__haxe_io_BytesInput.__name__ = true
__haxe_io_BytesInput.prototype = _hx_a();
__haxe_io_BytesInput.prototype.b= nil;
__haxe_io_BytesInput.prototype.pos= nil;
__haxe_io_BytesInput.prototype.len= nil;
__haxe_io_BytesInput.prototype.totlen= nil;
__haxe_io_BytesInput.prototype.readByte = function(self) 
  if (self.len == 0) then 
    _G.error(__haxe_io_Eof.new(),0);
  end;
  self.len = self.len - 1;
  do return self.b[(function() 
  local _hx_obj = self;
  local _hx_fld = 'pos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end
__haxe_io_BytesInput.prototype.readBytes = function(self,buf,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > buf.length)) then 
    _G.error(__haxe_io_Error.OutsideBounds,0);
  end;
  if ((self.len == 0) and (len > 0)) then 
    _G.error(__haxe_io_Eof.new(),0);
  end;
  if (self.len < len) then 
    len = self.len;
  end;
  local b1 = self.b;
  local b2 = buf.b;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    b2[pos + i] = b1[self.pos + i];
  end;
  local tmp = self;
  tmp.pos = tmp.pos + len;
  local tmp1 = self;
  tmp1.len = tmp1.len - len;
  do return len end
end

__haxe_io_BytesInput.prototype.__class__ =  __haxe_io_BytesInput
__haxe_io_BytesInput.__super__ = __haxe_io_Input
setmetatable(__haxe_io_BytesInput.prototype,{__index=__haxe_io_Input.prototype})
_hxClasses["haxe.io.Encoding"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)


__haxe_io_Eof.new = function() 
  local self = _hx_new(__haxe_io_Eof.prototype)
  __haxe_io_Eof.super(self)
  return self
end
__haxe_io_Eof.super = function(self) 
end
__haxe_io_Eof.__name__ = true
__haxe_io_Eof.prototype = _hx_a();
__haxe_io_Eof.prototype.toString = function(self) 
  do return "Eof" end
end

__haxe_io_Eof.prototype.__class__ =  __haxe_io_Eof
_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 

__haxe_zip_Compress.new = {}
__haxe_zip_Compress.__name__ = true
__haxe_zip_Compress.run = function(s,level) 
  _G.error("Not implemented for this platform",0);
end
_hxClasses["haxe.zip.Huffman"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Found","NeedBit","NeedBits"},3)}
__haxe_zip_Huffman = _hxClasses["haxe.zip.Huffman"];
__haxe_zip_Huffman.Found = function(i) local _x = _hx_tab_array({[0]="Found",0,i,__enum__=__haxe_zip_Huffman}, 3); return _x; end 
__haxe_zip_Huffman.NeedBit = function(left,right) local _x = _hx_tab_array({[0]="NeedBit",1,left,right,__enum__=__haxe_zip_Huffman}, 4); return _x; end 
__haxe_zip_Huffman.NeedBits = function(n,table) local _x = _hx_tab_array({[0]="NeedBits",2,n,table,__enum__=__haxe_zip_Huffman}, 4); return _x; end 

__haxe_zip_HuffTools.new = function() 
  local self = _hx_new(__haxe_zip_HuffTools.prototype)
  __haxe_zip_HuffTools.super(self)
  return self
end
__haxe_zip_HuffTools.super = function(self) 
end
__haxe_zip_HuffTools.__name__ = true
__haxe_zip_HuffTools.prototype = _hx_a();
__haxe_zip_HuffTools.prototype.treeDepth = function(self,t) 
  local tmp = t[1];
  if (tmp) == 0 then 
    do return 0 end;
  elseif (tmp) == 1 then 
    local da = self:treeDepth(t[2]);
    local db = self:treeDepth(t[3]);
    do return 1 + (function() 
      local _hx_1
      if (da < db) then 
      _hx_1 = da; else 
      _hx_1 = db; end
      return _hx_1
    end )() end;
  elseif (tmp) == 2 then 
    _G.error("assert",0); end;
end
__haxe_zip_HuffTools.prototype.treeCompress = function(self,t) 
  local d = self:treeDepth(t);
  if (d == 0) then 
    do return t end;
  end;
  if (d == 1) then 
    if (t[1] == 1) then 
      do return __haxe_zip_Huffman.NeedBit(self:treeCompress(t[2]), self:treeCompress(t[3])) end;
    else
      _G.error("assert",0);
    end;
  end;
  local size = _hx_bit.lshift(1,d);
  local table = Array.new();
  local _g = 0;
  while (_g < size) do 
    _g = _g + 1;
    table:push(__haxe_zip_Huffman.Found(-1));
  end;
  self:treeWalk(table, 0, 0, d, t);
  do return __haxe_zip_Huffman.NeedBits(d, table) end
end
__haxe_zip_HuffTools.prototype.treeWalk = function(self,table,p,cd,d,t) 
  if (t[1] == 1) then 
    if (d > 0) then 
      self:treeWalk(table, p, cd + 1, d - 1, t[2]);
      self:treeWalk(table, _hx_bit.bor(p,_hx_bit.lshift(1,cd)), cd + 1, d - 1, t[3]);
    else
      table[p] = self:treeCompress(t);
    end;
  else
    table[p] = self:treeCompress(t);
  end;
end
__haxe_zip_HuffTools.prototype.treeMake = function(self,bits,maxbits,v,len) 
  if (len > maxbits) then 
    _G.error("Invalid huffman",0);
  end;
  local idx = _hx_bit.bor(_hx_bit.lshift(v,5),len);
  if (bits.h[idx] ~= nil) then 
    local ret = bits.h[idx];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    do return __haxe_zip_Huffman.Found(ret) end;
  end;
  v = _hx_bit.lshift(v,1);
  len = len + 1;
  do return __haxe_zip_Huffman.NeedBit(self:treeMake(bits, maxbits, v, len), self:treeMake(bits, maxbits, _hx_bit.bor(v,1), len)) end
end
__haxe_zip_HuffTools.prototype.make = function(self,lengths,pos,nlengths,maxbits) 
  if (nlengths == 1) then 
    do return __haxe_zip_Huffman.NeedBit(__haxe_zip_Huffman.Found(0), __haxe_zip_Huffman.Found(0)) end;
  end;
  local counts = Array.new();
  local tmp = Array.new();
  if (maxbits > 32) then 
    _G.error("Invalid huffman",0);
  end;
  local _g = 0;
  while (_g < maxbits) do 
    _g = _g + 1;
    counts:push(0);
    tmp:push(0);
  end;
  local _g2 = 0;
  while (_g2 < nlengths) do 
    _g2 = _g2 + 1;
    local p = lengths[(_g2 - 1) + pos];
    if (p >= maxbits) then 
      _G.error("Invalid huffman",0);
    end;
    counts[p] = counts[p] + 1;
  end;
  local code = 0;
  local _g4 = 1;
  local _g5 = maxbits - 1;
  while (_g4 < _g5) do 
    _g4 = _g4 + 1;
    local i = _g4 - 1;
    code = _hx_bit.lshift(code + counts[i],1);
    tmp[i] = code;
  end;
  local bits = __haxe_ds_IntMap.new();
  local _g6 = 0;
  while (_g6 < nlengths) do 
    _g6 = _g6 + 1;
    local i1 = _g6 - 1;
    local l = lengths[i1 + pos];
    if (l ~= 0) then 
      local n = tmp[l - 1];
      tmp[l - 1] = n + 1;
      local key = _hx_bit.bor(_hx_bit.lshift(n,5),l);
      if (i1 == nil) then 
        bits.h[key] = __haxe_ds_IntMap.tnull;
      else
        bits.h[key] = i1;
      end;
    end;
  end;
  do return self:treeCompress(__haxe_zip_Huffman.NeedBit(self:treeMake(bits, maxbits, 0, 1), self:treeMake(bits, maxbits, 1, 1))) end
end

__haxe_zip_HuffTools.prototype.__class__ =  __haxe_zip_HuffTools

__haxe_zip__InflateImpl_Window.new = function(hasCrc) 
  local self = _hx_new(__haxe_zip__InflateImpl_Window.prototype)
  __haxe_zip__InflateImpl_Window.super(self,hasCrc)
  return self
end
__haxe_zip__InflateImpl_Window.super = function(self,hasCrc) 
  self.buffer = __haxe_io_Bytes.alloc(65536);
  self.pos = 0;
  if (hasCrc) then 
    self.crc = __haxe_crypto_Adler32.new();
  end;
end
__haxe_zip__InflateImpl_Window.__name__ = true
__haxe_zip__InflateImpl_Window.prototype = _hx_a();
__haxe_zip__InflateImpl_Window.prototype.buffer= nil;
__haxe_zip__InflateImpl_Window.prototype.pos= nil;
__haxe_zip__InflateImpl_Window.prototype.crc= nil;
__haxe_zip__InflateImpl_Window.prototype.slide = function(self) 
  if (self.crc ~= nil) then 
    self.crc:update(self.buffer, 0, 32768);
  end;
  local b = __haxe_io_Bytes.alloc(65536);
  local tmp = self;
  tmp.pos = tmp.pos - 32768;
  b:blit(0, self.buffer, 32768, self.pos);
  self.buffer = b;
end
__haxe_zip__InflateImpl_Window.prototype.addBytes = function(self,b,p,len) 
  if ((self.pos + len) > 65536) then 
    self:slide();
  end;
  self.buffer:blit(self.pos, b, p, len);
  local tmp = self;
  tmp.pos = tmp.pos + len;
end
__haxe_zip__InflateImpl_Window.prototype.addByte = function(self,c) 
  if (self.pos == 65536) then 
    self:slide();
  end;
  self.buffer.b[self.pos] = _hx_bit.band(c,255);
  self.pos = self.pos + 1;
end
__haxe_zip__InflateImpl_Window.prototype.getLastChar = function(self) 
  do return self.buffer.b[self.pos - 1] end
end
__haxe_zip__InflateImpl_Window.prototype.available = function(self) 
  do return self.pos end
end
__haxe_zip__InflateImpl_Window.prototype.checksum = function(self) 
  if (self.crc ~= nil) then 
    self.crc:update(self.buffer, 0, self.pos);
  end;
  do return self.crc end
end

__haxe_zip__InflateImpl_Window.prototype.__class__ =  __haxe_zip__InflateImpl_Window
_hxClasses["haxe.zip._InflateImpl.State"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Head","Block","CData","Flat","Crc","Dist","DistOne","Done"},8)}
__haxe_zip__InflateImpl_State = _hxClasses["haxe.zip._InflateImpl.State"];
__haxe_zip__InflateImpl_State.Head = _hx_tab_array({[0]="Head",0,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.Block = _hx_tab_array({[0]="Block",1,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.CData = _hx_tab_array({[0]="CData",2,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.Flat = _hx_tab_array({[0]="Flat",3,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.Crc = _hx_tab_array({[0]="Crc",4,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.Dist = _hx_tab_array({[0]="Dist",5,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.DistOne = _hx_tab_array({[0]="DistOne",6,__enum__ = __haxe_zip__InflateImpl_State},2)

__haxe_zip__InflateImpl_State.Done = _hx_tab_array({[0]="Done",7,__enum__ = __haxe_zip__InflateImpl_State},2)


__haxe_zip_InflateImpl.new = function(i,header,crc) 
  local self = _hx_new(__haxe_zip_InflateImpl.prototype)
  __haxe_zip_InflateImpl.super(self,i,header,crc)
  return self
end
__haxe_zip_InflateImpl.super = function(self,i,header,crc) 
  if (crc == nil) then 
    crc = true;
  end;
  if (header == nil) then 
    header = true;
  end;
  self.isFinal = false;
  self.htools = __haxe_zip_HuffTools.new();
  self.huffman = self:buildFixedHuffman();
  self.huffdist = nil;
  self.len = 0;
  self.dist = 0;
  self.state = (function() 
    local _hx_1
    if (header) then 
    _hx_1 = __haxe_zip__InflateImpl_State.Head; else 
    _hx_1 = __haxe_zip__InflateImpl_State.Block; end
    return _hx_1
  end )();
  self.input = i;
  self.bits = 0;
  self.nbits = 0;
  self.needed = 0;
  self.output = nil;
  self.outpos = 0;
  self.lengths = Array.new();
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.lengths:push(-1);
  self.window = __haxe_zip__InflateImpl_Window.new(crc);
end
__haxe_zip_InflateImpl.__name__ = true
__haxe_zip_InflateImpl.run = function(i,bufsize) 
  if (bufsize == nil) then 
    bufsize = 65536;
  end;
  local buf = __haxe_io_Bytes.alloc(bufsize);
  local output = __haxe_io_BytesBuffer.new();
  local inflate = __haxe_zip_InflateImpl.new(i);
  while (true) do 
    local len = inflate:readBytes(buf, 0, bufsize);
    if ((len < 0) or (len > buf.length)) then 
      _G.error(__haxe_io_Error.OutsideBounds,0);
    end;
    local b2 = buf.b;
    local _g = 0;
    while (_g < len) do 
      _g = _g + 1;
      output.b:push(b2[_g - 1]);
    end;
    if (len < bufsize) then 
      break;
    end;
  end;
  do return output:getBytes() end;
end
__haxe_zip_InflateImpl.prototype = _hx_a();
__haxe_zip_InflateImpl.prototype.nbits= nil;
__haxe_zip_InflateImpl.prototype.bits= nil;
__haxe_zip_InflateImpl.prototype.state= nil;
__haxe_zip_InflateImpl.prototype.isFinal= nil;
__haxe_zip_InflateImpl.prototype.huffman= nil;
__haxe_zip_InflateImpl.prototype.huffdist= nil;
__haxe_zip_InflateImpl.prototype.htools= nil;
__haxe_zip_InflateImpl.prototype.len= nil;
__haxe_zip_InflateImpl.prototype.dist= nil;
__haxe_zip_InflateImpl.prototype.needed= nil;
__haxe_zip_InflateImpl.prototype.output= nil;
__haxe_zip_InflateImpl.prototype.outpos= nil;
__haxe_zip_InflateImpl.prototype.input= nil;
__haxe_zip_InflateImpl.prototype.lengths= nil;
__haxe_zip_InflateImpl.prototype.window= nil;
__haxe_zip_InflateImpl.prototype.buildFixedHuffman = function(self) 
  if (__haxe_zip_InflateImpl.FIXED_HUFFMAN ~= nil) then 
    do return __haxe_zip_InflateImpl.FIXED_HUFFMAN end;
  end;
  local a = Array.new();
  local _g = 0;
  while (_g < 288) do 
    _g = _g + 1;
    local n = _g - 1;
    a:push((function() 
      local _hx_1
      if (n <= 143) then 
      _hx_1 = 8; elseif (n <= 255) then 
      _hx_1 = 9; elseif (n <= 279) then 
      _hx_1 = 7; else 
      _hx_1 = 8; end
      return _hx_1
    end )());
  end;
  __haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools:make(a, 0, 288, 10);
  do return __haxe_zip_InflateImpl.FIXED_HUFFMAN end
end
__haxe_zip_InflateImpl.prototype.readBytes = function(self,b,pos,len) 
  self.needed = len;
  self.outpos = pos;
  self.output = b;
  if (len > 0) then 
    while (self:inflateLoop()) do 
    end;
  end;
  do return len - self.needed end
end
__haxe_zip_InflateImpl.prototype.getBits = function(self,n) 
  while (self.nbits < n) do 
    local tmp = self;
    tmp.bits = _hx_bit.bor(tmp.bits,_hx_bit.lshift(self.input:readByte(),self.nbits));
    local tmp1 = self;
    tmp1.nbits = tmp1.nbits + 8;
  end;
  local b = _hx_bit.band(self.bits,(_hx_bit.lshift(1,n)) - 1);
  local tmp2 = self;
  tmp2.nbits = tmp2.nbits - n;
  local tmp3 = self;
  tmp3.bits = _hx_bit.arshift(tmp3.bits,n);
  do return b end
end
__haxe_zip_InflateImpl.prototype.getBit = function(self) 
  if (self.nbits == 0) then 
    self.nbits = 8;
    self.bits = self.input:readByte();
  end;
  local b = (_hx_bit.band(self.bits,1)) == 1;
  self.nbits = self.nbits - 1;
  local tmp = self;
  tmp.bits = _hx_bit.arshift(tmp.bits,1);
  do return b end
end
__haxe_zip_InflateImpl.prototype.getRevBits = function(self,n) 
  if (n == 0) then 
    do return 0 end;
  else
    if (self:getBit()) then 
      do return _hx_bit.bor(_hx_bit.lshift(1,n - 1),self:getRevBits(n - 1)) end;
    else
      do return self:getRevBits(n - 1) end;
    end;
  end;
end
__haxe_zip_InflateImpl.prototype.resetBits = function(self) 
  self.bits = 0;
  self.nbits = 0;
end
__haxe_zip_InflateImpl.prototype.addBytes = function(self,b,p,len) 
  self.window:addBytes(b, p, len);
  self.output:blit(self.outpos, b, p, len);
  local tmp = self;
  tmp.needed = tmp.needed - len;
  local tmp1 = self;
  tmp1.outpos = tmp1.outpos + len;
end
__haxe_zip_InflateImpl.prototype.addByte = function(self,b) 
  self.window:addByte(b);
  self.output.b[self.outpos] = _hx_bit.band(b,255);
  self.needed = self.needed - 1;
  self.outpos = self.outpos + 1;
end
__haxe_zip_InflateImpl.prototype.addDistOne = function(self,n) 
  local c = self.window:getLastChar();
  local _g = 0;
  while (_g < n) do 
    _g = _g + 1;
    self:addByte(c);
  end;
end
__haxe_zip_InflateImpl.prototype.addDist = function(self,d,len) 
  self:addBytes(self.window.buffer, self.window.pos - d, len);
end
__haxe_zip_InflateImpl.prototype.applyHuffman = function(self,h) 
  local tmp = h[1];
  if (tmp) == 0 then 
    do return h[2] end;
  elseif (tmp) == 1 then 
    do return self:applyHuffman((function() 
      local _hx_1
      if (self:getBit()) then 
      _hx_1 = h[3]; else 
      _hx_1 = h[2]; end
      return _hx_1
    end )()) end;
  elseif (tmp) == 2 then 
    do return self:applyHuffman(h[3][self:getBits(h[2])]) end; end;
end
__haxe_zip_InflateImpl.prototype.inflateLengths = function(self,a,max) 
  local i = 0;
  local prev = 0;
  while (i < max) do 
    local n = self:applyHuffman(self.huffman);
    if (n) == 0 or (n) == 1 or (n) == 2 or (n) == 3 or (n) == 4 or (n) == 5 or (n) == 6 or (n) == 7 or (n) == 8 or (n) == 9 or (n) == 10 or (n) == 11 or (n) == 12 or (n) == 13 or (n) == 14 or (n) == 15 then 
      prev = n;
      a[i] = n;
      i = i + 1;
    elseif (n) == 16 then 
      local _end = (i + 3) + self:getBits(2);
      if (_end > max) then 
        _G.error("Invalid data",0);
      end;
      while (i < _end) do 
        a[i] = prev;
        i = i + 1;
      end;
    elseif (n) == 17 then 
      i = i + (3 + self:getBits(3));
      if (i > max) then 
        _G.error("Invalid data",0);
      end;
    elseif (n) == 18 then 
      i = i + (11 + self:getBits(7));
      if (i > max) then 
        _G.error("Invalid data",0);
      end;else
    _G.error("Invalid data",0); end;
  end;
end
__haxe_zip_InflateImpl.prototype.inflateLoop = function(self) 
  local tmp = self.state[1];
  if (tmp) == 0 then 
    local cmf = self.input:readByte();
    if ((_hx_bit.band(cmf,15)) ~= 8) then 
      _G.error("Invalid data",0);
    end;
    local flg = self.input:readByte();
    if ((_G.math.fmod(((_hx_bit.lshift(cmf,8)) + flg), 31)) ~= 0) then 
      _G.error("Invalid data",0);
    end;
    if ((_hx_bit.band(flg,32)) ~= 0) then 
      _G.error("Unsupported dictionary",0);
    end;
    self.state = __haxe_zip__InflateImpl_State.Block;
    do return true end;
  elseif (tmp) == 1 then 
    self.isFinal = self:getBit();
    local _g = self:getBits(2);
    if (_g) == 0 then 
      self.len = self.input:readUInt16();
      if (self.input:readUInt16() ~= (65535 - self.len)) then 
        _G.error("Invalid data",0);
      end;
      self.state = __haxe_zip__InflateImpl_State.Flat;
      local r = self:inflateLoop();
      self:resetBits();
      do return r end;
    elseif (_g) == 1 then 
      self.huffman = self:buildFixedHuffman();
      self.huffdist = nil;
      self.state = __haxe_zip__InflateImpl_State.CData;
      do return true end;
    elseif (_g) == 2 then 
      local hlit = self:getBits(5) + 257;
      local hdist = self:getBits(5) + 1;
      local hclen = self:getBits(4) + 4;
      local _g1 = 0;
      while (_g1 < hclen) do 
        _g1 = _g1 + 1;
        self.lengths[__haxe_zip_InflateImpl.CODE_LENGTHS_POS[_g1 - 1]] = self:getBits(3);
      end;
      local _g2 = hclen;
      while (_g2 < 19) do 
        _g2 = _g2 + 1;
        self.lengths[__haxe_zip_InflateImpl.CODE_LENGTHS_POS[_g2 - 1]] = 0;
      end;
      self.huffman = self.htools:make(self.lengths, 0, 19, 8);
      local lengths = Array.new();
      local _g4 = 0;
      local _g5 = hlit + hdist;
      while (_g4 < _g5) do 
        _g4 = _g4 + 1;
        lengths:push(0);
      end;
      self:inflateLengths(lengths, hlit + hdist);
      self.huffdist = self.htools:make(lengths, hlit, hdist, 16);
      self.huffman = self.htools:make(lengths, 0, hlit, 16);
      self.state = __haxe_zip__InflateImpl_State.CData;
      do return true end;else
    _G.error("Invalid data",0); end;
  elseif (tmp) == 2 then 
    local n = self:applyHuffman(self.huffman);
    if (n < 256) then 
      self:addByte(n);
      do return self.needed > 0 end;
    else
      if (n == 256) then 
        self.state = (function() 
          local _hx_1
          if (self.isFinal) then 
          _hx_1 = __haxe_zip__InflateImpl_State.Crc; else 
          _hx_1 = __haxe_zip__InflateImpl_State.Block; end
          return _hx_1
        end )();
        do return true end;
      else
        n = n - 257;
        local extra_bits = __haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
        if (extra_bits == -1) then 
          _G.error("Invalid data",0);
        end;
        self.len = __haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + self:getBits(extra_bits);
        local dist_code = (function() 
          local _hx_2
          if (self.huffdist == nil) then 
          _hx_2 = self:getRevBits(5); else 
          _hx_2 = self:applyHuffman(self.huffdist); end
          return _hx_2
        end )();
        extra_bits = __haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
        if (extra_bits == -1) then 
          _G.error("Invalid data",0);
        end;
        self.dist = __haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + self:getBits(extra_bits);
        if (self.dist > self.window:available()) then 
          _G.error("Invalid data",0);
        end;
        self.state = (function() 
          local _hx_3
          if (self.dist == 1) then 
          _hx_3 = __haxe_zip__InflateImpl_State.DistOne; else 
          _hx_3 = __haxe_zip__InflateImpl_State.Dist; end
          return _hx_3
        end )();
        do return true end;
      end;
    end;
  elseif (tmp) == 3 then 
    local rlen = (function() 
      local _hx_4
      if (self.len < self.needed) then 
      _hx_4 = self.len; else 
      _hx_4 = self.needed; end
      return _hx_4
    end )();
    local bytes = self.input:read(rlen);
    local tmp1 = self;
    tmp1.len = tmp1.len - rlen;
    self:addBytes(bytes, 0, rlen);
    if (self.len == 0) then 
      self.state = (function() 
        local _hx_5
        if (self.isFinal) then 
        _hx_5 = __haxe_zip__InflateImpl_State.Crc; else 
        _hx_5 = __haxe_zip__InflateImpl_State.Block; end
        return _hx_5
      end )();
    end;
    do return self.needed > 0 end;
  elseif (tmp) == 4 then 
    local calc = self.window:checksum();
    if (calc == nil) then 
      self.state = __haxe_zip__InflateImpl_State.Done;
      do return true end;
    end;
    if (not calc:equals(__haxe_crypto_Adler32.read(self.input))) then 
      _G.error("Invalid CRC",0);
    end;
    self.state = __haxe_zip__InflateImpl_State.Done;
    do return true end;
  elseif (tmp) == 5 then 
    while ((self.len > 0) and (self.needed > 0)) do 
      local rdist = (function() 
        local _hx_6
        if (self.len < self.dist) then 
        _hx_6 = self.len; else 
        _hx_6 = self.dist; end
        return _hx_6
      end )();
      local rlen1 = (function() 
        local _hx_7
        if (self.needed < rdist) then 
        _hx_7 = self.needed; else 
        _hx_7 = rdist; end
        return _hx_7
      end )();
      self:addDist(self.dist, rlen1);
      local tmp2 = self;
      tmp2.len = tmp2.len - rlen1;
    end;
    if (self.len == 0) then 
      self.state = __haxe_zip__InflateImpl_State.CData;
    end;
    do return self.needed > 0 end;
  elseif (tmp) == 6 then 
    local rlen2 = (function() 
      local _hx_8
      if (self.len < self.needed) then 
      _hx_8 = self.len; else 
      _hx_8 = self.needed; end
      return _hx_8
    end )();
    self:addDistOne(rlen2);
    local tmp3 = self;
    tmp3.len = tmp3.len - rlen2;
    if (self.len == 0) then 
      self.state = __haxe_zip__InflateImpl_State.CData;
    end;
    do return self.needed > 0 end;
  elseif (tmp) == 7 then 
    do return false end; end;
end

__haxe_zip_InflateImpl.prototype.__class__ =  __haxe_zip_InflateImpl

__haxe_zip_Uncompress.new = {}
__haxe_zip_Uncompress.__name__ = true
__haxe_zip_Uncompress.run = function(src,bufsize) 
  do return __haxe_zip_InflateImpl.run(__haxe_io_BytesInput.new(src), bufsize) end;
end

__jsoni18n_I18n.new = function() 
  local self = _hx_new(__jsoni18n_I18n.prototype)
  __jsoni18n_I18n.super(self)
  return self
end
__jsoni18n_I18n.super = function(self) 
  self.pluralizationVar = "_";
  self.varPrefix = ":";
  self.depthDelimiter = "/";
  self.trads = _hx_e();
end
__jsoni18n_I18n.__name__ = true
__jsoni18n_I18n.prototype = _hx_a();
__jsoni18n_I18n.prototype.depthDelimiter= nil;
__jsoni18n_I18n.prototype.varPrefix= nil;
__jsoni18n_I18n.prototype.pluralizationVar= nil;
__jsoni18n_I18n.prototype.trads= nil;
__jsoni18n_I18n.prototype.loadFromString = function(self,content,prefix) 
  local data = __haxe_Json.parse(content);
  local _g = 0;
  local _g1 = Reflect.fields(data);
  while (_g < _g1.length) do 
    local key = _g1[_g];
    _g = _g + 1;
    local name = key;
    if (prefix ~= nil) then 
      name = Std.string(prefix) .. Std.string(key);
    end;
    self:update(self.trads, name, Reflect.field(data, key));
  end;
end
__jsoni18n_I18n.prototype.tr = function(self,id,vars) 
  local str = id;
  local r = __lua_lib_luautf8_Utf8.find(id, self.depthDelimiter, 1, true);
  if ((function() 
    local _hx_1
    if ((r ~= nil) and (r > 0)) then 
    _hx_1 = r - 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )() ~= -1) then 
    local o = self:fetch(self.trads, String.new(id));
    if (o ~= nil) then 
      if (__lua_Boot.__instanceof(o, String)) then 
        str = Std.string(o);
      else
        local tmp;
        if ((vars ~= nil) and (vars.h[self.pluralizationVar] ~= nil)) then 
          local key = self.pluralizationVar;
          local o1 = o;
          tmp = (function() 
            local _hx_2
            if ((_G.type(o1) == "string") and ((String.prototype[key] ~= nil) or (key == "length"))) then 
            _hx_2 = true; elseif (o1.__fields__ ~= nil) then 
            _hx_2 = o1.__fields__[key] ~= nil; else 
            _hx_2 = o1[key] ~= nil; end
            return _hx_2
          end )();
        else
          tmp = false;
        end;
        if (tmp) then 
          local ret = vars.h[self.pluralizationVar];
          if (ret == __haxe_ds_StringMap.tnull) then 
            ret = nil;
          end;
          local n = Std.parseInt(ret);
          if (n ~= nil) then 
            local tmp1;
            if (n == 0) then 
              local o2 = o;
              tmp1 = (function() 
                local _hx_3
                if ((_G.type(o2) == "string") and (String.prototype["0"] ~= nil)) then 
                _hx_3 = true; elseif (o2.__fields__ ~= nil) then 
                _hx_3 = o2.__fields__["0"] ~= nil; else 
                _hx_3 = o2["0"] ~= nil; end
                return _hx_3
              end )();
            else
              tmp1 = false;
            end;
            if (tmp1) then 
              str = Reflect.field(o, "0");
            else
              local tmp2;
              if (n == 1) then 
                local o3 = o;
                tmp2 = (function() 
                  local _hx_4
                  if ((_G.type(o3) == "string") and (String.prototype["1"] ~= nil)) then 
                  _hx_4 = true; elseif (o3.__fields__ ~= nil) then 
                  _hx_4 = o3.__fields__["1"] ~= nil; else 
                  _hx_4 = o3["1"] ~= nil; end
                  return _hx_4
                end )();
              else
                tmp2 = false;
              end;
              if (tmp2) then 
                str = Reflect.field(o, "1");
              else
                local key1 = self.pluralizationVar;
                local o4 = o;
                if ((function() 
                  local _hx_5
                  if ((_G.type(o4) == "string") and ((String.prototype[key1] ~= nil) or (key1 == "length"))) then 
                  _hx_5 = true; elseif (o4.__fields__ ~= nil) then 
                  _hx_5 = o4.__fields__[key1] ~= nil; else 
                  _hx_5 = o4[key1] ~= nil; end
                  return _hx_5
                end )()) then 
                  str = Reflect.field(o, self.pluralizationVar);
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  else
    local o5 = self.trads;
    if ((function() 
      local _hx_6
      if ((_G.type(o5) == "string") and ((String.prototype[id] ~= nil) or (id == "length"))) then 
      _hx_6 = true; elseif (o5.__fields__ ~= nil) then 
      _hx_6 = o5.__fields__[id] ~= nil; else 
      _hx_6 = o5[id] ~= nil; end
      return _hx_6
    end )() == true) then 
      str = Reflect.field(self.trads, id);
    end;
  end;
  if (vars ~= nil) then 
    local key2 = vars:keys();
    while (key2:hasNext()) do 
      local key3 = key2:next();
      local ret1 = vars.h[key3];
      if (ret1 == __haxe_ds_StringMap.tnull) then 
        ret1 = nil;
      end;
      str = StringTools.replace(str, Std.string(self.varPrefix) .. Std.string(key3), ret1);
    end;
  end;
  do return str end
end
__jsoni18n_I18n.prototype.update = function(self,el,rest,data) 
  local r = __lua_lib_luautf8_Utf8.find(rest, self.depthDelimiter, 1, true);
  local pos = (function() 
    local _hx_1
    if ((r ~= nil) and (r > 0)) then 
    _hx_1 = r - 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  if (pos == -1) then 
    local o = el;
    if ((function() 
      local _hx_2
      if ((_G.type(o) == "string") and ((String.prototype[rest] ~= nil) or (rest == "length"))) then 
      _hx_2 = true; elseif (o.__fields__ ~= nil) then 
      _hx_2 = o.__fields__[rest] ~= nil; else 
      _hx_2 = o[rest] ~= nil; end
      return _hx_2
    end )() == true) then 
      el = Reflect.field(el, rest);
      local _g = 0;
      local _g1 = Reflect.fields(data);
      while (_g < _g1.length) do 
        local key = _g1[_g];
        _g = _g + 1;
        el[key] = Reflect.field(data, key);
      end;
    else
      el[rest] = data;
    end;
  else
    local len = pos;
    if ((len == nil) or (len > __lua_lib_luautf8_Utf8.len(rest))) then 
      len = __lua_lib_luautf8_Utf8.len(rest);
    else
      if (len < 0) then 
        len = __lua_lib_luautf8_Utf8.len(rest) + len;
      end;
    end;
    local part = __lua_lib_luautf8_Utf8.sub(rest, 1, len);
    local pos1 = pos + 1;
    local len1 = nil;
    len1 = __lua_lib_luautf8_Utf8.len(rest);
    if (pos1 < 0) then 
      pos1 = __lua_lib_luautf8_Utf8.len(rest) + pos1;
    end;
    if (pos1 < 0) then 
      pos1 = 0;
    end;
    rest = __lua_lib_luautf8_Utf8.sub(rest, pos1 + 1, pos1 + len1);
    local sub;
    local o1 = el;
    if ((function() 
      local _hx_3
      if ((_G.type(o1) == "string") and ((String.prototype[part] ~= nil) or (part == "length"))) then 
      _hx_3 = true; elseif (o1.__fields__ ~= nil) then 
      _hx_3 = o1.__fields__[part] ~= nil; else 
      _hx_3 = o1[part] ~= nil; end
      return _hx_3
    end )() == false) then 
      sub = _hx_e();
      el[part] = sub;
    else
      sub = Reflect.field(el, part);
    end;
    self:update(sub, rest, data);
  end;
end
__jsoni18n_I18n.prototype.fetch = function(self,el,rest) 
  local r = __lua_lib_luautf8_Utf8.find(rest, self.depthDelimiter, 1, true);
  local pos = (function() 
    local _hx_1
    if ((r ~= nil) and (r > 0)) then 
    _hx_1 = r - 1; else 
    _hx_1 = -1; end
    return _hx_1
  end )();
  if (pos == -1) then 
    do return Reflect.field(el, rest) end;
  end;
  local len = pos;
  if ((len == nil) or (len > __lua_lib_luautf8_Utf8.len(rest))) then 
    len = __lua_lib_luautf8_Utf8.len(rest);
  else
    if (len < 0) then 
      len = __lua_lib_luautf8_Utf8.len(rest) + len;
    end;
  end;
  local part = __lua_lib_luautf8_Utf8.sub(rest, 1, len);
  local pos1 = pos + 1;
  local len1 = nil;
  len1 = __lua_lib_luautf8_Utf8.len(rest);
  if (pos1 < 0) then 
    pos1 = __lua_lib_luautf8_Utf8.len(rest) + pos1;
  end;
  if (pos1 < 0) then 
    pos1 = 0;
  end;
  rest = __lua_lib_luautf8_Utf8.sub(rest, pos1 + 1, pos1 + len1);
  local o = el;
  if ((function() 
    local _hx_2
    if ((_G.type(o) == "string") and ((String.prototype[part] ~= nil) or (part == "length"))) then 
    _hx_2 = true; elseif (o.__fields__ ~= nil) then 
    _hx_2 = o.__fields__[part] ~= nil; else 
    _hx_2 = o[part] ~= nil; end
    return _hx_2
  end )() == false) then 
    do return nil end;
  end;
  do return self:fetch(Reflect.field(el, part), rest) end
end

__jsoni18n_I18n.prototype.__class__ =  __jsoni18n_I18n

__lua_Boot.new = {}
__lua_Boot.__name__ = true
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl2 = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl2 ~= nil) then 
          _hx_1 = cl2; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.__cast = function(o,t) 
  if ((o == nil) or __lua_Boot.__instanceof(o, t)) then 
    do return o end;
  else
    _G.error(Std.string(Std.string(Std.string("Cannot cast ") .. Std.string(Std.string(o))) .. Std.string(" to ")) .. Std.string(Std.string(t)),0);
  end;
end
__lua_Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(Std.string(o[0])) .. Std.string("(");
    s = Std.string(s) .. Std.string("\t");
    local _g = 2;
    local _g1 = o.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (i ~= 2) then 
        str = Std.string(str) .. Std.string((Std.string(",") .. Std.string(__lua_Boot.__string_rec(o[i], s))));
      else
        str = Std.string(str) .. Std.string(__lua_Boot.__string_rec(o[i], s));
      end;
    end;
    do return Std.string(str) .. Std.string(")") end;
  end;
end
__lua_Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = __lua_Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
__lua_Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  if (__lua_lib_luautf8_Utf8.len(s) >= 5) then 
    do return "<...>" end;
  end;
  local _g = type(o);
  if (_g) == "boolean" then 
    do return tostring(o) end;
  elseif (_g) == "function" then 
    do return "<function>" end;
  elseif (_g) == "nil" then 
    do return "null" end;
  elseif (_g) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o == 0) then 
          do return "0" end;
        else
          if (o ~= o) then 
            do return "NaN" end;
          else
            do return tostring(o) end;
          end;
        end;
      end;
    end;
  elseif (_g) == "string" then 
    do return o end;
  elseif (_g) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return __lua_Boot.printEnum(o, s) end;
    else
      if ((_hx_wrap_if_string_field(o,'toString') ~= nil) and not __lua_Boot.isArray(o)) then 
        do return _hx_wrap_if_string_field(o,'toString')(o) end;
      else
        if (__lua_Boot.isArray(o)) then 
          local o2 = o;
          if (__lua_lib_luautf8_Utf8.len(s) > 5) then 
            do return "[...]" end;
          else
            local _g1 = _hx_tab_array({}, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g1:push(__lua_Boot.__string_rec(i, Std.string(s) .. Std.string(1)));
            end;
            do return Std.string(Std.string("[") .. Std.string(_g1:join(","))) .. Std.string("]") end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return Std.string(Std.string("{") .. Std.string(__lua_Boot.printClassRec(o, "", Std.string(s) .. Std.string("\t")))) .. Std.string("}") end;
          else
            local fields = __lua_Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer, "{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer, ", ");
              end;
              _G.table.insert(buffer, Std.string(Std.string(Std.string("") .. Std.string(Std.string(f1))) .. Std.string(" : ")) .. Std.string(__lua_Boot.__string_rec(o[f1], Std.string(s) .. Std.string("\t"))));
            end;
            _G.table.insert(buffer, " }");
            do return _G.table.concat(buffer, "") end;
          end;
        end;
      end;
    end;
  elseif (_g) == "thread" then 
    do return "<thread>" end;
  elseif (_g) == "userdata" then 
    local mt = _G.getmetatable(o);
    if ((mt ~= nil) and (mt.__tostring ~= nil)) then 
      do return _G.tostring(o) end;
    else
      do return "<userdata>" end;
    end;else
  _G.error("Unknown Lua type",0); end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end
__lua_Boot.fieldIterator = function(o) 
  if (_G.type(o) ~= "table") then 
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      do return nil end;
    end,hasNext=function(self) 
      do return false end;
    end}) end;
  end;
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (__lua_Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1, val);
    end;
    do return val end;
  end;
  local cur_val = next_valid(tbl, cur(tbl, nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl, cur(tbl, cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end

__lua_UserData.new = {}
__lua_UserData.__name__ = true

__lua_Thread.new = {}
__lua_Thread.__name__ = true

__seedyrng_GeneratorInterface.new = {}
__seedyrng_GeneratorInterface.__name__ = true
__seedyrng_GeneratorInterface.prototype = _hx_a();
__seedyrng_GeneratorInterface.prototype.set_seed= nil;

__seedyrng_GeneratorInterface.prototype.__class__ =  __seedyrng_GeneratorInterface

__seedyrng_Random.new = function(seed,generator) 
  local self = _hx_new(__seedyrng_Random.prototype)
  __seedyrng_Random.super(self,seed,generator)
  return self
end
__seedyrng_Random.super = function(self,seed,generator) 
  if (seed == nil) then 
    seed = __haxe__Int64____Int64.new(__seedyrng_Random.randomSystemInt(), __seedyrng_Random.randomSystemInt());
  end;
  if (generator == nil) then 
    generator = __seedyrng_Xorshift128Plus.new();
  end;
  self.generator = generator;
  self:set_seed(seed);
end
__seedyrng_Random.__name__ = true
__seedyrng_Random.__interfaces__ = {__seedyrng_GeneratorInterface}
__seedyrng_Random.randomSystemInt = function() 
  do return _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_hx_bit.lshift(Std.random(255),24),_hx_bit.lshift(Std.random(255),16)),_hx_bit.lshift(Std.random(255),8)),Std.random(255)) end;
end
__seedyrng_Random.prototype = _hx_a();
__seedyrng_Random.prototype.generator= nil;
__seedyrng_Random.prototype.set_seed = function(self,value) 
  do return self.generator:set_seed(value) end
end

__seedyrng_Random.prototype.__class__ =  __seedyrng_Random

__seedyrng_Xorshift128Plus.new = function() 
  local self = _hx_new(__seedyrng_Xorshift128Plus.prototype)
  __seedyrng_Xorshift128Plus.super(self)
  return self
end
__seedyrng_Xorshift128Plus.super = function(self) 
  self._currentAvailable = false;
  self:set_seed(__haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(1, 31), 1));
end
__seedyrng_Xorshift128Plus.__name__ = true
__seedyrng_Xorshift128Plus.__interfaces__ = {__seedyrng_GeneratorInterface}
__seedyrng_Xorshift128Plus.prototype = _hx_a();
__seedyrng_Xorshift128Plus.prototype._seed= nil;
__seedyrng_Xorshift128Plus.prototype._state0= nil;
__seedyrng_Xorshift128Plus.prototype._state1= nil;
__seedyrng_Xorshift128Plus.prototype._currentAvailable= nil;
__seedyrng_Xorshift128Plus.prototype.set_seed = function(self,value) 
  local high = __haxe__Int32_Int32_Impl_.shr(0, 31);
  value = (function() 
    local _hx_1
    if ((value.high ~= high) or (value.low ~= 0)) then 
    _hx_1 = value; else 
    _hx_1 = __haxe__Int64____Int64.new(__haxe__Int32_Int32_Impl_.shr(1, 31), 1); end
    return _hx_1
  end )();
  self._seed = value;
  self._state0 = value;
  self._state1 = _hx_funcToField(__seedyrng_Xorshift128Plus.SEED_1);
  self._currentAvailable = false;
  do return value end
end

__seedyrng_Xorshift128Plus.prototype.__class__ =  __seedyrng_Xorshift128Plus

__shared_Configs.new = {}
_hx_exports["shared"]["Configs"] = __shared_Configs
__shared_Configs.__name__ = true
__shared_Configs.parse = function(json) 
  do return Reflect.callMethod(__haxe_Json,Reflect.field(__haxe_Json, "parseFast"),_hx_tab_array({[0]=json}, 1)) end;
end
__shared_Configs.getConfigByLocale = function(locale) 
  if (locale == "ru") then 
    if (__shared_Configs.configRU == nil) then 
      __shared_Configs.configRU = __shared_Configs.parseConfig(__shared_Configs.parse(__haxe_Resource.getString("game_configs_ru")));
    end;
    do return __shared_Configs.configRU end;
  end;
  if (__shared_Configs.configEN == nil) then 
    __shared_Configs.configEN = __shared_Configs.parseConfig(__shared_Configs.parse(__haxe_Resource.getString("game_configs_en")));
  end;
  do return __shared_Configs.configEN end;
end
__shared_Configs.getConfigByWorld = function(world) 
  do return __shared_Configs.getConfigByLocale(world:storageGet().user.locale) end;
end
__shared_Configs.parseConfig = function(config) 
  do return _hx_o({__fields__={config=true},config=config}) end;
end
__shared_Configs.validate = function(config) 
end
__shared_Configs.checksCurrentConfigs = function(world) 
end

__shared_Shared.new = function(nativeApi,storageJson,contextsJson,initClientStorage,isDev) 
  local self = _hx_new(__shared_Shared.prototype)
  __shared_Shared.super(self,nativeApi,storageJson,contextsJson,initClientStorage,isDev)
  return self
end
__shared_Shared.super = function(self,nativeApi,storageJson,contextsJson,initClientStorage,isDev) 
  if (isDev == nil) then 
    isDev = false;
  end;
  if (initClientStorage == nil) then 
    initClientStorage = false;
  end;
  self.nativeApi = nativeApi;
  self.dsBackupJson = storageJson;
  local storage = __shared_project_storage_Storage.restore(storageJson);
  if (initClientStorage) then 
    __shared_project_storage_Storage.initClientStruct(storage);
  end;
  self.world = __shared_project_model_World.new(storage);
  self.i18n = __shared_base_Localization.getI18n(self.world:storageGet().user.locale);
  self.world:setI18n(self.i18n);
  self.world.isDevServer = isDev;
  self.intentProcessor = __shared_project_intent_processors_IntentProcessor.new(self.world, self, self.i18n);
  self.world:setIntentProcessor(self.intentProcessor);
  self:contextInit(contextsJson);
end
_hx_exports["shared"]["Shared"] = __shared_Shared
__shared_Shared.__name__ = true
__shared_Shared.ContextJsonToMap = function(contextsJson) 
  local contextsData = __haxe_Json.parse(contextsJson);
  local contexts = Array.new();
  local i = 0;
  while ((contextsJson ~= "") and (contextsJson ~= "{}")) do 
    local context = contextsData[i];
    if (context == nil) then 
      break;
    end;
    local lifespan = context.lifespan;
    if (lifespan == nil) then 
      lifespan = 0;
    end;
    if (lifespan > 0) then 
      contexts:push(__shared_base_struct_ContextStruct.new(context.name, lifespan, context.parameters));
    end;
    i = i + 1;
  end;
  do return __shared_Shared.ContextArrayToMap(contexts) end;
end
__shared_Shared.ContextArrayToMap = function(array) 
  local contexts = __haxe_ds_StringMap.new();
  local _g = 0;
  while (_g < array.length) do 
    local context = array[_g];
    _g = _g + 1;
    local lifespan = context.lifespan;
    if (lifespan == nil) then 
      lifespan = 0;
    end;
    contexts:set(context.name, __shared_base_struct_ContextStruct.new(context.name, lifespan, context.parameters));
  end;
  do return contexts end;
end
__shared_Shared.load = function() 
  __shared_project_enums_Intents.init();
  local time = __shared_project_utils_TimeUtils.getCurrentTime();
  __shared_Configs.getConfigByLocale("en");
  __haxe_Log.trace(Std.string("load configs") .. Std.string((__shared_project_utils_TimeUtils.getCurrentTime() - time)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=385,className="shared.Shared",methodName="load"}));
  time = __shared_project_utils_TimeUtils.getCurrentTime();
  __shared_base_Localization.getI18n("en");
  __haxe_Log.trace(Std.string("load locale") .. Std.string((__shared_project_utils_TimeUtils.getCurrentTime() - time)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=388,className="shared.Shared",methodName="load"}));
  __shared_base_SpeechCommands.load();
  __shared_base_MatchWords.load();
end
__shared_Shared.jsonToDynamic = function(json) 
  do return __haxe_Json.parse(json) end;
end
__shared_Shared.prepareStorage = function(storage,user,version) 
  local storage1 = __haxe_Json.parse(storage);
  storage1.user = __haxe_Json.parse(user);
  storage1.version = __haxe_Json.parse(version);
  do return __haxe_Json.stringify(storage1) end;
end
__shared_Shared.prototype = _hx_a();
__shared_Shared.prototype.nativeApi= nil;
__shared_Shared.prototype.i18n= nil;
__shared_Shared.prototype.world= nil;
__shared_Shared.prototype.intentProcessor= nil;
__shared_Shared.prototype.dsBackupJson= nil;
__shared_Shared.prototype.isDevUser = function(self) 
  do return self.world:isDevUser() end
end
__shared_Shared.prototype.setConversationID = function(self,id) 
  self.world:storageGet().profile.conversationIdCurrent = id;
end
__shared_Shared.prototype.setUUID = function(self,uuid) 
  self.world:storageGet().profile.uuid = uuid;
end
__shared_Shared.prototype.setClientIntentIdx = function(self,idx) 
  __haxe_Log.trace(Std.string("setClientIntentIdx:") .. Std.string(idx), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=71,className="shared.Shared",methodName="setClientIntentIdx"}));
  self.world.clientIntentIdx = idx;
end
__shared_Shared.prototype.storageInit = function(self,storageJson) 
  self.dsBackupJson = storageJson;
  self.world:storageInit(__shared_project_storage_Storage.restore(storageJson));
end
__shared_Shared.prototype.contextInit = function(self,contextsJson) 
  self.world:contextInit(__shared_Shared.ContextJsonToMap(contextsJson));
end
__shared_Shared.prototype.updateServerTime = function(self,time) 
  local tmp = (function() 
    local _hx_1
    if (time ~= nil) then 
    _hx_1 = time; else 
    _hx_1 = __shared_project_utils_TimeUtils.getCurrentTime(); end
    return _hx_1
  end )();
  self.world:storageGet().timers.serverLastTime = tmp;
end
__shared_Shared.prototype.getAutolistening = function(self) 
  do return self.world:storageGet().utils.auto_listening end
end
__shared_Shared.prototype.updateClientTime = function(self) 
  local tmp = __shared_project_utils_TimeUtils.getCurrentTime();
  self.world:storageGet().timers.time = tmp + self.world:storageGet().timers.clientDeltaTime;
  local client = self.world:storageGet().clientStruct;
  if (client ~= nil) then 
    client.time = __shared_project_utils_TimeUtils.getCurrentTime();
  end;
end
__shared_Shared.prototype.updateClientDeltaTime = function(self) 
  local tmp = self.world:storageGet().timers.serverLastTime;
  local tmp1 = __shared_project_utils_TimeUtils.getCurrentTime();
  self.world:storageGet().timers.clientDeltaTime = tmp - tmp1;
  self:updateClientTime();
end
__shared_Shared.prototype.update = function(self) 
  local prevTime = self.world:storageGet().timers.time;
  local prevTimeClient = 0;
  local client = self.world:storageGet().clientStruct;
  if (client ~= nil) then 
    prevTimeClient = client.time;
  end;
  self:updateClientTime();
  self.world:storageGet().timers.timerDelta = self.world:storageGet().timers.time - prevTime;
  local client1 = self.world:storageGet().clientStruct;
  if (client1 ~= nil) then 
    client1.timerDeltaClient = client1.time - prevTimeClient;
  end;
end
__shared_Shared.prototype.postProcessIntent = function(self,response) 
end
__shared_Shared.prototype.processPurchase = function(self,data) 
  self.intentProcessor:processIntent("actions.iap.buy", data);
end
__shared_Shared.prototype.sendInputRawRequest = function(self,data) 
  __shared_project_analytics_AnalyticsHelper.sendInputRequestRawEvent(self.world, data);
end
__shared_Shared.prototype.processIntent = function(self,intentStart,data) 
  self.world:storageGet().utils.auto_listening = false;
  self.world.intent = intentStart;
  if (self.world.intent == "main.welcome") then 
    self.world.tutorialsModel:updateStorageOnGameRestart();
  end;
  self:updateClientDeltaTime();
  self:update();
  if (self.world.intent ~= "main.keep_working") then 
    self.world:storageGet().stat.intentIdx = self.world:storageGet().stat.intentIdx + 1;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (self.world.intent == "tutorial.yes") then 
        local tmp = self.world.tutorialsModel:findIntentReplacement(self.world.intent, data);
        self.world.intent = _hx_funcToField(tmp.intent);
        data = tmp.data;
      end;
      if (self.world.intent == "tutorial.yes") then 
        self.world.intent = "main.fallback";
      end;
      self.world:canProcessIntent(self.world.intent, data, true);
      self.world.tutorialsModel:tutorialsAnyActive();
      local response = self.intentProcessor:processIntent(self.world.intent, data);
      self:postProcessIntent(response);
      self.world.tutorialsModel:postProcessIntent(self.world.intent, response.modelResult.code);
      if (__shared_project_analytics_AnalyticsHelper.intentExclusions:indexOf(self.world.intent) == -1) then 
        __shared_project_analytics_AnalyticsHelper.sendOutputResponseEvent(self.world, __haxe_Json.stringify(response.modelResult));
      end;
      if ((self.world.intent ~= "main.welcome") and not self.world.tutorialsModel:tutorialsAnyActive()) then 
        self.world:storageGet().utils.auto_listening = true;
      end;
      response.events = self.world:eventGetAll();
      response.analyticEvents = self.world.dtdAnalytics:getEvents();
      local speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(self.world);
      if (not self.world.speechBuilder:isEmpty()) then 
        speechBuilder:text(self.world.speechBuilder:buildText());
        self.world.speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(self.world);
      end;
      if (not self.intentProcessor.speechBuilder:isEmpty()) then 
        speechBuilder:text(self.intentProcessor.speechBuilder:buildText());
        self.intentProcessor.speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(self.world);
      end;
      if (not self.world.speechBuilderTutorial:isEmpty()) then 
        if (not speechBuilder:isEmpty()) then 
          speechBuilder:breakTime(0.5);
        end;
        speechBuilder:text(self.world.speechBuilderTutorial:buildText());
        self.world.speechBuilderTutorial = __shared_base_utils_GameUtils.getSpeechBuilder(self.world);
      end;
      self:continuosMatchIsEnabled();
      if (not speechBuilder:isEmpty()) then 
        local text = speechBuilder:build();
        self:getNativeApi():convAsk(text);
        if (__shared_project_analytics_AnalyticsHelper.intentExclusions:indexOf(self.world.intent) == -1) then 
          __shared_project_analytics_AnalyticsHelper.sendOutputSpeechEvent(self.world, text);
        end;
      end;
      if (response.modelResult.code == "EXIT") then 
        self:getNativeApi():convExit();
        do return end;
      end;
      if (response.modelResult.code == "EXIT_AND_SAVE") then 
        self:flush();
        self:getNativeApi():convExit();
        do return end;
      end;
      local continuousMatchConfig = self.world:storageGet().continuousMatchConfig;
      self.world:storageGet().continuousMatchConfig = nil;
      self:flush();
      self.world:storageGet().continuousMatchConfig = continuousMatchConfig;
      self.world:eventClear();
      local out = self:outputGet();
      out.intent = self.world.intent;
      out.response = response;
      out.continuousMatchConfig = continuousMatchConfig;
      self.nativeApi:convAskHtmlResponse(__haxe_Json.stringify(out));
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    if( __lua_Boot.__instanceof(_hx_1,String) ) then 
      local error = _hx_1
      __haxe_Log.trace(_hx_wrap_if_string_field(__haxe_CallStack,'toString')(__haxe_CallStack.exceptionStack()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=275,className="shared.Shared",methodName="processIntent"}));
      self:processError(error);
    else _G.error(_hx_1)
    end
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__shared_Shared.prototype.saveOut = function(self) 
end
__shared_Shared.prototype.setIaps = function(self,json) 
  self.world:storageGet().iap.skuGoogle = __haxe_Json.parse(json);
end
__shared_Shared.prototype.processUnknownIntent = function(self,intent_name) 
  self:processError(Std.string("processUnknownIntent:") .. Std.string(intent_name));
end
__shared_Shared.prototype.processError = function(self,error) 
  self.nativeApi:convAsk(self.i18n:tr("conv/error"));
  self:storageInit(self.dsBackupJson);
  local out = self:outputGet();
  self:storageInit(self.dsBackupJson);
  out.intent = "main.error";
  local stack = __haxe_CallStack.exceptionStack();
  self.world.dtdAnalytics = __shared_project_analytics_DtdAnalytics.new();
  local tmp = Array.new();
  out.response = _hx_o({__fields__={modelResult=true,events=true,analyticEvents=true},modelResult=_hx_o({__fields__={code=true,data=true},code="ERROR",data=_hx_o({__fields__={error=true,stack=true},error=error,stack=stack})}),events=tmp,analyticEvents=Array.new()});
  __shared_project_analytics_AnalyticsHelper.sendProcessErrorEvent(self.world, error, Std.string(stack));
  self.nativeApi:convAskHtmlResponse(__haxe_Json.stringify(out));
end
__shared_Shared.prototype.flush = function(self) 
  self.nativeApi:saveStorage(__haxe_Json.stringify(self.world:storageOutputGet()));
  local _g = 0;
  local _g1 = self.world:contextGetAll();
  while (_g < _g1.length) do 
    local context = _g1[_g];
    _g = _g + 1;
    self.nativeApi:contextSet(context.name, context.lifespan, context.parameters);
  end;
  self.nativeApi:flushDone();
end
__shared_Shared.prototype.outputGet = function(self) 
  local contexts = __haxe_ds_StringMap.new();
  local contextsArray = Array.new();
  local worldContexts = self.world:contextGetAll();
  local _g = 0;
  while (_g < worldContexts.length) do 
    local context = worldContexts[_g];
    _g = _g + 1;
    contexts:set(context.name, context);
  end;
  local context1 = contexts:iterator();
  while (context1:hasNext()) do 
    local context2 = context1:next();
    if (context2.lifespan > 0) then 
      contextsArray:push(context2);
    end;
  end;
  do return _hx_o({__fields__={storage=true,contexts=true,continuousMatchConfig=true},storage=self.world:storageOutputGet(),contexts=contextsArray,continuousMatchConfig=nil}) end
end
__shared_Shared.prototype.getNativeApi = function(self) 
  do return self.nativeApi end
end
__shared_Shared.prototype.continuosMatchIsEnabled = function(self) 
  do return self.world:storageGet().continuousMatchConfig ~= nil end
end
__shared_Shared.prototype.continuosMatchGetJson = function(self) 
  local config = self.world:storageGet().continuousMatchConfig;
  if (config == nil) then 
    do return "" end;
  end;
  do return __haxe_Json.stringify(config) end
end
__shared_Shared.prototype.continuosMatchSetWords = function(self) 
  __haxe_Log.trace("continuosMatchSetWords", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=364,className="shared.Shared",methodName="continuosMatchSetWords"}));
  local match = self.world:storageGet().continuousMatchConfig;
  if (match ~= nil) then 
    if (self.world:storageGet().serverStruct ~= nil) then 
      local addedWords_h = ({});
      local _g = 0;
      local _g1 = __shared_base_MatchWords.getForWorld(self.world);
      while (_g < _g1.length) do 
        local word = _g1[_g];
        _g = _g + 1;
        addedWords_h[word] = true;
        match.expected_phrases:push(_hx_o({__fields__={phrase=true},phrase=word}));
      end;
    end;
  else
    __haxe_Log.trace("no match", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/Shared.hx",lineNumber=375,className="shared.Shared",methodName="continuosMatchSetWords"}));
  end;
end

__shared_Shared.prototype.__class__ =  __shared_Shared

__shared_base_Localization.new = {}
__shared_base_Localization.__name__ = true
__shared_base_Localization.getI18n = function(locale) 
  if (locale == "ru") then 
    if (__shared_base_Localization.ru == nil) then 
      __shared_base_Localization.ru = __jsoni18n_I18n.new();
      __shared_base_Localization.ru:loadFromString(__haxe_Resource.getString("localization_ru"));
    end;
    do return __shared_base_Localization.ru end;
  end;
  if (__shared_base_Localization.eng == nil) then 
    __shared_base_Localization.eng = __jsoni18n_I18n.new();
    __shared_base_Localization.eng:loadFromString(__haxe_Resource.getString("localization_eng"));
  end;
  do return __shared_base_Localization.eng end;
end

__shared_base_MatchWords.new = {}
_hx_exports["shared"]["base"]["MatchWords"] = __shared_base_MatchWords
__shared_base_MatchWords.__name__ = true
__shared_base_MatchWords.parse = function(str) 
  local result = Array.new();
  local jsonData = __haxe_Json.parse(str);
  if (jsonData == nil) then 
    __haxe_Log.trace(str, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/base/MatchWords.hx",lineNumber=19,className="shared.base.MatchWords",methodName="parse"}));
    _G.error("json not valid",0);
  end;
  local _g_keys = Reflect.fields(jsonData);
  local _g_index = 0;
  while (_g_index < _g_keys.length) do 
    _g_index = _g_index + 1;
    local key = _g_keys[_g_index - 1];
    local kv = _hx_o({__fields__={value=true,key=true},value=Reflect.field(jsonData, key),key=key});
    local intent = kv.key;
    local msg = Std.string("unknown intent:") .. Std.string(intent);
    if (not __shared_project_enums_Intents.isIntent(intent)) then 
      if (msg == nil) then 
        msg = "assert";
      end;
      _G.error(msg,0);
    end;
    local list = kv.value;
    local _g = 0;
    while (_g < list.length) do 
      local word = list[_g];
      _g = _g + 1;
      result:push(word);
    end;
  end;
  do return result end;
end
__shared_base_MatchWords.getForLocale = function(locale) 
  if (locale == "ru") then 
    do return __shared_base_MatchWords.ru end;
  else
    do return __shared_base_MatchWords.eng end;
  end;
end
__shared_base_MatchWords.getForWorld = function(world) 
  do return __shared_base_MatchWords.getForLocale(world:storageGet().user.locale) end;
end
__shared_base_MatchWords.load = function() 
  __shared_base_MatchWords.ru = __shared_base_MatchWords.parse(__haxe_Resource.getString("match_words_ru"));
  __shared_base_MatchWords.eng = __shared_base_MatchWords.parse(__haxe_Resource.getString("match_words_en"));
  __haxe_Log.trace(__shared_base_MatchWords.ru, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/base/MatchWords.hx",lineNumber=51,className="shared.base.MatchWords",methodName="load"}));
  __haxe_Log.trace(__shared_base_MatchWords.eng, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/base/MatchWords.hx",lineNumber=52,className="shared.base.MatchWords",methodName="load"}));
end

__shared_base_NativeApi.new = {}
_hx_exports["shared"]["base"]["NativeApi"] = __shared_base_NativeApi
__shared_base_NativeApi.__name__ = true
__shared_base_NativeApi.prototype = _hx_a();
__shared_base_NativeApi.prototype.saveStorage= nil;
__shared_base_NativeApi.prototype.contextSet= nil;
__shared_base_NativeApi.prototype.convAsk= nil;
__shared_base_NativeApi.prototype.convAskHtmlResponse= nil;
__shared_base_NativeApi.prototype.flushDone= nil;
__shared_base_NativeApi.prototype.convExit= nil;

__shared_base_NativeApi.prototype.__class__ =  __shared_base_NativeApi

__shared_base_SpeechCommands.new = {}
_hx_exports["shared"]["base"]["SpeechCommands"] = __shared_base_SpeechCommands
__shared_base_SpeechCommands.__name__ = true
__shared_base_SpeechCommands.parseCommands = function(str) 
  local result = Array.new();
  result:sort(function(a,b) 
    if (a.order > b.order) then 
      do return -1 end;
    else
      if (a.order < b.order) then 
        do return 1 end;
      else
        do return 0 end;
      end;
    end;
  end);
  do return result end;
end
__shared_base_SpeechCommands.checkIntent = function(world,query) 
  query = __lua_lib_luautf8_Utf8.lower(query);
  query = StringTools.trim(query);
  local array = __shared_base_SpeechCommands.getForLocale(world:storageGet().user.locale);
  local _g = 0;
  while (_g < array.length) do 
    local data = array[_g];
    _g = _g + 1;
    if (world:canProcessIntent(data.intent, nil, false) and data.regexp:match(query)) then 
      do return data.intent end;
    end;
  end;
  do return nil end;
end
__shared_base_SpeechCommands.getForLocale = function(locale) 
  if (locale == "ru") then 
    do return __shared_base_SpeechCommands.ru end;
  else
    do return __shared_base_SpeechCommands.eng end;
  end;
end
__shared_base_SpeechCommands.load = function() 
  __shared_base_SpeechCommands.ru = __shared_base_SpeechCommands.parseCommands(__haxe_Resource.getString("speech_commands_ru"));
  __shared_base_SpeechCommands.eng = __shared_base_SpeechCommands.parseCommands(__haxe_Resource.getString("speech_commands_en"));
end

__shared_base_event_EventHelper.new = {}
__shared_base_event_EventHelper.__name__ = true
__shared_base_event_EventHelper.levelNew = function(world) 
  world:eventEmit("LEVEL_NEW");
end
__shared_base_event_EventHelper.levelMoveToNext = function(world) 
  world:eventEmit("LEVEL_MOVE_TO_NEXT");
end
__shared_base_event_EventHelper.levelNextTurn = function(world) 
  world:eventEmit("LEVEL_NEXT_TURN");
end
__shared_base_event_EventHelper.levelMoneyChange = function(world,count,tag) 
  world:eventEmit("LEVEL_MONEY_CHANGE", _hx_o({__fields__={count=true,tag=true},count=count,tag=tag}));
end
__shared_base_event_EventHelper.levelManaChange = function(world,count,tag) 
  world:eventEmit("LEVEL_MANA_CHANGE", _hx_o({__fields__={count=true,tag=true},count=count,tag=tag}));
end
__shared_base_event_EventHelper.levelUnitSpawn = function(world,id,struct) 
  world:eventEmit("LEVEL_UNIT_SPAWN", _hx_o({__fields__={id=true,struct=true},id=id,struct=Reflect.copy(struct)}));
end
__shared_base_event_EventHelper.levelCaravanSpawn = function(world,id,struct) 
  world:eventEmit("LEVEL_CARAVAN_SPAWN", _hx_o({__fields__={id=true,struct=true},id=id,struct=Reflect.copy(struct)}));
end
__shared_base_event_EventHelper.levelCaravanDiewMoveToNextCastle = function(world,id) 
  world:eventEmit("LEVEL_CARAVAN_DIED_MOVE_TO_NEXT_CASTLE", _hx_o({__fields__={id=true},id=id}));
end
__shared_base_event_EventHelper.levelCaravanMove = function(world,id,roadId) 
  world:eventEmit("LEVEL_CARAVAN_MOVE", _hx_o({__fields__={id=true,roadId=true},id=id,roadId=roadId}));
end
__shared_base_event_EventHelper.levelCaravanLoad = function(world,id) 
  world:eventEmit("LEVEL_CARAVAN_LOAD", _hx_o({__fields__={id=true},id=id}));
end
__shared_base_event_EventHelper.levelCaravanUnLoad = function(world,id) 
  world:eventEmit("LEVEL_CARAVAN_UNLOAD", _hx_o({__fields__={id=true},id=id}));
end
__shared_base_event_EventHelper.levelUnitMove = function(world,id,roadId) 
  world:eventEmit("LEVEL_UNIT_MOVE", _hx_o({__fields__={id=true,roadId=true},id=id,roadId=roadId}));
end
__shared_base_event_EventHelper.levelUnitAttack = function(world,attackerId,defenderId) 
  world:eventEmit("LEVEL_UNIT_ATTACK", _hx_o({__fields__={attackerId=true,defenderId=true},attackerId=attackerId,defenderId=defenderId}));
end
__shared_base_event_EventHelper.levelUnitDied = function(world,id) 
  world:eventEmit("LEVEL_UNIT_DIED", _hx_o({__fields__={id=true},id=id}));
end
__shared_base_event_EventHelper.levelUnitDiedMoveToNextCastle = function(world,id) 
  world:eventEmit("LEVEL_UNIT_DIED_MOVE_TO_NEXT_CASTLE", _hx_o({__fields__={id=true},id=id}));
end
__shared_base_event_EventHelper.levelLost = function(world) 
  world:eventEmit("LEVEL_PLAYER_LOST");
end
__shared_base_event_EventHelper.levelWin = function(world) 
  world:eventEmit("LEVEL_WIN");
end
__shared_base_event_EventHelper.levelTurnStart = function(world) 
  world:eventEmit("LEVEL_TURN_START");
end
__shared_base_event_EventHelper.levelTurnEnd = function(world) 
  world:eventEmit("LEVEL_TURN_END");
end
__shared_base_event_EventHelper.levelRestart = function(world) 
  world:eventEmit("LEVEL_RESTART");
end
__shared_base_event_EventHelper.levelCastleEnemyDestroy = function(world) 
  world:eventEmit("LEVEL_CASTLE_ENEMY_DESTROY");
end
__shared_base_event_EventHelper.levelCastSpellStart = function(world,type) 
  world:eventEmit("LEVEL_CAST_SPELL_START", _hx_o({__fields__={type=true},type=type}));
end
__shared_base_event_EventHelper.levelCastSpellEnd = function(world,type) 
  world:eventEmit("LEVEL_CAST_SPELL_END", _hx_o({__fields__={type=true},type=type}));
end
__shared_base_event_EventHelper.levelSpellIceEnd = function(world) 
  world:eventEmit("LEVEL_SPELL_ICE_END");
end

__shared_base_model_WorldBaseModel.new = function(storage) 
  local self = _hx_new(__shared_base_model_WorldBaseModel.prototype)
  __shared_base_model_WorldBaseModel.super(self,storage)
  return self
end
__shared_base_model_WorldBaseModel.super = function(self,storage) 
  self.storage = storage;
  self.contexts = __haxe_ds_StringMap.new();
  self.events = Array.new();
  self.intent = "main.fallback";
end
__shared_base_model_WorldBaseModel.__name__ = true
__shared_base_model_WorldBaseModel.prototype = _hx_a();
__shared_base_model_WorldBaseModel.prototype.storage= nil;
__shared_base_model_WorldBaseModel.prototype.contexts= nil;
__shared_base_model_WorldBaseModel.prototype.events= nil;
__shared_base_model_WorldBaseModel.prototype.intent= nil;
__shared_base_model_WorldBaseModel.prototype.restore = function(self) 
end
__shared_base_model_WorldBaseModel.prototype.contextExist = function(self,ctx) 
  if (self.contexts:get(ctx) == nil) then 
    do return false end;
  else
    do return true end;
  end;
end
__shared_base_model_WorldBaseModel.prototype.contextGetAll = function(self) 
  local result = Array.new();
  local context = self.contexts:iterator();
  while (context:hasNext()) do 
    result:push(context:next());
  end;
  do return result end
end
__shared_base_model_WorldBaseModel.prototype.contextInit = function(self,map) 
  self.contexts = map;
end
__shared_base_model_WorldBaseModel.prototype.contextChange = function(self,name,lifespan,parameters) 
  if (lifespan == nil) then 
    lifespan = 99999;
  end;
  self.contexts:set(name, __shared_base_struct_ContextStruct.new(name, lifespan, parameters));
end
__shared_base_model_WorldBaseModel.prototype.contextDelete = function(self,name) 
  self:contextChange(name, 0, nil);
end
__shared_base_model_WorldBaseModel.prototype.storageInit = function(self,storage) 
  self.storage = storage;
end
__shared_base_model_WorldBaseModel.prototype.storageGet = function(self) 
  do return self.storage end
end
__shared_base_model_WorldBaseModel.prototype.eventClear = function(self) 
  self.events = Array.new();
end
__shared_base_model_WorldBaseModel.prototype.eventEmit = function(self,name,data) 
  self.events:push(_hx_o({__fields__={name=true,data=true},name=name,data=data}));
end
__shared_base_model_WorldBaseModel.prototype.eventGetAll = function(self) 
  do return self.events end
end

__shared_base_model_WorldBaseModel.prototype.__class__ =  __shared_base_model_WorldBaseModel

__shared_base_struct_ContextStruct.new = function(name,lifespan,parameters) 
  local self = _hx_new(__shared_base_struct_ContextStruct.prototype)
  __shared_base_struct_ContextStruct.super(self,name,lifespan,parameters)
  return self
end
__shared_base_struct_ContextStruct.super = function(self,name,lifespan,parameters) 
  self.name = name;
  self.lifespan = lifespan;
  self.parameters = parameters;
end
__shared_base_struct_ContextStruct.__name__ = true
__shared_base_struct_ContextStruct.prototype = _hx_a();
__shared_base_struct_ContextStruct.prototype.name= nil;
__shared_base_struct_ContextStruct.prototype.lifespan= nil;
__shared_base_struct_ContextStruct.prototype.parameters= nil;

__shared_base_struct_ContextStruct.prototype.__class__ =  __shared_base_struct_ContextStruct

__shared_base_utils_GameUtils.new = {}
__shared_base_utils_GameUtils.__name__ = true
__shared_base_utils_GameUtils.getSpeechBuilder = function(world) 
  if (__shared_project_configs_GameConfig.PLATFORM == "sber") then 
    do return __shared_base_utils_SpeechBuilderSber.new() end;
  else
    do return __shared_base_utils_SpeechBuilder.new() end;
  end;
end

__shared_base_utils_MathUtils.new = {}
__shared_base_utils_MathUtils.__name__ = true
__shared_base_utils_MathUtils.clamp = function(value,min,max) 
  do return Math.min(Math.max(min, value), max) end;
end

__shared_base_utils_SpeechBuilder.new = function() 
  local self = _hx_new(__shared_base_utils_SpeechBuilder.prototype)
  __shared_base_utils_SpeechBuilder.super(self)
  return self
end
__shared_base_utils_SpeechBuilder.super = function(self) 
  self.builed = false;
  self.str = "";
  self.str = "<speak>";
  self.builed = false;
end
__shared_base_utils_SpeechBuilder.__name__ = true
__shared_base_utils_SpeechBuilder.prototype = _hx_a();
__shared_base_utils_SpeechBuilder.prototype.str= nil;
__shared_base_utils_SpeechBuilder.prototype.builed= nil;
__shared_base_utils_SpeechBuilder.prototype.build = function(self) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.builed = true;
  self.str = Std.string(self.str) .. Std.string("</speak>");
  do return self.str end
end
__shared_base_utils_SpeechBuilder.prototype.buildText = function(self) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.builed = true;
  local _this = self.str;
  local endIndex = nil;
  endIndex = __lua_lib_luautf8_Utf8.len(_this);
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (endIndex < 7) then 
    do return __lua_lib_luautf8_Utf8.sub(_this, endIndex + 1, 7) end;
  else
    do return __lua_lib_luautf8_Utf8.sub(_this, 8, endIndex) end;
  end;
end
__shared_base_utils_SpeechBuilder.prototype.text = function(self,text) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.str = Std.string(Std.string(self.str) .. Std.string(" ")) .. Std.string(text);
  do return self end
end
__shared_base_utils_SpeechBuilder.prototype.breakTime = function(self,time) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.str = Std.string(Std.string(Std.string(self.str) .. Std.string("<break time=\"")) .. Std.string(time)) .. Std.string("\"/>");
  do return self end
end
__shared_base_utils_SpeechBuilder.prototype.isEmpty = function(self) 
  if (not ((self.str == "<speak>") or (self.str == "<speak></speak>"))) then 
    do return self.str == "" end;
  else
    do return true end;
  end;
end

__shared_base_utils_SpeechBuilder.prototype.__class__ =  __shared_base_utils_SpeechBuilder

__shared_base_utils_SpeechBuilderSber.new = function() 
  local self = _hx_new(__shared_base_utils_SpeechBuilderSber.prototype)
  __shared_base_utils_SpeechBuilderSber.super(self)
  return self
end
__shared_base_utils_SpeechBuilderSber.super = function(self) 
  __shared_base_utils_SpeechBuilder.super(self);
  self.str = "";
  self.builed = false;
end
__shared_base_utils_SpeechBuilderSber.__name__ = true
__shared_base_utils_SpeechBuilderSber.prototype = _hx_a();
__shared_base_utils_SpeechBuilderSber.prototype.build = function(self) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.builed = true;
  self.str = Std.string(self.str) .. Std.string("");
  do return self.str end
end
__shared_base_utils_SpeechBuilderSber.prototype.breakTime = function(self,time) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  local timeInt = _G.math.ceil(time * 1000);
  if (timeInt > 0) then 
    self.str = Std.string(Std.string(Std.string(self.str) .. Std.string("<break time=\"")) .. Std.string(timeInt)) .. Std.string("ms\"/>");
  end;
  do return self end
end
__shared_base_utils_SpeechBuilderSber.prototype.buildText = function(self) 
  if (not (not self.builed)) then 
    _G.error("already build",0);
  end;
  self.builed = true;
  do return self.str end
end

__shared_base_utils_SpeechBuilderSber.prototype.__class__ =  __shared_base_utils_SpeechBuilderSber
__shared_base_utils_SpeechBuilderSber.__super__ = __shared_base_utils_SpeechBuilder
setmetatable(__shared_base_utils_SpeechBuilderSber.prototype,{__index=__shared_base_utils_SpeechBuilder.prototype})

__shared_project_analytics_AnalyticsHelper.new = {}
__shared_project_analytics_AnalyticsHelper.__name__ = true
__shared_project_analytics_AnalyticsHelper.sendProcessIntentEvent = function(world,intent,data) 
  local dataString;
  if (data ~= nil) then 
    dataString = Std.string(data);
  else
    dataString = "";
  end;
  world:trackAnalyticEvent(__shared_project_analytics_events_ProcessIntentEvent.new(world:storageGet().stat, Std.string(intent), dataString));
end
__shared_project_analytics_AnalyticsHelper.sendGameLaunchEvent = function(world) 
  world:trackAnalyticEvent(__shared_project_analytics_events_GameLaunchEvent.new(world:storageGet().stat, "Not implemented.", "Not implemented."));
end
__shared_project_analytics_AnalyticsHelper.sendTutorialPartChangedEvent = function(world,name,prev,currentPart,prevPartIdx) 
  local prevSafe;
  if (prev ~= nil) then 
    prevSafe = prev;
  else
    prevSafe = "";
  end;
  if (currentPart ~= nil) then 
    world:trackAnalyticEvent(__shared_project_analytics_events_TutorialPartChangedEvent.new(world:storageGet().stat, prevSafe, currentPart, name));
  else
    _G.error("no_current_tutorial_part_data",0);
  end;
  if (__shared_project_analytics_AnalyticsHelper.tutorNameToStep.h[name] ~= nil) then 
    if ((prevPartIdx ~= -1) or (name == "Level1Battle")) then 
      __shared_project_analytics_AnalyticsHelper.sendTutorialEvent(world, __shared_project_analytics_AnalyticsHelper.getStep(name, prevPartIdx));
    end;
  end;
end
__shared_project_analytics_AnalyticsHelper.sendTutorialFinishedEvent = function(world,name) 
  world:trackAnalyticEvent(__shared_project_analytics_events_TutorialFinishEvent.new(world:storageGet().stat, name));
  if (__shared_project_analytics_AnalyticsHelper.tutorNameToStep.h[name] ~= nil) then 
    __shared_project_analytics_AnalyticsHelper.sendTutorialEvent(world, __shared_project_analytics_AnalyticsHelper.getStep(name, 99));
  end;
end
__shared_project_analytics_AnalyticsHelper.sendTutorialStartedEvent = function(world,name) 
  world:trackAnalyticEvent(__shared_project_analytics_events_TutorialStartEvent.new(world:storageGet().stat, name));
end
__shared_project_analytics_AnalyticsHelper.sendGameSessionEvent = function(world) 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  world:trackAnalyticEvent(__shared_project_analytics_events_predefined_GameSessionEvent.new(_G.math.floor((d:getTime() / 1000) + 0.5), 0, world:storageGet().stat.userLevel));
end
__shared_project_analytics_AnalyticsHelper.sendPlayerInfoEvent = function(world) 
  local storage = world:storageGet();
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  world:trackAnalyticEvent(__shared_project_analytics_events_predefined_PlayerInfoEvent.new(_G.math.floor((d:getTime() / 1000) + 0.5), storage.stat.userLevel));
end
__shared_project_analytics_AnalyticsHelper.sendProcessErrorEvent = function(world,error,stack) 
  world:trackAnalyticEvent(__shared_project_analytics_events_ProcessErrorEvent.new(world:storageGet().stat, error, stack));
end
__shared_project_analytics_AnalyticsHelper.sendOutputResponseEvent = function(world,data) 
  world:trackAnalyticEvent(__shared_project_analytics_events_OutputResponseEvent.new(world:storageGet().stat, data));
end
__shared_project_analytics_AnalyticsHelper.sendInputRequestRawEvent = function(world,data) 
  if (__shared_project_analytics_AnalyticsHelper.intentExclusions:indexOf(world.intent) == -1) then 
    world:trackAnalyticEvent(__shared_project_analytics_events_InputRequestRawEvent.new(world:storageGet().stat, data));
  end;
end
__shared_project_analytics_AnalyticsHelper.sendOutputSpeechEvent = function(world,data) 
  world:trackAnalyticEvent(__shared_project_analytics_events_OutputSpeechEvent.new(world:storageGet().stat, data));
end
__shared_project_analytics_AnalyticsHelper.sendTutorialEvent = function(world,step) 
  local t = _G.os.time() * 1000;
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  world:trackAnalyticEvent(__shared_project_analytics_events_predefined_TutorialEvent.new(step, _G.math.floor((d:getTime() / 1000) + 0.5), world:storageGet().stat.userLevel));
end
__shared_project_analytics_AnalyticsHelper.getStep = function(tutorName,stepNum) 
  if ((tutorName == "Level1Battle") and (stepNum == -1)) then 
    do return -1 end;
  end;
  if ((tutorName == "Level5Battle") and (stepNum == 99)) then 
    do return -2 end;
  end;
  local ret = __shared_project_analytics_AnalyticsHelper.tutorNameToStep.h[tutorName];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local stepBase = ret;
  if (stepBase == nil) then 
    _G.error(Std.string("no_steps_defined_for_tutor_") .. Std.string(tutorName),0);
  end;
  do return stepBase + stepNum end;
end

__shared_project_analytics_DtdAnalytics.new = function() 
  local self = _hx_new(__shared_project_analytics_DtdAnalytics.prototype)
  __shared_project_analytics_DtdAnalytics.super(self)
  return self
end
__shared_project_analytics_DtdAnalytics.super = function(self) 
  self.events = Array.new();
end
__shared_project_analytics_DtdAnalytics.__name__ = true
__shared_project_analytics_DtdAnalytics.prototype = _hx_a();
__shared_project_analytics_DtdAnalytics.prototype.events= nil;
__shared_project_analytics_DtdAnalytics.prototype.trackEvent = function(self,event) 
  self.events:push(event);
end
__shared_project_analytics_DtdAnalytics.prototype.getEvents = function(self) 
  do return self.events end
end

__shared_project_analytics_DtdAnalytics.prototype.__class__ =  __shared_project_analytics_DtdAnalytics

__shared_project_analytics_events_common_DtdAnalyticsBaseEvent.new = {}
__shared_project_analytics_events_common_DtdAnalyticsBaseEvent.__name__ = true

__shared_project_analytics_events_common_DtdAnalyticsEvent.new = function(struct) 
  local self = _hx_new(__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype)
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct)
  return self
end
__shared_project_analytics_events_common_DtdAnalyticsEvent.super = function(self,struct) 
  self.eventName = "";
  self.session = _hx_funcToField(struct.startGameCounter);
  self.intentIdx = _hx_funcToField(struct.intentIdx);
  self.userLevel = _hx_funcToField(struct.userLevel);
end
__shared_project_analytics_events_common_DtdAnalyticsEvent.__name__ = true
__shared_project_analytics_events_common_DtdAnalyticsEvent.__interfaces__ = {__shared_project_analytics_events_common_DtdAnalyticsBaseEvent}
__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype = _hx_a();
__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype.session= nil;
__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype.intentIdx= nil;
__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype.userLevel= nil;
__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype.eventName= nil;

__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype.__class__ =  __shared_project_analytics_events_common_DtdAnalyticsEvent

__shared_project_analytics_events_GameLaunchEvent.new = function(struct,source,userCountry) 
  local self = _hx_new(__shared_project_analytics_events_GameLaunchEvent.prototype)
  __shared_project_analytics_events_GameLaunchEvent.super(self,struct,source,userCountry)
  return self
end
__shared_project_analytics_events_GameLaunchEvent.super = function(self,struct,source,userCountry) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.platform = _hx_funcToField(struct.platform);
  self.device = _hx_funcToField(struct.device);
  self.dayAfterInstall = _hx_funcToField(struct.dayAfterInstall);
  self.gameConfigVersion = _hx_funcToField(struct.gameConfigVersion);
  self.gameLocaleVersion = _hx_funcToField(struct.gameLocaleVersion);
  self.gameSharedVersion = _hx_funcToField(struct.gameSharedVersion);
  self.gameBackendVersion = _hx_funcToField(struct.gameBackendVersion);
  self.source = source;
  self.userCountry = userCountry;
  self.eventName = "gameLaunch";
end
__shared_project_analytics_events_GameLaunchEvent.__name__ = true
__shared_project_analytics_events_GameLaunchEvent.prototype = _hx_a();
__shared_project_analytics_events_GameLaunchEvent.prototype.platform= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.device= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.dayAfterInstall= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.gameConfigVersion= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.gameLocaleVersion= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.gameSharedVersion= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.gameBackendVersion= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.source= nil;
__shared_project_analytics_events_GameLaunchEvent.prototype.userCountry= nil;

__shared_project_analytics_events_GameLaunchEvent.prototype.__class__ =  __shared_project_analytics_events_GameLaunchEvent
__shared_project_analytics_events_GameLaunchEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_GameLaunchEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_InputRequestRawEvent.new = function(struct,data) 
  local self = _hx_new(__shared_project_analytics_events_InputRequestRawEvent.prototype)
  __shared_project_analytics_events_InputRequestRawEvent.super(self,struct,data)
  return self
end
__shared_project_analytics_events_InputRequestRawEvent.super = function(self,struct,data) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.data = data;
  self.eventName = "inputRequestRawEvent";
end
__shared_project_analytics_events_InputRequestRawEvent.__name__ = true
__shared_project_analytics_events_InputRequestRawEvent.prototype = _hx_a();
__shared_project_analytics_events_InputRequestRawEvent.prototype.data= nil;

__shared_project_analytics_events_InputRequestRawEvent.prototype.__class__ =  __shared_project_analytics_events_InputRequestRawEvent
__shared_project_analytics_events_InputRequestRawEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_InputRequestRawEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_OutputResponseEvent.new = function(struct,data) 
  local self = _hx_new(__shared_project_analytics_events_OutputResponseEvent.prototype)
  __shared_project_analytics_events_OutputResponseEvent.super(self,struct,data)
  return self
end
__shared_project_analytics_events_OutputResponseEvent.super = function(self,struct,data) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.data = data;
  self.eventName = "outputResponse";
end
__shared_project_analytics_events_OutputResponseEvent.__name__ = true
__shared_project_analytics_events_OutputResponseEvent.prototype = _hx_a();
__shared_project_analytics_events_OutputResponseEvent.prototype.data= nil;

__shared_project_analytics_events_OutputResponseEvent.prototype.__class__ =  __shared_project_analytics_events_OutputResponseEvent
__shared_project_analytics_events_OutputResponseEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_OutputResponseEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_OutputSpeechEvent.new = function(struct,data) 
  local self = _hx_new(__shared_project_analytics_events_OutputSpeechEvent.prototype)
  __shared_project_analytics_events_OutputSpeechEvent.super(self,struct,data)
  return self
end
__shared_project_analytics_events_OutputSpeechEvent.super = function(self,struct,data) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.data = data;
  self.eventName = "outputSpeech";
end
__shared_project_analytics_events_OutputSpeechEvent.__name__ = true
__shared_project_analytics_events_OutputSpeechEvent.prototype = _hx_a();
__shared_project_analytics_events_OutputSpeechEvent.prototype.data= nil;

__shared_project_analytics_events_OutputSpeechEvent.prototype.__class__ =  __shared_project_analytics_events_OutputSpeechEvent
__shared_project_analytics_events_OutputSpeechEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_OutputSpeechEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_ProcessErrorEvent.new = function(struct,error,stack) 
  local self = _hx_new(__shared_project_analytics_events_ProcessErrorEvent.prototype)
  __shared_project_analytics_events_ProcessErrorEvent.super(self,struct,error,stack)
  return self
end
__shared_project_analytics_events_ProcessErrorEvent.super = function(self,struct,error,stack) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.error = error;
  self.stack = stack;
end
__shared_project_analytics_events_ProcessErrorEvent.__name__ = true
__shared_project_analytics_events_ProcessErrorEvent.prototype = _hx_a();
__shared_project_analytics_events_ProcessErrorEvent.prototype.error= nil;
__shared_project_analytics_events_ProcessErrorEvent.prototype.stack= nil;

__shared_project_analytics_events_ProcessErrorEvent.prototype.__class__ =  __shared_project_analytics_events_ProcessErrorEvent
__shared_project_analytics_events_ProcessErrorEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_ProcessErrorEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_ProcessIntentEvent.new = function(struct,name,data) 
  local self = _hx_new(__shared_project_analytics_events_ProcessIntentEvent.prototype)
  __shared_project_analytics_events_ProcessIntentEvent.super(self,struct,name,data)
  return self
end
__shared_project_analytics_events_ProcessIntentEvent.super = function(self,struct,name,data) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.name = name;
  self.data = data;
  self.eventName = "processIntent";
end
__shared_project_analytics_events_ProcessIntentEvent.__name__ = true
__shared_project_analytics_events_ProcessIntentEvent.prototype = _hx_a();
__shared_project_analytics_events_ProcessIntentEvent.prototype.name= nil;
__shared_project_analytics_events_ProcessIntentEvent.prototype.data= nil;

__shared_project_analytics_events_ProcessIntentEvent.prototype.__class__ =  __shared_project_analytics_events_ProcessIntentEvent
__shared_project_analytics_events_ProcessIntentEvent.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_ProcessIntentEvent.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_common_TutorialCommon.new = function(struct,name) 
  local self = _hx_new(__shared_project_analytics_events_common_TutorialCommon.prototype)
  __shared_project_analytics_events_common_TutorialCommon.super(self,struct,name)
  return self
end
__shared_project_analytics_events_common_TutorialCommon.super = function(self,struct,name) 
  __shared_project_analytics_events_common_DtdAnalyticsEvent.super(self,struct);
  self.name = name;
end
__shared_project_analytics_events_common_TutorialCommon.__name__ = true
__shared_project_analytics_events_common_TutorialCommon.prototype = _hx_a();
__shared_project_analytics_events_common_TutorialCommon.prototype.name= nil;

__shared_project_analytics_events_common_TutorialCommon.prototype.__class__ =  __shared_project_analytics_events_common_TutorialCommon
__shared_project_analytics_events_common_TutorialCommon.__super__ = __shared_project_analytics_events_common_DtdAnalyticsEvent
setmetatable(__shared_project_analytics_events_common_TutorialCommon.prototype,{__index=__shared_project_analytics_events_common_DtdAnalyticsEvent.prototype})

__shared_project_analytics_events_TutorialFinishEvent.new = function(struct,name) 
  local self = _hx_new(__shared_project_analytics_events_TutorialFinishEvent.prototype)
  __shared_project_analytics_events_TutorialFinishEvent.super(self,struct,name)
  return self
end
__shared_project_analytics_events_TutorialFinishEvent.super = function(self,struct,name) 
  __shared_project_analytics_events_common_TutorialCommon.super(self,struct,name);
  self.eventName = "tutorialFinish";
end
__shared_project_analytics_events_TutorialFinishEvent.__name__ = true
__shared_project_analytics_events_TutorialFinishEvent.prototype = _hx_a();

__shared_project_analytics_events_TutorialFinishEvent.prototype.__class__ =  __shared_project_analytics_events_TutorialFinishEvent
__shared_project_analytics_events_TutorialFinishEvent.__super__ = __shared_project_analytics_events_common_TutorialCommon
setmetatable(__shared_project_analytics_events_TutorialFinishEvent.prototype,{__index=__shared_project_analytics_events_common_TutorialCommon.prototype})

__shared_project_analytics_events_TutorialPartChangedEvent.new = function(struct,prev,New,name) 
  local self = _hx_new(__shared_project_analytics_events_TutorialPartChangedEvent.prototype)
  __shared_project_analytics_events_TutorialPartChangedEvent.super(self,struct,prev,New,name)
  return self
end
__shared_project_analytics_events_TutorialPartChangedEvent.super = function(self,struct,prev,New,name) 
  __shared_project_analytics_events_common_TutorialCommon.super(self,struct,name);
  self.prev = Std.string(Std.string(name) .. Std.string("_")) .. Std.string(prev);
  self.New = Std.string(Std.string(name) .. Std.string("_")) .. Std.string(New);
  self.eventName = "tutorialPartChanged";
end
__shared_project_analytics_events_TutorialPartChangedEvent.__name__ = true
__shared_project_analytics_events_TutorialPartChangedEvent.prototype = _hx_a();
__shared_project_analytics_events_TutorialPartChangedEvent.prototype.prev= nil;
__shared_project_analytics_events_TutorialPartChangedEvent.prototype.New= nil;

__shared_project_analytics_events_TutorialPartChangedEvent.prototype.__class__ =  __shared_project_analytics_events_TutorialPartChangedEvent
__shared_project_analytics_events_TutorialPartChangedEvent.__super__ = __shared_project_analytics_events_common_TutorialCommon
setmetatable(__shared_project_analytics_events_TutorialPartChangedEvent.prototype,{__index=__shared_project_analytics_events_common_TutorialCommon.prototype})

__shared_project_analytics_events_TutorialStartEvent.new = function(struct,name) 
  local self = _hx_new(__shared_project_analytics_events_TutorialStartEvent.prototype)
  __shared_project_analytics_events_TutorialStartEvent.super(self,struct,name)
  return self
end
__shared_project_analytics_events_TutorialStartEvent.super = function(self,struct,name) 
  __shared_project_analytics_events_common_TutorialCommon.super(self,struct,name);
  self.eventName = "tutorialStart";
end
__shared_project_analytics_events_TutorialStartEvent.__name__ = true
__shared_project_analytics_events_TutorialStartEvent.prototype = _hx_a();

__shared_project_analytics_events_TutorialStartEvent.prototype.__class__ =  __shared_project_analytics_events_TutorialStartEvent
__shared_project_analytics_events_TutorialStartEvent.__super__ = __shared_project_analytics_events_common_TutorialCommon
setmetatable(__shared_project_analytics_events_TutorialStartEvent.prototype,{__index=__shared_project_analytics_events_common_TutorialCommon.prototype})

__shared_project_analytics_events_predefined_GameSessionEvent.new = function(timestamp,length,level) 
  local self = _hx_new(__shared_project_analytics_events_predefined_GameSessionEvent.prototype)
  __shared_project_analytics_events_predefined_GameSessionEvent.super(self,timestamp,length,level)
  return self
end
__shared_project_analytics_events_predefined_GameSessionEvent.super = function(self,timestamp,length,level) 
  self.timestamp = timestamp;
  self.length = length;
  self.level = level;
  self.eventName = "gs";
end
__shared_project_analytics_events_predefined_GameSessionEvent.__name__ = true
__shared_project_analytics_events_predefined_GameSessionEvent.__interfaces__ = {__shared_project_analytics_events_common_DtdAnalyticsBaseEvent}
__shared_project_analytics_events_predefined_GameSessionEvent.prototype = _hx_a();
__shared_project_analytics_events_predefined_GameSessionEvent.prototype.timestamp= nil;
__shared_project_analytics_events_predefined_GameSessionEvent.prototype.length= nil;
__shared_project_analytics_events_predefined_GameSessionEvent.prototype.level= nil;
__shared_project_analytics_events_predefined_GameSessionEvent.prototype.eventName= nil;

__shared_project_analytics_events_predefined_GameSessionEvent.prototype.__class__ =  __shared_project_analytics_events_predefined_GameSessionEvent

__shared_project_analytics_events_predefined_PlayerInfoEvent.new = function(timestamp,userLevel) 
  local self = _hx_new(__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype)
  __shared_project_analytics_events_predefined_PlayerInfoEvent.super(self,timestamp,userLevel)
  return self
end
__shared_project_analytics_events_predefined_PlayerInfoEvent.super = function(self,timestamp,userLevel) 
  self.timestamp = timestamp;
  self.data = __haxe_ds_StringMap.new();
  local v = userLevel;
  local _this = self.data;
  if (v == nil) then 
    _this.h.userLevel = __haxe_ds_StringMap.tnull;
  else
    _this.h.userLevel = v;
  end;
  self.eventName = "pl";
end
__shared_project_analytics_events_predefined_PlayerInfoEvent.__name__ = true
__shared_project_analytics_events_predefined_PlayerInfoEvent.__interfaces__ = {__shared_project_analytics_events_common_DtdAnalyticsBaseEvent}
__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype = _hx_a();
__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype.timestamp= nil;
__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype.data= nil;
__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype.eventName= nil;

__shared_project_analytics_events_predefined_PlayerInfoEvent.prototype.__class__ =  __shared_project_analytics_events_predefined_PlayerInfoEvent

__shared_project_analytics_events_predefined_TutorialEvent.new = function(step,timestamp,level) 
  local self = _hx_new(__shared_project_analytics_events_predefined_TutorialEvent.prototype)
  __shared_project_analytics_events_predefined_TutorialEvent.super(self,step,timestamp,level)
  return self
end
__shared_project_analytics_events_predefined_TutorialEvent.super = function(self,step,timestamp,level) 
  self.step = step;
  self.timestamp = timestamp;
  self.level = level;
  self.eventName = "tr";
end
__shared_project_analytics_events_predefined_TutorialEvent.__name__ = true
__shared_project_analytics_events_predefined_TutorialEvent.__interfaces__ = {__shared_project_analytics_events_common_DtdAnalyticsBaseEvent}
__shared_project_analytics_events_predefined_TutorialEvent.prototype = _hx_a();
__shared_project_analytics_events_predefined_TutorialEvent.prototype.step= nil;
__shared_project_analytics_events_predefined_TutorialEvent.prototype.timestamp= nil;
__shared_project_analytics_events_predefined_TutorialEvent.prototype.level= nil;
__shared_project_analytics_events_predefined_TutorialEvent.prototype.eventName= nil;

__shared_project_analytics_events_predefined_TutorialEvent.prototype.__class__ =  __shared_project_analytics_events_predefined_TutorialEvent

__shared_project_configs_GameConfig.new = {}
_hx_exports["shared"]["project"]["configs"]["GameConfig"] = __shared_project_configs_GameConfig
__shared_project_configs_GameConfig.__name__ = true

__shared_project_configs_UnitConfig.new = {}
__shared_project_configs_UnitConfig.__name__ = true
__shared_project_configs_UnitConfig.unitTypeGetById = function(id) 
  if (id == "ARCHER") then 
    do return "ARCHER" end;
  else
    if (id == "KNIGHT") then 
      do return "KNIGHT" end;
    else
      if (id == "SHIELD") then 
        do return "SHIELD" end;
      else
        if (id == "SPEARMAN") then 
          do return "SPEARMAN" end;
        else
          if (id == "MAGE") then 
            do return "MAGE" end;
          else
            if (id == "CASTLE") then 
              do return "CASTLE" end;
            end;
          end;
        end;
      end;
    end;
  end;
  do return nil end;
end

__shared_project_configs_MageConfig.new = {}
__shared_project_configs_MageConfig.__name__ = true
__shared_project_configs_MageConfig.mageTypeGetById = function(id) 
  if (id == "FIREBALL") then 
    do return "FIREBALL" end;
  else
    if (id == "ICE") then 
      do return "ICE" end;
    else
      if (id == "CARAVAN") then 
        do return "CARAVAN" end;
      else
        if (id == "MANA") then 
          do return "MANA" end;
        end;
      end;
    end;
  end;
  do return nil end;
end

__shared_project_enums_Intents.new = {}
_hx_exports["shared"]["project"]["enums"]["Intents"] = __shared_project_enums_Intents
__shared_project_enums_Intents.__name__ = true
__shared_project_enums_Intents.init = function() 
  __shared_project_enums_Intents.intentContexts = __haxe_ds_StringMap.new();
  __shared_project_enums_Intents.intentContexts:set("main.welcome", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("main.fallback", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("main.error", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("main.keep_working", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("main.help", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("webapp.load_done", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("actions.iap.buy", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("level.cast", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("level.spawn.unit", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("level.turn.skip", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("lose.modal.restart", _hx_tab_array({[0]="lose_modal"}, 1));
  __shared_project_enums_Intents.intentContexts:set("win.modal.restart", _hx_tab_array({[0]="win_modal"}, 1));
  __shared_project_enums_Intents.intentContexts:set("debug.toggle", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.enable", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.disable", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.mana.add", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.money.add", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.kill_all_enemies", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("cheats.restore_hp", _hx_tab_array({[0]="dev"}, 1));
  __shared_project_enums_Intents.intentContexts:set("tutorial.no", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("tutorial.yes", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("level.spawn.caravan", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.unit.archer", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.unit.knight", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.unit.mage", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.unit.spearman", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.unit.tank", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.spell.fireball", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.spell.ice", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.spell.upgrade_mana", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.intentContexts:set("simple.spell.upgrade_caravan", _hx_tab_array({}, 0));
  __shared_project_enums_Intents.ignoreTutorialCheck:set("main.welcome", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("lose.modal.restart", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("win.modal.restart", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("level.spawn.unit", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("level.cast", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("level.turn.skip", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("debug.toggle", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.disable", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.enable", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.mana.add", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.money.add", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.kill_all_enemies", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("cheats.restore_hp", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("webapp.load_done", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("main.fallback", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("main.error", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("main.keep_working", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("actions.iap.buy", true);
  __shared_project_enums_Intents.ignoreTutorialCheck:set("tutorial.yes", true);
end
__shared_project_enums_Intents.isIntent = function(name) 
  do return __shared_project_enums_Intents.intentContexts:exists(name) end;
end
__shared_project_enums_Intents.contextIsModal = function(ctx) 
  do return __shared_project_enums_Intents.modalContexts:exists(ctx) end;
end
__shared_project_enums_Intents.worldHaveModalContext = function(world) 
  local _g = 0;
  local _g1 = world:contextGetAll();
  while (_g < _g1.length) do 
    local ctx = _g1[_g];
    _g = _g + 1;
    if (__shared_project_enums_Intents.contextIsModal(ctx.name)) then 
      do return true end;
    end;
  end;
  do return false end;
end

__shared_project_enums__UnitType_UnitType_Impl_.new = {}
__shared_project_enums__UnitType_UnitType_Impl_.__name__ = true

__shared_project_enums__UnitType_MageType_Impl_.new = {}
__shared_project_enums__UnitType_MageType_Impl_.__name__ = true
__shared_project_enums__UnitType_MageType_Impl_.getByName = function(mageName) 
  local _g = __lua_lib_luautf8_Utf8.lower(mageName);
  if (_g) == "caravan" then 
    do return "CARAVAN" end;
  elseif (_g) == "fireball" then 
    do return "FIREBALL" end;
  elseif (_g) == "ice" then 
    do return "ICE" end;
  elseif (_g) == "mana" then 
    do return "MANA" end;else
  do return nil end; end;
end

__shared_project_intent_processors_IntentSubProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentSubProcessor.prototype)
  __shared_project_intent_processors_IntentSubProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentSubProcessor.super = function(self,world,shared1,i18n) 
  self.world = world;
  self.shared = shared1;
  self.i18n = i18n;
end
__shared_project_intent_processors_IntentSubProcessor.__name__ = true
__shared_project_intent_processors_IntentSubProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentSubProcessor.prototype.baseProcessor= nil;
__shared_project_intent_processors_IntentSubProcessor.prototype.world= nil;
__shared_project_intent_processors_IntentSubProcessor.prototype.i18n= nil;
__shared_project_intent_processors_IntentSubProcessor.prototype.shared= nil;
__shared_project_intent_processors_IntentSubProcessor.prototype.setBaseProcessor = function(self,baseProcessor) 
  self.baseProcessor = baseProcessor;
end
__shared_project_intent_processors_IntentSubProcessor.prototype.ask = function(self,text) 
  self.baseProcessor.speechBuilder:text(text);
end

__shared_project_intent_processors_IntentSubProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentSubProcessor

__shared_project_intent_processors_IntentCheatsProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentCheatsProcessor.prototype)
  __shared_project_intent_processors_IntentCheatsProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentCheatsProcessor.super = function(self,world,shared1,i18n) 
  __shared_project_intent_processors_IntentSubProcessor.super(self,world,shared1,i18n);
end
__shared_project_intent_processors_IntentCheatsProcessor.__name__ = true
__shared_project_intent_processors_IntentCheatsProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentCheatsProcessor.prototype.processIntent = function(self,intent,data) 
  if (intent) == "cheats.disable" then 
    local modelResult = self.world:outputCheatsDisable();
    self:ask(self.i18n:tr("conv/cheats_disabled"));
    do return self.baseProcessor:getResult(modelResult) end;
  elseif (intent) == "cheats.enable" then 
    local modelResult1 = self.world:outputCheatsEnable();
    self:ask(self.i18n:tr("conv/cheats_enabled"));
    do return self.baseProcessor:getResult(modelResult1) end;
  elseif (intent) == "cheats.kill_all_enemies" then 
    self:ask(self.i18n:tr("kill all enemies"));
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "cheats.mana.add" then 
    self:ask(self.i18n:tr("add mana"));
    self.world.levelModel.playerModel:manaChange(100, "Cheats");
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "cheats.money.add" then 
    self:ask(self.i18n:tr("add money"));
    self.world.levelModel.playerModel:moneyChange(100, "Cheats");
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "cheats.restore_hp" then 
    self:ask(self.i18n:tr("restore hp"));
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "debug.toggle" then 
    if (not self.world:isDev()) then 
      _G.error("cheats only work in dev mode",0);
    end;
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;else
  do return nil end; end;
end

__shared_project_intent_processors_IntentCheatsProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentCheatsProcessor
__shared_project_intent_processors_IntentCheatsProcessor.__super__ = __shared_project_intent_processors_IntentSubProcessor
setmetatable(__shared_project_intent_processors_IntentCheatsProcessor.prototype,{__index=__shared_project_intent_processors_IntentSubProcessor.prototype})

__shared_project_intent_processors_IntentLevelProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentLevelProcessor.prototype)
  __shared_project_intent_processors_IntentLevelProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentLevelProcessor.super = function(self,world,shared1,i18n) 
  __shared_project_intent_processors_IntentSubProcessor.super(self,world,shared1,i18n);
end
__shared_project_intent_processors_IntentLevelProcessor.__name__ = true
__shared_project_intent_processors_IntentLevelProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentLevelProcessor.prototype.processIntent = function(self,intent,data) 
  if (intent) == "cheats.mana.add" then 
    do return self:processIntent("level.cast", _hx_o({__fields__={spell=true},spell="MANA"})) end;
  elseif (intent) == "level.cast" then 
    if (data == nil) then 
      _G.error("LEVEL_CAST no data",0);
    end;
    if (data.spell == nil) then 
      _G.error("LEVEL_CAST no spell",0);
    end;
    local spelType = __shared_project_configs_MageConfig.mageTypeGetById(data.spell);
    if (spelType == nil) then 
      _G.error("LEVEL_CAST unknown spell",0);
    end;
    if (__shared_project_configs_MageConfig.scalesByMageType:get(spelType) == nil) then 
      _G.error("bad scales",0);
    end;
    local price = self.world.levelModel.playerModel:mageGetPrice(spelType);
    if (self.world.levelModel.playerModel:canSpendMana(price)) then 
      self.world.levelModel.playerModel:manaChange(-price, "cast");
      self.world.levelModel.playerModel:castSpell(spelType, true);
    else
      self:ask(Std.string("not enought mana.Need ") .. Std.string(price));
    end;
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "level.spawn.caravan" then 
    self:ask("caravan");
    self.world.levelModel.playerModel:spawnCaravan();
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "level.spawn.unit" then 
    if (data == nil) then 
      _G.error("LEVEL_SPAWN_UNIT no data",0);
    end;
    if (data.unit == nil) then 
      _G.error("LEVEL_SPAWN_UNIT no unit",0);
    end;
    local unitType = __shared_project_configs_UnitConfig.unitTypeGetById(data.unit);
    if (unitType == nil) then 
      _G.error("LEVEL_SPAWN_UNIT unknown unit",0);
    end;
    local amount;
    if (data.amount == nil) then 
      amount = 1;
    else
      amount = Std.parseInt(data.amount);
    end;
    if (__shared_project_configs_UnitConfig.scalesByUnitType:get(unitType) == nil) then 
      _G.error("bad scales",0);
    end;
    local price1 = self.world.levelModel.playerModel:unitGetPrice(unitType);
    local cost = amount * price1;
    if (self.world.levelModel.playerModel:canSpendMoney(cost)) then 
      self.world.levelModel.playerModel:moneyChange(-cost, "spawn unit");
      self.world.levelModel.playerModel:unitsSpawnUnit(unitType, amount);
    else
      self:ask(Std.string("not enought money.Need ") .. Std.string(price1));
    end;
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "level.turn.skip" then 
    self:ask("skip");
    __shared_base_event_EventHelper.levelTurnStart(self.world);
    self.world.levelModel:levelNextTurn();
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "simple.spell.fireball" then 
    do return self:processIntent("level.cast", _hx_o({__fields__={spell=true},spell="FIREBALL"})) end;
  elseif (intent) == "simple.spell.ice" then 
    do return self:processIntent("level.cast", _hx_o({__fields__={spell=true},spell="ICE"})) end;
  elseif (intent) == "simple.spell.upgrade_caravan" then 
    do return self:processIntent("level.cast", _hx_o({__fields__={spell=true},spell="CARAVAN"})) end;
  elseif (intent) == "simple.unit.archer" then 
    do return self:processIntent("level.spawn.unit", _hx_o({__fields__={unit=true},unit="ARCHER"})) end;
  elseif (intent) == "simple.unit.knight" then 
    do return self:processIntent("level.spawn.unit", _hx_o({__fields__={unit=true},unit="KNIGHT"})) end;
  elseif (intent) == "simple.unit.mage" then 
    do return self:processIntent("level.spawn.unit", _hx_o({__fields__={unit=true},unit="MAGE"})) end;
  elseif (intent) == "simple.unit.spearman" then 
    do return self:processIntent("level.spawn.unit", _hx_o({__fields__={unit=true},unit="SPEARMAN"})) end;
  elseif (intent) == "simple.unit.tank" then 
    do return self:processIntent("level.spawn.unit", _hx_o({__fields__={unit=true},unit="SHIELD"})) end;else
  do return nil end; end;
end

__shared_project_intent_processors_IntentLevelProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentLevelProcessor
__shared_project_intent_processors_IntentLevelProcessor.__super__ = __shared_project_intent_processors_IntentSubProcessor
setmetatable(__shared_project_intent_processors_IntentLevelProcessor.prototype,{__index=__shared_project_intent_processors_IntentSubProcessor.prototype})

__shared_project_intent_processors_IntentModalProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentModalProcessor.prototype)
  __shared_project_intent_processors_IntentModalProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentModalProcessor.super = function(self,world,shared1,i18n) 
  __shared_project_intent_processors_IntentSubProcessor.super(self,world,shared1,i18n);
end
__shared_project_intent_processors_IntentModalProcessor.__name__ = true
__shared_project_intent_processors_IntentModalProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentModalProcessor.prototype.processIntent = function(self,intent,data) 
  if (intent) == "lose.modal.restart" then 
    self:ask("restart");
    self.world.levelModel:restart();
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent) == "win.modal.restart" then 
    self:ask("restart");
    self.world.levelModel:restart();
    do return self.baseProcessor:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;else
  do return nil end; end;
end

__shared_project_intent_processors_IntentModalProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentModalProcessor
__shared_project_intent_processors_IntentModalProcessor.__super__ = __shared_project_intent_processors_IntentSubProcessor
setmetatable(__shared_project_intent_processors_IntentModalProcessor.prototype,{__index=__shared_project_intent_processors_IntentSubProcessor.prototype})

__shared_project_intent_processors_IntentProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentProcessor.prototype)
  __shared_project_intent_processors_IntentProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentProcessor.super = function(self,world,shared1,i18n) 
  self.world = world;
  self.shared = shared1;
  self.i18n = i18n;
  self.speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(world);
  self.processerCheats = __shared_project_intent_processors_IntentCheatsProcessor.new(self.world, self.shared, self.i18n);
  self.processerModal = __shared_project_intent_processors_IntentModalProcessor.new(self.world, self.shared, self.i18n);
  self.processerTutorial = __shared_project_intent_processors_IntentTutorialProcessor.new(self.world, self.shared, self.i18n);
  self.processerLevel = __shared_project_intent_processors_IntentLevelProcessor.new(self.world, self.shared, self.i18n);
  self.processerCheats:setBaseProcessor(self);
  self.processerModal:setBaseProcessor(self);
  self.processerTutorial:setBaseProcessor(self);
  self.processerLevel:setBaseProcessor(self);
end
__shared_project_intent_processors_IntentProcessor.__name__ = true
__shared_project_intent_processors_IntentProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentProcessor.prototype.world= nil;
__shared_project_intent_processors_IntentProcessor.prototype.i18n= nil;
__shared_project_intent_processors_IntentProcessor.prototype.shared= nil;
__shared_project_intent_processors_IntentProcessor.prototype.processerCheats= nil;
__shared_project_intent_processors_IntentProcessor.prototype.processerModal= nil;
__shared_project_intent_processors_IntentProcessor.prototype.processerTutorial= nil;
__shared_project_intent_processors_IntentProcessor.prototype.processerLevel= nil;
__shared_project_intent_processors_IntentProcessor.prototype.speechBuilder= nil;
__shared_project_intent_processors_IntentProcessor.prototype.ask = function(self,text) 
  self.speechBuilder:text(text);
end
__shared_project_intent_processors_IntentProcessor.prototype.getResult = function(self,modelResult) 
  do return _hx_o({__fields__={modelResult=true,events=true,analyticEvents=true},modelResult=modelResult,events=self.world:eventGetAll(),analyticEvents=self.world.dtdAnalytics:getEvents()}) end
end
__shared_project_intent_processors_IntentProcessor.prototype.processIntent = function(self,intent,data) 
  self.speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(self.world);
  if (__shared_project_analytics_AnalyticsHelper.intentExclusions:indexOf(intent) == -1) then 
    __shared_project_analytics_AnalyticsHelper.sendProcessIntentEvent(self.world, intent, data);
    __shared_project_analytics_AnalyticsHelper.sendPlayerInfoEvent(self.world);
  end;
  __haxe_Log.trace(Std.string("process intent:") .. Std.string(intent), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/intent_processors/IntentProcessor.hx",lineNumber=67,className="shared.project.intent_processors.IntentProcessor",methodName="processIntent"}));
  if (intent == "main.welcome") then 
    self:ask(self.i18n:tr("conv/welcome"));
    __shared_project_analytics_AnalyticsHelper.sendGameLaunchEvent(self.world);
    __shared_project_analytics_AnalyticsHelper.sendGameSessionEvent(self.world);
    do return self:getResult(self.world:outputConversationStart()) end;
  end;
  if (intent ~= "actions.iap.buy") then 
    if (self.world:storageGet().version.version ~= self.world:storageGet().profile.currentVersion) then 
      self:ask(self.i18n:tr("conv/server_was_update"));
      do return self:getResult(_hx_o({__fields__={code=true},code="EXIT"})) end;
    end;
    if (self.world:storageGet().profile.conversationIdCurrent ~= self.world:storageGet().profile.conversationIdAtStart) then 
      self:ask(self.i18n:tr("conv/play_multiple_devices"));
      do return self:getResult(_hx_o({__fields__={code=true},code="EXIT"})) end;
    end;
  end;
  local result = self.processerCheats:processIntent(intent, data);
  if (result ~= nil) then 
    do return result end;
  end;
  result = self.processerModal:processIntent(intent, data);
  if (result ~= nil) then 
    do return result end;
  end;
  result = self.processerTutorial:processIntent(intent, data);
  if (result ~= nil) then 
    do return result end;
  end;
  result = self.processerLevel:processIntent(intent, data);
  if (result ~= nil) then 
    do return result end;
  end;
  local intent1 = intent;
  if (intent1) == "actions.iap.buy" then 
    if (data == nil) then 
      _G.error("no data",0);
    end;
    if (data.iapKey == nil) then 
      _G.error("no iap key",0);
    end;
    __haxe_Log.trace(Std.string("iap buy:") .. Std.string(data.iapKey), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/intent_processors/IntentProcessor.hx",lineNumber=147,className="shared.project.intent_processors.IntentProcessor",methodName="processIntent"}));
    do return self:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent1) == "main.fallback" then 
    self:ask(self.i18n:tr(Std.string("conv/fallback_") .. Std.string(_G.math.ceil(_G.math.random() * 4))));
    do return self:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent1) == "main.help" then 
    if (data.question ~= nil) then 
      local localizationInput = Std.string("conv/") .. Std.string(Std.string(data.question));
      local argMap = __shared_project_utils_TranslationUtils.getSpellCostMap(data.question, self.world);
      local localized = self.i18n:tr(localizationInput, argMap);
      if (localized == localizationInput) then 
        do return self:processIntent("main.fallback") end;
      else
        self:ask(localized);
      end;
    else
      do return self:processIntent("main.fallback") end;
    end;
    do return self:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent1) == "main.keep_working" then 
    do return self:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;
  elseif (intent1) == "webapp.load_done" then 
    self.world:onGameLoaded();
    do return self:getResult(_hx_o({__fields__={code=true},code="SUCCESS"})) end;else
  _G.error(Std.string("UnknownIntent:") .. Std.string(intent),0); end;
end

__shared_project_intent_processors_IntentProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentProcessor

__shared_project_intent_processors_IntentTutorialProcessor.new = function(world,shared1,i18n) 
  local self = _hx_new(__shared_project_intent_processors_IntentTutorialProcessor.prototype)
  __shared_project_intent_processors_IntentTutorialProcessor.super(self,world,shared1,i18n)
  return self
end
__shared_project_intent_processors_IntentTutorialProcessor.super = function(self,world,shared1,i18n) 
  __shared_project_intent_processors_IntentSubProcessor.super(self,world,shared1,i18n);
end
__shared_project_intent_processors_IntentTutorialProcessor.__name__ = true
__shared_project_intent_processors_IntentTutorialProcessor.prototype = _hx_a();
__shared_project_intent_processors_IntentTutorialProcessor.prototype.processIntent = function(self,intent,data) 
  do return nil end
end

__shared_project_intent_processors_IntentTutorialProcessor.prototype.__class__ =  __shared_project_intent_processors_IntentTutorialProcessor
__shared_project_intent_processors_IntentTutorialProcessor.__super__ = __shared_project_intent_processors_IntentSubProcessor
setmetatable(__shared_project_intent_processors_IntentTutorialProcessor.prototype,{__index=__shared_project_intent_processors_IntentSubProcessor.prototype})

__shared_project_model_EnemyModel.new = function(world) 
  local self = _hx_new(__shared_project_model_EnemyModel.prototype)
  __shared_project_model_EnemyModel.super(self,world)
  return self
end
__shared_project_model_EnemyModel.super = function(self,world) 
  self.ai = _hx_tab_array({[0]=_hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.5,archer=0.5,shield=0,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.33,archer=0.33,shield=0.33,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.33,archer=0.33,shield=0.33,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.33,archer=0.33,shield=0.33,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.33,archer=0.33,shield=0.33,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.33,archer=0.33,shield=0.33,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.25,archer=0.25,shield=0.25,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.25,archer=0.25,shield=0.25,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0,knight=0.25,archer=0.25,shield=0.25,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.25,archer=0.25,shield=0.25,spearman=0,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.25,archer=0.25,shield=0.25,spearman=0.25,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.2,archer=0.2,shield=0.3,spearman=0.3,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.2,archer=0.2,shield=0.3,spearman=0.3,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.1,knight=0.15,archer=0.15,shield=0.35,spearman=0.3,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=0.5,knight=0.1,archer=0.1,shield=0.4,spearman=0.4,mage=0}), _hx_o({__fields__={spawn_percent=true,knight=true,archer=true,shield=true,spearman=true,mage=true},spawn_percent=1,knight=0.05,archer=0.5,shield=0.2,spearman=0.2,mage=0.5})}, 21);
  self.world = world;
  self.ds = self.world:storageGet();
end
_hx_exports["shared"]["project"]["model"]["EnemyModel"] = __shared_project_model_EnemyModel
__shared_project_model_EnemyModel.__name__ = true
__shared_project_model_EnemyModel.prototype = _hx_a();
__shared_project_model_EnemyModel.prototype.world= nil;
__shared_project_model_EnemyModel.prototype.ds= nil;
__shared_project_model_EnemyModel.prototype.ai= nil;
__shared_project_model_EnemyModel.prototype.unitsSpawnUnit = function(self,unitType) 
  self.world.levelModel:unitsSpawnUnit(1, unitType, 0);
  self.world.speechBuilder:text(Std.string("enemy spawn ") .. Std.string(unitType));
end
__shared_project_model_EnemyModel.prototype.modelRestore = function(self) 
end
__shared_project_model_EnemyModel.prototype.turn = function(self) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("enemy can't turn no level",0);
  end;
  if (level.ice > 0) then 
    do return end;
  end;
  local data = self.ai[_G.math.fmod(level.turnEnemyAI, self.ai.length)];
  if (data.spawn_percent >= _G.math.random()) then 
    local chance = _G.math.random();
    if (data.knight >= chance) then 
      self:unitsSpawnUnit("KNIGHT");
    else
      if ((data.knight + data.archer) >= chance) then 
        self:unitsSpawnUnit("ARCHER");
      else
        if (((data.knight + data.archer) + data.shield) >= chance) then 
          self:unitsSpawnUnit("SHIELD");
        else
          if ((((data.knight + data.archer) + data.shield) + data.spearman) >= chance) then 
            self:unitsSpawnUnit("SPEARMAN");
          else
            if (((((data.knight + data.archer) + data.shield) + data.spearman) + data.mage) >= chance) then 
              self:unitsSpawnUnit("MAGE");
            end;
          end;
        end;
      end;
    end;
  end;
  level.turnEnemyAI = level.turnEnemyAI + 1;
end

__shared_project_model_EnemyModel.prototype.__class__ =  __shared_project_model_EnemyModel

__shared_project_model_IBasicUnit.new = {}
__shared_project_model_IBasicUnit.__name__ = true

__shared_project_model_IBattleUnit.new = {}
__shared_project_model_IBattleUnit.__name__ = true
__shared_project_model_IBattleUnit.__interfaces__ = {__shared_project_model_IBasicUnit}
__shared_project_model_IBattleUnit.prototype = _hx_a();
__shared_project_model_IBattleUnit.prototype.takeDamage= nil;
__shared_project_model_IBattleUnit.prototype.getPos= nil;
__shared_project_model_IBattleUnit.prototype.getOwnerId= nil;
__shared_project_model_IBattleUnit.prototype.getId= nil;

__shared_project_model_IBattleUnit.prototype.__class__ =  __shared_project_model_IBattleUnit

__shared_project_model_LevelModel.new = function(world) 
  local self = _hx_new(__shared_project_model_LevelModel.prototype)
  __shared_project_model_LevelModel.super(self,world)
  return self
end
__shared_project_model_LevelModel.super = function(self,world) 
  self.world = world;
  self.ds = self.world:storageGet();
  self.playerModel = __shared_project_model_PlayerModel.new(world);
  self.enemyModel = __shared_project_model_EnemyModel.new(world);
  self.battleUnitModels = __haxe_ds_List.new();
  self.resourceUnitModels = __haxe_ds_List.new();
  self:modelRestore();
end
_hx_exports["shared"]["project"]["model"]["LevelModel"] = __shared_project_model_LevelModel
__shared_project_model_LevelModel.__name__ = true
__shared_project_model_LevelModel.prototype = _hx_a();
__shared_project_model_LevelModel.prototype.world= nil;
__shared_project_model_LevelModel.prototype.ds= nil;
__shared_project_model_LevelModel.prototype.playerModel= nil;
__shared_project_model_LevelModel.prototype.enemyModel= nil;
__shared_project_model_LevelModel.prototype.battleUnitModels= nil;
__shared_project_model_LevelModel.prototype.resourceUnitModels= nil;
__shared_project_model_LevelModel.prototype.restart = function(self) 
  local storage = self.world:storageGet();
  if (storage.level ~= nil) then 
    __shared_base_event_EventHelper.levelRestart(self.world);
  end;
  storage.level = nil;
  if (storage.level == nil) then 
    self:createLevel();
  end;
end
__shared_project_model_LevelModel.prototype.addUnit = function(self,unit) 
  self.battleUnitModels:add(unit);
  __shared_base_event_EventHelper.levelUnitSpawn(self.world, unit:getId(), unit:getStruct());
end
__shared_project_model_LevelModel.prototype.addUnitCastle = function(self,unit) 
  self.battleUnitModels:add(unit);
end
__shared_project_model_LevelModel.prototype.modelRestore = function(self) 
  if (self.ds.level ~= nil) then 
    local o = self.ds.level.units;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype.length ~= nil) or true)) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__.length ~= nil; else 
      _hx_1 = o.length ~= nil; end
      return _hx_1
    end )()) then 
      local _g = 0;
      local _g1 = self.ds.level.units;
      while (_g < _g1.length) do 
        local unit = _g1[_g];
        _g = _g + 1;
        if (unit.type == "CASTLE") then 
          self.battleUnitModels:add(__shared_project_model_units_CastleUnitModel.new(unit, self.world));
        else
          self.battleUnitModels:add(__shared_project_model_units_BattleUnitModel.new(unit, self.world));
        end;
      end;
    end;
    __haxe_Log.trace(Std.string("DBG_CAR: ") .. Std.string(Std.string(self.ds.level.caravans)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/LevelModel.hx",lineNumber=74,className="shared.project.model.LevelModel",methodName="modelRestore"}));
    local o1 = self.ds.level.caravans;
    if ((function() 
      local _hx_2
      if ((_G.type(o1) == "string") and ((String.prototype.length ~= nil) or true)) then 
      _hx_2 = true; elseif (o1.__fields__ ~= nil) then 
      _hx_2 = o1.__fields__.length ~= nil; else 
      _hx_2 = o1.length ~= nil; end
      return _hx_2
    end )()) then 
      local _g2 = 0;
      local _g11 = self.ds.level.caravans;
      while (_g2 < _g11.length) do 
        local caravan = _g11[_g2];
        _g2 = _g2 + 1;
        self.resourceUnitModels:add(__shared_project_model_units_ResourceUnitModel.new(caravan, self.world));
      end;
    end;
  end;
end
__shared_project_model_LevelModel.prototype.enqueueUnits = function(self,ownerId,type,amount) 
  local counter = amount;
  local owner = self:getPlayerById(ownerId);
  while (counter > 0) do 
    owner.unitQueue:push(_hx_o({__fields__={ownerId=true,unitType=true},ownerId=ownerId,unitType=type}));
    counter = counter - 1;
  end;
end
__shared_project_model_LevelModel.prototype.dequeUnits = function(self,ownerId,type,amount) 
  local counter = amount;
  local owner = self:getPlayerById(ownerId);
  if (owner ~= nil) then 
    local queuedOfType = Lambda.filter(owner.unitQueue, function(v) 
      do return v.unitType == type end;
    end);
    local _g = 0;
    while (_g < queuedOfType.length) do 
      local unit = queuedOfType[_g];
      _g = _g + 1;
      owner.unitQueue:remove(unit);
      counter = counter - 1;
      if (counter == 0) then 
        break;
      end;
    end;
  end;
end
__shared_project_model_LevelModel.prototype.unitsSpawnUnitCastle = function(self,ownerId,unitLevel) 
  local level = self.world:storageGet().level;
  local type = "CASTLE";
  if (level == nil) then 
    _G.error("no level in unitsSpawnUnitCastle",0);
  end;
  local scales = __shared_project_configs_UnitConfig.scalesByUnitType:get(type);
  if (scales == nil) then 
    _G.error("no scales in unitsSpawnUnitCastle",0);
  end;
  local unit = _hx_o({__fields__={roadPartIdx=true,id=true,hpLvl=true,hp=true,ownerId=true,type=true,attackLvl=true,attackRange=true,reward=true},roadPartIdx=-1,id=level.unitIdx,hpLvl=unitLevel,hp=scales.hpByLevel[unitLevel],ownerId=ownerId,type=type,attackLvl=unitLevel,attackRange=scales.attackRange,reward=scales.rewardByLevel[unitLevel]});
  level.unitIdx = level.unitIdx + 1;
  local road = level.roads[level.roads.length - 1];
  if (ownerId == 0) then 
    unit.roadPartIdx = _hx_funcToField(road[0].idx);
  else
    unit.roadPartIdx = _hx_funcToField(road[road.length - 1].idx);
  end;
  level.units:push(unit);
  local model = __shared_project_model_units_CastleUnitModel.new(unit, self.world);
  self:addUnitCastle(model);
  do return model end
end
__shared_project_model_LevelModel.prototype.getResourceCastlePos = function(self) 
  do return self.ds.level.roads[self.ds.level.roads.length - 2][0] end
end
__shared_project_model_LevelModel.prototype.getUnloadPos = function(self) 
  local road = self.ds.level.roads[self.ds.level.roads.length - 2];
  do return road[road.length - 1] end
end
__shared_project_model_LevelModel.prototype.spawnCaravan = function(self,level) 
  if (self.ds.level.caravans.length < self.playerModel:caravanGetMax()) then 
    local caravan = _hx_o({__fields__={roadPartIdx=true,ownerId=true,id=true,resources=true,resourceLvl=true},roadPartIdx=self:getUnloadPos().idx,ownerId=0,id=self.ds.level.caravanIdx,resources=0,resourceLvl=level});
    self.ds.level.caravanIdx = self.ds.level.caravanIdx + 1;
    self.ds.level.caravans:push(caravan);
    self:addCaravan(__shared_project_model_units_ResourceUnitModel.new(caravan, self.world));
    do return true end;
  end;
  do return false end
end
__shared_project_model_LevelModel.prototype.addCaravan = function(self,model) 
  self.resourceUnitModels:add(model);
  __shared_base_event_EventHelper.levelCaravanSpawn(self.world, model:getId(), model:getStruct());
end
__shared_project_model_LevelModel.prototype.unitsSpawnUnit = function(self,ownerId,type,unitLevel) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level in unitsSpawnUnit",0);
  end;
  local scales = __shared_project_configs_UnitConfig.scalesByUnitType:get(type);
  if (scales == nil) then 
    _G.error("no scales in unitsSpawnUnit",0);
  end;
  local unit = _hx_o({__fields__={roadPartIdx=true,id=true,hpLvl=true,hp=true,ownerId=true,type=true,attackLvl=true,attackRange=true,reward=true},roadPartIdx=-1,id=level.unitIdx,hpLvl=unitLevel,hp=scales.hpByLevel[unitLevel],ownerId=ownerId,type=type,attackLvl=unitLevel,attackRange=scales.attackRange,reward=scales.rewardByLevel[unitLevel]});
  level.unitIdx = level.unitIdx + 1;
  local road = level.roads[level.roads.length - 1];
  local roadPartIdx;
  if (ownerId == 0) then 
    roadPartIdx = road[0].idx;
  else
    roadPartIdx = road[road.length - 1].idx;
  end;
  if (self:canMoveToPart(roadPartIdx)) then 
    unit.roadPartIdx = roadPartIdx;
    level.units:push(unit);
    self:addUnit(__shared_project_model_units_BattleUnitModel.new(unit, self.world));
    do return true end;
  else
    do return false end;
  end;
end
__shared_project_model_LevelModel.prototype.canMoveToPart = function(self,partIdx) 
  do return Lambda.count(self.ds.level.units, function(v) 
    if (v.type ~= "CASTLE") then 
      do return v.roadPartIdx == partIdx end;
    else
      do return false end;
    end;
  end) == 0 end
end
__shared_project_model_LevelModel.prototype.createPlayer = function(self) 
  local unitLevels = _hx_e();
  local _g = 0;
  local _g1 = __shared_project_enums__UnitType_UnitType_Impl_.ALL_TYPES;
  while (_g < _g1.length) do 
    local type = _g1[_g];
    _g = _g + 1;
    unitLevels[Std.string(type)] = 1;
  end;
  do return _hx_o({__fields__={id=true,unitLevels=true,caravanLevel=true,unitQueue=true,mana=true,money=true},id=0,unitLevels=unitLevels,caravanLevel=1,unitQueue=Array.new(),mana=__shared_project_configs_GameConfig.START_MANA,money=__shared_project_configs_GameConfig.START_MONEY}) end
end
__shared_project_model_LevelModel.prototype.createEnemy = function(self) 
  local unitLevels = _hx_e();
  local _g = 0;
  local _g1 = __shared_project_enums__UnitType_UnitType_Impl_.ALL_TYPES;
  while (_g < _g1.length) do 
    local type = _g1[_g];
    _g = _g + 1;
    unitLevels[Std.string(type)] = 1;
  end;
  do return _hx_o({__fields__={id=true,unitLevels=true,unitQueue=true},id=1,unitLevels=unitLevels,unitQueue=Array.new()}) end
end
__shared_project_model_LevelModel.prototype.createRoadPart = function(self,x,y,type) 
  do return _hx_o({__fields__={x=true,y=true,type=true,idx=true},x=x,y=y,type=type,idx=(x * 1000) + y}) end
end
__shared_project_model_LevelModel.prototype.levelNextTurnBattles = function(self) 
  local madeTurn_h = ({});
  local madeTurn_k = ({});
  local _g_head = self.battleUnitModels.h;
  while (_g_head ~= nil) do 
    local val = _g_head.item;
    _g_head = _g_head.next;
    local attacker = _hx_tab_array({[0]=val}, 1);
    local canAttack = Lambda.filter(self.battleUnitModels, (function(attacker1) 
      do return function(v) 
        do return attacker1[0]:canAttack(v) end;
      end end;
    end)(attacker));
    __haxe_ds_ArraySort.sort(canAttack, (function() 
      do return function(a,b) 
        if (a:canMove() and not b:canMove()) then 
          do return -1 end;
        else
          if (not a:canMove() and b:canMove()) then 
            do return 1 end;
          else
            do return 0 end;
          end;
        end;
      end end;
    end)());
    if (canAttack.length == 0) then 
      if (attacker[0]:canMove()) then 
        if (madeTurn_h[attacker[0]] == nil) then 
          local newPos = self:unitNewPosition(attacker[0]);
          if (self:canMoveToPart(newPos.idx)) then 
            attacker[0]:move(newPos.idx);
            madeTurn_h[attacker[0]] = true;
            madeTurn_k[attacker[0]] = true;
          end;
        end;
      end;
    else
      local defender = canAttack[0];
      if (madeTurn_h[attacker[0]] == nil) then 
        attacker[0]:attack(defender);
        madeTurn_h[attacker[0]] = true;
        madeTurn_k[attacker[0]] = true;
        if ((madeTurn_h[defender] == nil) and defender:canAttack(attacker[0])) then 
          defender:attack(attacker[0]);
          madeTurn_h[defender] = true;
          madeTurn_k[defender] = true;
        end;
      end;
    end;
  end;
  self:removeDeadUnits();
end
__shared_project_model_LevelModel.prototype.removeDeadUnits = function(self) 
  local dead = Lambda.filter(self.ds.level.units, function(u) 
    do return u.hp == 0 end;
  end);
  Lambda.filter(self.battleUnitModels, function(u1) 
    do return not u1:isAlive() end;
  end);
  local _g = 0;
  while (_g < dead.length) do 
    local unit = dead[_g];
    _g = _g + 1;
    self.ds.level.units:remove(unit);
    local unitModel = self:unitsGetUnitById(unit.id);
    if (unit.type ~= "CASTLE") then 
      __shared_base_event_EventHelper.levelUnitDied(self.world, unit.id);
      if (unitModel:getOwnerId() > 0) then 
        self.world.levelModel.playerModel:moneyChange(unitModel:getReward(), "kill enemy");
      end;
      self.battleUnitModels:remove(unitModel);
    end;
  end;
end
__shared_project_model_LevelModel.prototype.unitNewPosition = function(self,unit) 
  local road = self:roadByRoadPart(unit:getPos());
  if (unit:getOwnerId() > 0) then 
    local id = road:indexOf(unit:getPos()) - 1;
    if (id < 0) then 
      id = 0;
    end;
    do return road[id] end;
  end;
  local id1 = road:indexOf(unit:getPos()) + 1;
  if (id1 >= road.length) then 
    id1 = road.length - 1;
  end;
  do return road[id1] end
end
__shared_project_model_LevelModel.prototype.roadByRoadPart = function(self,part) 
  if (self.ds.level ~= nil) then 
    local _g = 0;
    local _g1 = self.ds.level.roads;
    while (_g < _g1.length) do 
      local road = _g1[_g];
      _g = _g + 1;
      if (road:indexOf(part) ~= -1) then 
        do return road end;
      end;
    end;
  end;
  _G.error("Part doesnt belong to any road",0);
end
__shared_project_model_LevelModel.prototype.levelNextTurnCaravans = function(self) 
  local caravansToRemove = Array.new();
  local _g_head = self.resourceUnitModels.h;
  while (_g_head ~= nil) do 
    local val = _g_head.item;
    _g_head = _g_head.next;
    if (val:canLoad()) then 
      __haxe_Log.trace("can load", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/LevelModel.hx",lineNumber=333,className="shared.project.model.LevelModel",methodName="levelNextTurnCaravans"}));
      val:loadResources();
    else
      if (val:canUnload()) then 
        __haxe_Log.trace("can unload", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/LevelModel.hx",lineNumber=337,className="shared.project.model.LevelModel",methodName="levelNextTurnCaravans"}));
        val:unloadResources();
        caravansToRemove:push(val);
      else
        if (val:canMove()) then 
          __haxe_Log.trace("can move", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/LevelModel.hx",lineNumber=341,className="shared.project.model.LevelModel",methodName="levelNextTurnCaravans"}));
          val:move(self:caravanNewPos(val).idx);
        end;
      end;
    end;
  end;
  local _g1 = 0;
  while (_g1 < caravansToRemove.length) do 
    local caravan = caravansToRemove[_g1];
    _g1 = _g1 + 1;
    self.resourceUnitModels:remove(caravan);
    self.ds.level.caravans:remove(caravan:getStruct());
  end;
end
__shared_project_model_LevelModel.prototype.caravanNewPos = function(self,caravan) 
  local road = self:roadByRoadPart(caravan:getPos());
  if (caravan:getResources() > 0) then 
    do return road[road:indexOf(caravan:getPos()) + 1] end;
  else
    do return road[road:indexOf(caravan:getPos()) - 1] end;
  end;
end
__shared_project_model_LevelModel.prototype.levelNextTurnRegenMoney = function(self) 
  self.playerModel:moneyChange(__shared_project_configs_GameConfig.MONEY_REGEN, "startTurnRegen");
end
__shared_project_model_LevelModel.prototype.levelNextTurnRegenMana = function(self) 
  self.playerModel:manaChange(self.playerModel:mageGetManaRegen(), "startTurnRegen");
end
__shared_project_model_LevelModel.prototype.levelNextCheckWinLose = function(self) 
  local _gthis = self;
  if (self.ds.level ~= nil) then 
    local playerLose = Lambda.count(self.ds.level.castles, function(castle) 
      local unit = _gthis:unitsGetUnitById(castle.unitId);
      if (unit ~= nil) then 
        if (unit:getOwnerId() == 0) then 
          do return unit:getHp() == 0 end;
        else
          do return false end;
        end;
      else
        _G.error(Std.string("no unit levelNextCheckWinLose1 with id:") .. Std.string(castle.unitId),0);
      end;
    end) > 0;
    local allEnemiesLost = Lambda.count(self.ds.level.castles, function(castle1) 
      local unit1 = _gthis:unitsGetUnitById(castle1.unitId);
      if (unit1 ~= nil) then 
        __haxe_Log.trace(Std.string(Std.string(unit1:getOwnerId()) .. Std.string(" ")) .. Std.string(unit1:getHp()), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/LevelModel.hx",lineNumber=383,className="shared.project.model.LevelModel",methodName="levelNextCheckWinLose"}));
        if (unit1:getOwnerId() > 0) then 
          do return unit1:getHp() > 0 end;
        else
          do return false end;
        end;
      else
        _G.error(Std.string("no unit levelNextCheckWinLose2 with id:") .. Std.string(castle1.unitId),0);
      end;
    end) == 0;
    if (playerLose) then 
      self.ds.level.lose = true;
      self.world:contextChange("lose_modal");
      __shared_base_event_EventHelper.levelLost(self.world);
    else
      if (allEnemiesLost) then 
        self:levelWin();
      end;
    end;
  else
    _G.error("no level",0);
  end;
end
__shared_project_model_LevelModel.prototype.levelNextTurnQueue = function(self) 
  local level = self.ds.level;
  if (level ~= nil) then 
    local playerQueue = level.player.unitQueue;
    local enemyQueue = level.enemy.unitQueue;
    if (playerQueue.length > 0) then 
      local entry = playerQueue[0];
      if (self:unitsSpawnUnit(entry.ownerId, entry.unitType, Reflect.field(level.player.unitLevels, Std.string(entry.unitType)))) then 
        playerQueue:shift();
      end;
    end;
    if (enemyQueue.length > 0) then 
      local entry1 = enemyQueue[0];
      if (self:unitsSpawnUnit(entry1.ownerId, entry1.unitType, Reflect.field(level.enemy.unitLevels, Std.string(entry1.unitType)))) then 
        enemyQueue:shift();
      end;
    end;
  end;
end
__shared_project_model_LevelModel.prototype.turnMove = function(self) 
  local _g_head = self.battleUnitModels.h;
  while (_g_head ~= nil) do 
    local val = _g_head.item;
    _g_head = _g_head.next;
    if (val:canMove()) then 
      local newPos = self:unitNewPosition(val);
      if (self:canMoveToPart(newPos.idx)) then 
        val:move(newPos.idx);
      end;
    end;
  end;
end
__shared_project_model_LevelModel.prototype.turnEnemyAI = function(self) 
  self.enemyModel:turn();
end
__shared_project_model_LevelModel.prototype.turnAttack = function(self) 
  local _g_head = self.battleUnitModels.h;
  while (_g_head ~= nil) do 
    local val = _g_head.item;
    _g_head = _g_head.next;
    local attacker = _hx_tab_array({[0]=val}, 1);
    local canAttack = Lambda.filter(self.battleUnitModels, (function(attacker1) 
      do return function(v) 
        do return attacker1[0]:canAttack(v) end;
      end end;
    end)(attacker));
    if (canAttack.length ~= 0) then 
      attacker[0]:attack(canAttack[0]);
    end;
  end;
end
__shared_project_model_LevelModel.prototype.turnRemoveDeadUnits = function(self) 
  self:removeDeadUnits();
end
__shared_project_model_LevelModel.prototype.levelNextTurn = function(self) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level in levelNextTurn",0);
  end;
  if (level.lose) then 
    do return end;
  end;
  if (level.lose) then 
    _G.error("can't make turn we lose",0);
  end;
  __shared_base_event_EventHelper.levelNextTurn(self.world);
  level.turn = level.turn + 1;
  self:turnEnemyAI();
  self:levelNextTurnQueue();
  self:turnAttack();
  self:turnMove();
  self:turnRemoveDeadUnits();
  self:levelNextTurnCaravans();
  self:levelNextTurnRegenMoney();
  self:levelNextTurnRegenMana();
  if (level.ice > 0) then 
    level.ice = level.ice - 1;
    if (level.ice == 0) then 
      __shared_base_event_EventHelper.levelSpellIceEnd(self.world);
    end;
  end;
  __shared_base_event_EventHelper.levelTurnEnd(self.world);
  self:levelNextCheckWinLose();
end
__shared_project_model_LevelModel.prototype.levelFirstInitial = function(self) 
  self:createPlayer();
  self:createEnemy();
  local level = self:createPlayer();
  local level1 = self:createEnemy();
  local level2 = Array.new();
  local level3 = Array.new();
  local level4 = Array.new();
  local level5 = _hx_o({__fields__={ice=true,mageLevels=true,turnEnemyAI=true,turn=true,lose=true,unitIdx=true,caravanIdx=true,player=true,enemy=true,caravans=true,castles=true,roads=true,units=true},ice=0,mageLevels=_hx_o({__fields__={FIREBALL=true,CARAVAN=true,MANA=true,ICE=true},FIREBALL=0,CARAVAN=0,MANA=0,ICE=0}),turnEnemyAI=0,turn=0,lose=false,unitIdx=0,caravanIdx=0,player=level,enemy=level1,caravans=level2,castles=level3,roads=level4,units=Array.new()});
  self.world:storageGet().level = level5;
  local roadResToPlayer = Array.new();
  roadResToPlayer:push(self:createRoadPart(0, 0, "CASTLE"));
  roadResToPlayer:push(self:createRoadPart(1, 0, "BASE"));
  roadResToPlayer:push(self:createRoadPart(2, 0, "BASE"));
  roadResToPlayer:push(self:createRoadPart(3, 0, "CASTLE"));
  local roadPlayerToEnemy = Array.new();
  roadPlayerToEnemy:push(self:createRoadPart(7, 0, "CASTLE"));
  roadPlayerToEnemy:push(self:createRoadPart(8, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(9, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(10, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(11, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(12, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(13, 0, "CASTLE"));
  level5.roads:push(roadResToPlayer);
  level5.roads:push(roadPlayerToEnemy);
  local resourceUnit = self:unitsSpawnUnitCastle(0, 0);
  resourceUnit:getStruct().roadPartIdx = 0;
  level5.castles:push(_hx_o({__fields__={idx=true,unitId=true},idx=level5.castles.length,unitId=resourceUnit:getId()}));
  level5.castles:push(_hx_o({__fields__={idx=true,unitId=true},idx=level5.castles.length,unitId=self:unitsSpawnUnitCastle(0, 0):getId()}));
  level5.castles:push(_hx_o({__fields__={idx=true,unitId=true},idx=level5.castles.length,unitId=self:unitsSpawnUnitCastle(1, 0):getId()}));
  do return level5 end
end
__shared_project_model_LevelModel.prototype.createLevel = function(self) 
  if (self.world:storageGet().level == nil) then 
    self.world:storageGet().level = self:levelFirstInitial();
    __shared_base_event_EventHelper.levelNew(self.world);
  else
    _G.error("level already created",0);
  end;
end
__shared_project_model_LevelModel.prototype.levelWin = function(self) 
  if (self.world:storageGet().level == nil) then 
    _G.error("can't win level storage is null",0);
  end;
  __shared_base_event_EventHelper.levelWin(self.world);
end
__shared_project_model_LevelModel.prototype.levelNextCastle = function(self) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("can't move to next castle level storage is null",0);
  end;
  local _g = 0;
  local _g1 = level.units;
  while (_g < _g1.length) do 
    local unit = _g1[_g];
    _g = _g + 1;
    self:unitsGetUnitById(unit.id);
    if (unit.type ~= "CASTLE") then 
      __shared_base_event_EventHelper.levelUnitDiedMoveToNextCastle(self.world, unit.id);
    end;
  end;
  local _g2 = 0;
  local _g3 = level.caravans;
  while (_g2 < _g3.length) do 
    local caravan = _g3[_g2];
    _g2 = _g2 + 1;
    __shared_base_event_EventHelper.levelCaravanDiewMoveToNextCastle(self.world, caravan.id);
  end;
  level.caravans = Array.new();
  self.resourceUnitModels = __haxe_ds_List.new();
  level.enemy = self:createEnemy();
  local lastRoad = level.roads[level.roads.length - 1];
  local startX = lastRoad[lastRoad.length - 1].x;
  local roadPlayerToEnemy = Array.new();
  roadPlayerToEnemy:push(self:createRoadPart(startX + 1, 0, "CASTLE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 2, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 3, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 4, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 5, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 6, 0, "BASE"));
  roadPlayerToEnemy:push(self:createRoadPart(startX + 7, 0, "CASTLE"));
  level.roads:push(roadPlayerToEnemy);
  local persistCastleUnits = Array.new();
  level.castles:pop();
  local newUserCastleUnit = self:unitsSpawnUnitCastle(0, 0);
  level.castles:push(_hx_o({__fields__={idx=true,unitId=true},idx=level.castles.length,unitId=newUserCastleUnit:getId()}));
  local _g4 = 0;
  local _g5 = level.castles;
  while (_g4 < _g5.length) do 
    local castle = _g5[_g4];
    _g4 = _g4 + 1;
    local castleUnit = self:unitsGetUnitById(castle.unitId);
    if (castleUnit ~= nil) then 
      persistCastleUnits:push((__lua_Boot.__cast(castleUnit , __shared_project_model_units_CastleUnitModel)):getStruct());
    end;
  end;
  persistCastleUnits:push(newUserCastleUnit:getStruct());
  local newUnit = self:unitsSpawnUnitCastle(1, 0);
  level.castles:push(_hx_o({__fields__={idx=true,unitId=true},idx=level.castles.length,unitId=newUnit:getId()}));
  persistCastleUnits:push(newUnit:getStruct());
  level.units = Array.new();
  level.units = level.units:concat(persistCastleUnits);
  if (level.ice > 0) then 
    level.ice = 0;
    __shared_base_event_EventHelper.levelSpellIceEnd(self.world);
  end;
  self.world.levelModel.playerModel:moneyChange(__shared_project_configs_GameConfig.START_MONEY - level.player.money, "reset castle");
  self.world.levelModel.playerModel:manaChange(__shared_project_configs_GameConfig.START_MANA - level.player.mana, "reset castle");
  __shared_base_event_EventHelper.levelCastleEnemyDestroy(self.world);
  __shared_base_event_EventHelper.levelMoveToNext(self.world);
end
__shared_project_model_LevelModel.prototype.castlesGetByIdx = function(self,idx) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model castlesGetByIdx",0);
  end;
  do return level.castles[idx] end
end
__shared_project_model_LevelModel.prototype.roadsGetByIdx = function(self,idx) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model roadsGetByIdx",0);
  end;
  do return level.roads[idx] end
end
__shared_project_model_LevelModel.prototype.unitsGetUnitById = function(self,id) 
  local _g_head = self.battleUnitModels.h;
  while (_g_head ~= nil) do 
    local val = _g_head.item;
    _g_head = _g_head.next;
    if (val:getId() == id) then 
      do return val end;
    end;
  end;
  do return nil end
end
__shared_project_model_LevelModel.prototype.getPlayerById = function(self,id) 
  if (self.ds.level ~= nil) then 
    if (id == 0) then 
      do return self.ds.level.player end;
    else
      do return self.ds.level.enemy end;
    end;
  else
    _G.error("no level",0);
  end;
end
__shared_project_model_LevelModel.prototype.roadsFindPartById = function(self,id) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model roadsFindPartById",0);
  end;
  local road = self:roadsGetByIdx(_G.math.floor(_G.math.floor(id / 1000) / 7));
  local _g = 0;
  while (_g < road.length) do 
    local roadPart = road[_g];
    _g = _g + 1;
    if (roadPart.idx == id) then 
      do return roadPart end;
    end;
  end;
  local _g1 = 0;
  local _g2 = level.roads;
  while (_g1 < _g2.length) do 
    local road1 = _g2[_g1];
    _g1 = _g1 + 1;
    local _g11 = 0;
    while (_g11 < road1.length) do 
      local roadPart1 = road1[_g11];
      _g11 = _g11 + 1;
      if (roadPart1.idx == id) then 
        do return roadPart1 end;
      end;
    end;
  end;
  _G.error(Std.string("no road with id:") .. Std.string(id),0);
end

__shared_project_model_LevelModel.prototype.__class__ =  __shared_project_model_LevelModel

__shared_project_model_PlayerModel.new = function(world) 
  local self = _hx_new(__shared_project_model_PlayerModel.prototype)
  __shared_project_model_PlayerModel.super(self,world)
  return self
end
__shared_project_model_PlayerModel.super = function(self,world) 
  self.world = world;
  self.ds = self.world:storageGet();
end
_hx_exports["shared"]["project"]["model"]["PlayerModel"] = __shared_project_model_PlayerModel
__shared_project_model_PlayerModel.__name__ = true
__shared_project_model_PlayerModel.prototype = _hx_a();
__shared_project_model_PlayerModel.prototype.world= nil;
__shared_project_model_PlayerModel.prototype.ds= nil;
__shared_project_model_PlayerModel.prototype.spawnCaravan = function(self) 
  if (self.ds.level.caravans.length < self:caravanGetMax()) then 
    __shared_base_event_EventHelper.levelTurnStart(self.world);
  end;
  local success = self.world.levelModel:spawnCaravan(self.ds.level.player.caravanLevel);
  if (success) then 
    self.world.speechBuilder:text("spawned caravan");
    self.world.levelModel:levelNextTurn();
  end;
  do return success end
end
__shared_project_model_PlayerModel.prototype.unitsSpawnUnit = function(self,unitType,amount) 
  __shared_base_event_EventHelper.levelTurnStart(self.world);
  self.world.levelModel:enqueueUnits(0, unitType, amount);
  self.world.speechBuilder:text(Std.string("enqueued ") .. Std.string(unitType));
  self.world.levelModel:levelNextTurn();
end
__shared_project_model_PlayerModel.prototype.modelRestore = function(self) 
end
__shared_project_model_PlayerModel.prototype.moneyChange = function(self,value,tag) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:moneyChange",0);
  end;
  if (value == 0) then 
    do return end;
  end;
  if ((level.player.money + value) < 0) then 
    _G.error("not enought money",0);
  end;
  local level1 = level.player;
  level1.money = level1.money + value;
  __shared_base_event_EventHelper.levelMoneyChange(self.world, value, tag);
end
__shared_project_model_PlayerModel.prototype.canSpendMoney = function(self,value) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:moneyChange",0);
  end;
  do return level.player.money >= value end
end
__shared_project_model_PlayerModel.prototype.castSpell = function(self,type,newTurn) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for castSpell",0);
  end;
  if (newTurn) then 
    __shared_base_event_EventHelper.levelTurnStart(self.world);
  end;
  __shared_base_event_EventHelper.levelCastSpellStart(self.world, type);
  local power = self:mageGetPower(type);
  if (type == "FIREBALL") then 
    local _g_head = self.world.levelModel.battleUnitModels.h;
    while (_g_head ~= nil) do 
      local val = _g_head.item;
      _g_head = _g_head.next;
      if ((val:getOwnerId() > 0) and (val:getType() ~= "CASTLE")) then 
        val:takeDamage(power);
        __shared_base_event_EventHelper.levelUnitAttack(self.world, -10000, val:getId());
      end;
    end;
    self.world.levelModel:removeDeadUnits();
  else
    if (type == "ICE") then 
      level.ice = power;
      if (newTurn) then 
        level.ice = level.ice + 1;
      end;
      self.world.levelModel:removeDeadUnits();
    else
      if (type == "CARAVAN") then 
        level.mageLevels.CARAVAN = Reflect.field(level.mageLevels, "CARAVAN") + 1;
      else
        if (type == "MANA") then 
          level.mageLevels.MANA = Reflect.field(level.mageLevels, "MANA") + 1;
        end;
      end;
    end;
  end;
  __shared_base_event_EventHelper.levelCastSpellEnd(self.world, type);
  if (newTurn) then 
    self.world.levelModel:levelNextTurn();
  end;
end
__shared_project_model_PlayerModel.prototype.canSpendMana = function(self,value) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:moneyChange",0);
  end;
  do return level.player.mana >= value end
end
__shared_project_model_PlayerModel.prototype.unitGetPrice = function(self,type) 
  local scales = __shared_project_configs_UnitConfig.scalesByUnitType:get(type);
  if (scales == nil) then 
    _G.error("bad scales",0);
  end;
  do return scales.costByLevel[0] end
end
__shared_project_model_PlayerModel.prototype.mageGetPrice = function(self,type) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:mageGetPrice",0);
  end;
  local mageLevel = Reflect.field(level.mageLevels, Std.string(type));
  local scales = __shared_project_configs_MageConfig.scalesByMageType:get(type);
  if (scales == nil) then 
    _G.error("bad scales",0);
  end;
  do return scales.costByLevel[mageLevel] end
end
__shared_project_model_PlayerModel.prototype.mageGetPower = function(self,type) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:mageGetPrice",0);
  end;
  local mageLevel = Reflect.field(level.mageLevels, Std.string(type));
  local scales = __shared_project_configs_MageConfig.scalesByMageType:get(type);
  if (scales == nil) then 
    _G.error("bad scales",0);
  end;
  do return scales.powerByLevel[mageLevel] end
end
__shared_project_model_PlayerModel.prototype.mageGetPower2 = function(self,type) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:mageGetPrice",0);
  end;
  local mageLevel = Reflect.field(level.mageLevels, Std.string(type));
  local scales = __shared_project_configs_MageConfig.scalesByMageType:get(type);
  if (scales == nil) then 
    _G.error("bad scales",0);
  end;
  do return scales.power2ByLevel[mageLevel] end
end
__shared_project_model_PlayerModel.prototype.mageGetMaxMana = function(self) 
  do return self:mageGetPower2("MANA") end
end
__shared_project_model_PlayerModel.prototype.caravanGetMax = function(self) 
  do return self:mageGetPower("CARAVAN") end
end
__shared_project_model_PlayerModel.prototype.mageGetManaRegen = function(self) 
  do return self:mageGetPower("MANA") end
end
__shared_project_model_PlayerModel.prototype.manaChange = function(self,value,tag) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for playerModel:manaChange",0);
  end;
  if (value == 0) then 
    do return end;
  end;
  if ((level.player.mana + value) < 0) then 
    _G.error("not enought mana",0);
  end;
  if ((level.player.mana + value) > self:mageGetMaxMana()) then 
    value = self:mageGetMaxMana() - level.player.mana;
  end;
  if (value == 0) then 
    do return end;
  end;
  local level1 = level.player;
  level1.mana = level1.mana + value;
  __shared_base_event_EventHelper.levelManaChange(self.world, value, tag);
end

__shared_project_model_PlayerModel.prototype.__class__ =  __shared_project_model_PlayerModel

__shared_project_model_Restrictions.new = {}
_hx_exports["shared"]["project"]["model"]["Restrictions"] = __shared_project_model_Restrictions
__shared_project_model_Restrictions.__name__ = true

__shared_project_model_World.new = function(storage) 
  local self = _hx_new(__shared_project_model_World.prototype)
  __shared_project_model_World.super(self,storage)
  return self
end
__shared_project_model_World.super = function(self,storage) 
  self.clientIntentIdx = -1;
  __shared_base_model_WorldBaseModel.super(self,storage);
  self.dtdAnalytics = __shared_project_analytics_DtdAnalytics.new();
  self.timers = __shared_project_timers_Timers.new();
  self.isDevServer = false;
  self.tutorialsModel = __shared_project_tutorial_TutorialsModel.new(self);
  self.levelModel = __shared_project_model_LevelModel.new(self);
  self:restore();
  self.timers:init(self);
  self.speechBuilder = __shared_base_utils_GameUtils.getSpeechBuilder(self);
  self.speechBuilderTutorial = __shared_base_utils_GameUtils.getSpeechBuilder(self);
end
_hx_exports["shared"]["project"]["model"]["World"] = __shared_project_model_World
__shared_project_model_World.__name__ = true
__shared_project_model_World.prototype = _hx_a();
__shared_project_model_World.prototype.tutorialsModel= nil;
__shared_project_model_World.prototype.dtdAnalytics= nil;
__shared_project_model_World.prototype.timers= nil;
__shared_project_model_World.prototype.speechBuilder= nil;
__shared_project_model_World.prototype.speechBuilderTutorial= nil;
__shared_project_model_World.prototype.i18n= nil;
__shared_project_model_World.prototype.isDevServer= nil;
__shared_project_model_World.prototype.clientIntentIdx= nil;
__shared_project_model_World.prototype.levelModel= nil;
__shared_project_model_World.prototype.intentProcessor= nil;
__shared_project_model_World.prototype.setIntentProcessor = function(self,intentProcessor) 
  self.intentProcessor = intentProcessor;
end
__shared_project_model_World.prototype.setI18n = function(self,i18n) 
  self.i18n = i18n;
end
__shared_project_model_World.prototype.restore = function(self) 
  __shared_base_model_WorldBaseModel.prototype.restore(self);
end
__shared_project_model_World.prototype.onGameLoaded = function(self) 
  self.storage.level = nil;
  self.levelModel:restart();
end
__shared_project_model_World.prototype.outputConversationStart = function(self) 
  local _g = 0;
  local _g1 = self:contextGetAll();
  while (_g < _g1.length) do 
    local context = _g1[_g];
    _g = _g + 1;
    self:contextDelete(context.name);
  end;
  if (self:isDevUser()) then 
    self:contextChange("dev");
  end;
  if (self:isDevUser() and self.storage.profile.cheatsEnabled) then 
    self:outputCheatsEnable();
  end;
  self.storage.profile.conversationIdAtStart = _hx_funcToField(self.storage.profile.conversationIdCurrent);
  self.storage.profile.currentVersion = _hx_funcToField(self.storage.version.version);
  do return _hx_o({__fields__={code=true},code="SUCCESS"}) end
end
__shared_project_model_World.prototype.isDevUser = function(self) 
  if (not self.isDevServer) then 
    do return self.storage.profile.isDev end;
  else
    do return true end;
  end;
end
__shared_project_model_World.prototype.outputCheatsEnable = function(self) 
  if (not self:contextExist("dev")) then 
    _G.error("cheats only worked in dev mode",0);
  end;
  self:contextChange("cheats");
  self.storage.profile.cheatsEnabled = true;
  do return _hx_o({__fields__={code=true},code="SUCCESS"}) end
end
__shared_project_model_World.prototype.outputCheatsDisable = function(self) 
  if (not self:contextExist("dev")) then 
    _G.error("cheats only worked in dev mode",0);
  end;
  self:contextDelete("cheats");
  self.storage.profile.cheatsEnabled = false;
  do return _hx_o({__fields__={code=true},code="SUCCESS"}) end
end
__shared_project_model_World.prototype.storageOutputGet = function(self) 
  local storage = self:storageGet();
  storage.serverStruct = nil;
  do return __haxe_Json.parse(__haxe_Json.stringify(storage)) end
end
__shared_project_model_World.prototype.isDev = function(self) 
  do return self:contextExist("dev") end
end
__shared_project_model_World.prototype.isCheatsEnabled = function(self) 
  if (self:isDev()) then 
    do return self:contextExist("cheats") end;
  else
    do return false end;
  end;
end
__shared_project_model_World.prototype.canProcessIntent = function(self,name,data,throwExeption) 
  if (throwExeption == nil) then 
    throwExeption = false;
  end;
  local list = __shared_project_enums_Intents.intentContexts:get(name);
  if (list == nil) then 
    __haxe_Log.trace(Std.string("unknown intent ") .. Std.string(name), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="shared/src/shared/project/model/World.hx",lineNumber=119,className="shared.project.model.World",methodName="canProcessIntent"}));
    if (throwExeption) then 
      _G.error(Std.string("unknown intent ") .. Std.string(name),0);
    end;
    do return false end;
  end;
  local _g = 0;
  while (_g < list.length) do 
    local ctx = list[_g];
    _g = _g + 1;
    if (not self.contexts:exists(ctx)) then 
      if (throwExeption) then 
        _G.error(Std.string(Std.string(Std.string("can't process intent:") .. Std.string(name)) .. Std.string(" no context:")) .. Std.string(ctx),0);
      end;
      do return false end;
    end;
  end;
  if (__shared_project_enums_Intents.ignoreTutorialCheck:get(name) == nil) then 
    local result = self.tutorialsModel:canProcessIntent(name, data);
    if (throwExeption and not result) then 
      _G.error(Std.string(Std.string("can't process intent:") .. Std.string(name)) .. Std.string(" blocked by tutorial"),0);
    end;
    do return result end;
  else
    do return true end;
  end;
end
__shared_project_model_World.prototype.getLocalizationSafeLua = function(self,key,paramsJson) 
  if (paramsJson == nil) then 
    do return self:getLocalizationSafe(key, nil) end;
  else
    local map = __haxe_ds_StringMap.new();
    local data = __haxe_Json.parse(paramsJson);
    local _g = 0;
    local _g1 = Reflect.fields(data);
    while (_g < _g1.length) do 
      local k = _g1[_g];
      _g = _g + 1;
      local value = Reflect.field(data, k);
      if (value == nil) then 
        map.h[k] = __haxe_ds_StringMap.tnull;
      else
        map.h[k] = value;
      end;
    end;
    do return self:getLocalizationSafe(key, map) end;
  end;
end
__shared_project_model_World.prototype.getLocalizationLua = function(self,key,paramsJson) 
  if (paramsJson == nil) then 
    do return self:getLocalization(key, nil) end;
  else
    local map = __haxe_ds_StringMap.new();
    local data = __haxe_Json.parse(paramsJson);
    local _g = 0;
    local _g1 = Reflect.fields(data);
    while (_g < _g1.length) do 
      local k = _g1[_g];
      _g = _g + 1;
      local value = Reflect.field(data, k);
      if (value == nil) then 
        map.h[k] = __haxe_ds_StringMap.tnull;
      else
        map.h[k] = value;
      end;
    end;
    do return self:getLocalization(key, map) end;
  end;
end
__shared_project_model_World.prototype.getLocalizationLuaTutorial = function(self,key,paramsJson) 
  if (paramsJson == nil) then 
    do return self:getLocalizationTutorialText(key, nil) end;
  else
    local map = __haxe_ds_StringMap.new();
    local data = __haxe_Json.parse(paramsJson);
    local _g = 0;
    local _g1 = Reflect.fields(data);
    while (_g < _g1.length) do 
      local k = _g1[_g];
      _g = _g + 1;
      local value = Reflect.field(data, k);
      if (value == nil) then 
        map.h[k] = __haxe_ds_StringMap.tnull;
      else
        map.h[k] = value;
      end;
    end;
    do return self:getLocalizationTutorialText(key, map) end;
  end;
end
__shared_project_model_World.prototype.trackAnalyticEvent = function(self,event) 
  self.dtdAnalytics:trackEvent(event);
end
__shared_project_model_World.prototype.contextDeleteAll = function(self) 
  local _g = 0;
  local _g1 = self:contextGetAll();
  while (_g < _g1.length) do 
    local ctx = _g1[_g];
    _g = _g + 1;
    if ((ctx.name ~= "dev") and (ctx.name ~= "cheats")) then 
      self:contextDelete(ctx.name);
    end;
  end;
end
__shared_project_model_World.prototype.getLocalization = function(self,key,params) 
  do return self.i18n:tr(key, params) end
end
__shared_project_model_World.prototype.getLocalizationSafe = function(self,key,params) 
  local str = self.i18n:tr(key, params);
  if (str == key) then 
    do return "" end;
  end;
  do return str end
end
__shared_project_model_World.prototype.getLocalizationTutorialText = function(self,key,params) 
  if (__shared_project_configs_GameConfig.PLATFORM == "sber") then 
    do return self:getLocalization(key, params) end;
  else
    local tutorial_key = Std.string(key) .. Std.string("_text");
    local text = self:getLocalization(tutorial_key, params);
    if ((text == "") or (text == tutorial_key)) then 
      do return self:getLocalization(key, params) end;
    end;
    do return text end;
  end;
end
__shared_project_model_World.prototype.getUserLevel = function(self) 
  do return self.storage.stat.userLevel end
end
__shared_project_model_World.prototype.getSessionNumber = function(self) 
  do return self.storage.stat.startGameCounter end
end
__shared_project_model_World.prototype.getIntentIdx = function(self) 
  do return self.storage.stat.intentIdx end
end

__shared_project_model_World.prototype.__class__ =  __shared_project_model_World
__shared_project_model_World.__super__ = __shared_base_model_WorldBaseModel
setmetatable(__shared_project_model_World.prototype,{__index=__shared_base_model_WorldBaseModel.prototype})

__shared_project_model_units_BattleUnitModel.new = function(struct,world) 
  local self = _hx_new(__shared_project_model_units_BattleUnitModel.prototype)
  __shared_project_model_units_BattleUnitModel.super(self,struct,world)
  return self
end
__shared_project_model_units_BattleUnitModel.super = function(self,struct,world) 
  self.struct = struct;
  self.world = world;
end
_hx_exports["shared"]["project"]["model"]["units"]["BattleUnitModel"] = __shared_project_model_units_BattleUnitModel
__shared_project_model_units_BattleUnitModel.__name__ = true
__shared_project_model_units_BattleUnitModel.__interfaces__ = {__shared_project_model_IBattleUnit}
__shared_project_model_units_BattleUnitModel.prototype = _hx_a();
__shared_project_model_units_BattleUnitModel.prototype.struct= nil;
__shared_project_model_units_BattleUnitModel.prototype.world= nil;
__shared_project_model_units_BattleUnitModel.prototype.canAttack = function(self,enemy) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for canMove",0);
  end;
  if ((self:getOwnerId() > 0) and (level.ice > 0)) then 
    do return false end;
  end;
  if (self:calculateDistance(enemy) <= self.struct.attackRange) then 
    do return self:getOwnerId() ~= enemy:getOwnerId() end;
  else
    do return false end;
  end;
end
__shared_project_model_units_BattleUnitModel.prototype.attack = function(self,enemy) 
  if (self:canAttack(enemy)) then 
    enemy:takeDamage(self:calcDamage(enemy));
    __shared_base_event_EventHelper.levelUnitAttack(self.world, self:getId(), enemy:getId());
  end;
end
__shared_project_model_units_BattleUnitModel.prototype.calcDamage = function(self,enemy) 
  do return self:getScales().attackByLevel[self.struct.attackLvl] end
end
__shared_project_model_units_BattleUnitModel.prototype.calculateDistance = function(self,other) 
  do return _G.math.floor(_G.math.abs(self:getPos().x - other:getPos().x) + 0.5) + _G.math.floor(_G.math.abs(self:getPos().y - other:getPos().y) + 0.5) end
end
__shared_project_model_units_BattleUnitModel.prototype.takeDamage = function(self,amount) 
  local tmp = _G.math.floor(__shared_base_utils_MathUtils.clamp(self.struct.hp - amount, 0, self.struct.hp) + 0.5);
  self.struct.hp = tmp;
end
__shared_project_model_units_BattleUnitModel.prototype.isAlive = function(self) 
  do return self.struct.hp > 0 end
end
__shared_project_model_units_BattleUnitModel.prototype.takeHealing = function(self,amount) 
  local tmp = _G.math.floor(__shared_base_utils_MathUtils.clamp(self.struct.hp + amount, 0, self.struct.hp) + 0.5);
  self.struct.hp = tmp;
end
__shared_project_model_units_BattleUnitModel.prototype.getReward = function(self) 
  do return self:getScales().rewardByLevel[self.struct.hpLvl] end
end
__shared_project_model_units_BattleUnitModel.prototype.getScales = function(self) 
  do return __shared_project_configs_UnitConfig.scalesByUnitType:get(self.struct.type) end
end
__shared_project_model_units_BattleUnitModel.prototype.getPos = function(self) 
  do return self.world.levelModel:roadsFindPartById(self.struct.roadPartIdx) end
end
__shared_project_model_units_BattleUnitModel.prototype.canMove = function(self) 
  local level = self.world:storageGet().level;
  if (level == nil) then 
    _G.error("no level model for canMove",0);
  end;
  if ((self:getOwnerId() > 0) and (level.ice > 0)) then 
    do return false end;
  end;
  do return true end
end
__shared_project_model_units_BattleUnitModel.prototype.move = function(self,roadPartIdx) 
  self.struct.roadPartIdx = roadPartIdx;
  __shared_base_event_EventHelper.levelUnitMove(self.world, self:getId(), roadPartIdx);
end
__shared_project_model_units_BattleUnitModel.prototype.getOwnerId = function(self) 
  do return self.struct.ownerId end
end
__shared_project_model_units_BattleUnitModel.prototype.getType = function(self) 
  do return self.struct.type end
end
__shared_project_model_units_BattleUnitModel.prototype.getId = function(self) 
  do return self.struct.id end
end
__shared_project_model_units_BattleUnitModel.prototype.getStruct = function(self) 
  do return self.struct end
end
__shared_project_model_units_BattleUnitModel.prototype.getHp = function(self) 
  do return self.struct.hp end
end
__shared_project_model_units_BattleUnitModel.prototype.getMaxHp = function(self) 
  do return self:getScales().hpByLevel[self.struct.attackLvl] end
end
__shared_project_model_units_BattleUnitModel.prototype.getAttack = function(self) 
  local scales = self:getScales();
  if (scales == nil) then 
    _G.error("no scales in getAttack",0);
  end;
  do return scales.attackByLevel[self.struct.attackLvl] end
end

__shared_project_model_units_BattleUnitModel.prototype.__class__ =  __shared_project_model_units_BattleUnitModel

__shared_project_model_units_CastleUnitModel.new = function(struct,world) 
  local self = _hx_new(__shared_project_model_units_CastleUnitModel.prototype)
  __shared_project_model_units_CastleUnitModel.super(self,struct,world)
  return self
end
__shared_project_model_units_CastleUnitModel.super = function(self,struct,world) 
  __shared_project_model_units_BattleUnitModel.super(self,struct,world);
end
_hx_exports["shared"]["project"]["model"]["units"]["CastleUnitModel"] = __shared_project_model_units_CastleUnitModel
__shared_project_model_units_CastleUnitModel.__name__ = true
__shared_project_model_units_CastleUnitModel.prototype = _hx_a();
__shared_project_model_units_CastleUnitModel.prototype.canMove = function(self) 
  do return false end
end
__shared_project_model_units_CastleUnitModel.prototype.getStruct = function(self) 
  do return self.struct end
end

__shared_project_model_units_CastleUnitModel.prototype.__class__ =  __shared_project_model_units_CastleUnitModel
__shared_project_model_units_CastleUnitModel.__super__ = __shared_project_model_units_BattleUnitModel
setmetatable(__shared_project_model_units_CastleUnitModel.prototype,{__index=__shared_project_model_units_BattleUnitModel.prototype})

__shared_project_model_units_ResourceUnitModel.new = function(struct,world) 
  local self = _hx_new(__shared_project_model_units_ResourceUnitModel.prototype)
  __shared_project_model_units_ResourceUnitModel.super(self,struct,world)
  return self
end
__shared_project_model_units_ResourceUnitModel.super = function(self,struct,world) 
  self.struct = struct;
  self.world = world;
end
__shared_project_model_units_ResourceUnitModel.__name__ = true
__shared_project_model_units_ResourceUnitModel.__interfaces__ = {__shared_project_model_IBasicUnit}
__shared_project_model_units_ResourceUnitModel.prototype = _hx_a();
__shared_project_model_units_ResourceUnitModel.prototype.struct= nil;
__shared_project_model_units_ResourceUnitModel.prototype.world= nil;
__shared_project_model_units_ResourceUnitModel.prototype.getPos = function(self) 
  do return self.world.levelModel:roadsFindPartById(self.struct.roadPartIdx) end
end
__shared_project_model_units_ResourceUnitModel.prototype.canMove = function(self) 
  do return true end
end
__shared_project_model_units_ResourceUnitModel.prototype.move = function(self,roadPartIdx) 
  self.struct.roadPartIdx = roadPartIdx;
  __shared_base_event_EventHelper.levelUnitMove(self.world, self:getId(), roadPartIdx);
  __shared_base_event_EventHelper.levelCaravanMove(self.world, self:getId(), roadPartIdx);
end
__shared_project_model_units_ResourceUnitModel.prototype.getId = function(self) 
  do return self.struct.id end
end
__shared_project_model_units_ResourceUnitModel.prototype.getResources = function(self) 
  do return self.struct.resources end
end
__shared_project_model_units_ResourceUnitModel.prototype.canLoad = function(self) 
  if ((self.struct.resources == 0) and (self.world.levelModel:getResourceCastlePos().idx == self.struct.roadPartIdx)) then 
    do return true end;
  else
    do return false end;
  end;
end
__shared_project_model_units_ResourceUnitModel.prototype.loadResources = function(self) 
  if (self:canLoad()) then 
    local tmp = self.struct;
    tmp.resources = tmp.resources + __shared_project_configs_UnitConfig.resourceScale[self.struct.resourceLvl];
    __shared_base_event_EventHelper.levelCaravanLoad(self.world, self.struct.id);
  end;
end
__shared_project_model_units_ResourceUnitModel.prototype.canUnload = function(self) 
  if ((self.struct.resources > 0) and (self.world.levelModel:getUnloadPos().idx == self.struct.roadPartIdx)) then 
    do return true end;
  else
    do return false end;
  end;
end
__shared_project_model_units_ResourceUnitModel.prototype.unloadResources = function(self) 
  if (self:canUnload()) then 
    __shared_base_event_EventHelper.levelCaravanUnLoad(self.world, self.struct.id);
    local tmp = self.world:storageGet().level.player;
    tmp.money = tmp.money + self.struct.resources;
    self.struct.resources = 0;
  end;
end
__shared_project_model_units_ResourceUnitModel.prototype.getStruct = function(self) 
  do return self.struct end
end

__shared_project_model_units_ResourceUnitModel.prototype.__class__ =  __shared_project_model_units_ResourceUnitModel

__shared_project_storage_Storage.new = {}
__shared_project_storage_Storage.__name__ = true
__shared_project_storage_Storage.initNewStorage = function(data,force) 
  if (force == nil) then 
    force = true;
  end;
  if ((data.stat == nil) or force) then 
    data.stat = _hx_o({__fields__={version=true,startGameCounter=true,intentIdx=true,platform=true,device=true,dayAfterInstall=true,gameConfigVersion=true,gameLocaleVersion=true,gameSharedVersion=true,gameBackendVersion=true,userLevel=true},version=3,startGameCounter=0,intentIdx=0,platform="sber",device="sberbox",dayAfterInstall=0,gameConfigVersion="",gameLocaleVersion="",gameSharedVersion="",gameBackendVersion="",userLevel=1});
    data.iap = _hx_o({__fields__={current_iap=true,skuGoogle=true},current_iap="",skuGoogle=nil});
    local uuid = Uuid.v4();
    if ((data.profile ~= nil) and (data.profile.uuid ~= nil)) then 
      uuid = data.profile.uuid;
    end;
    local tag = "";
    if ((data.profile ~= nil) and (data.profile.tag ~= nil)) then 
      tag = data.profile.tag;
    end;
    local idAtStart = "";
    local idCurrent = "";
    if ((data.profile ~= nil) and (data.profile.conversationIdAtStart ~= nil)) then 
      idAtStart = data.profile.conversationIdAtStart;
    end;
    if ((data.profile ~= nil) and (data.profile.conversationIdCurrent ~= nil)) then 
      idCurrent = data.profile.conversationIdCurrent;
    end;
    local isDev = false;
    if ((data.profile ~= nil) and ((data.profile.isDev == false) or (data.profile.isDev == true))) then 
      isDev = data.profile.isDev;
    end;
    local t = _G.os.time() * 1000;
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    local firstLaunchTimestamp = _G.math.floor((d:getTime() / 1000) + 0.5);
    if ((data.profile ~= nil) and (data.profile.firstLaunchTimestamp ~= nil)) then 
      firstLaunchTimestamp = data.profile.firstLaunchTimestamp;
    end;
    data.profile = _hx_o({__fields__={cheatsEnabled=true,uuid=true,tag=true,isDev=true,conversationIdAtStart=true,conversationIdCurrent=true,currentVersion=true,dtdId=true,firstLaunchTimestamp=true},cheatsEnabled=false,uuid=uuid,tag=tag,isDev=isDev,conversationIdAtStart=idAtStart,conversationIdCurrent=idCurrent,currentVersion="",dtdId=Uuid.v4(),firstLaunchTimestamp=firstLaunchTimestamp});
    data.timers = _hx_o({__fields__={clientDeltaTime=true,serverLastTime=true,time=true,timerDelta=true},clientDeltaTime=0,serverLastTime=0,time=0,timerDelta=0});
    data.level = nil;
    data.serverStruct = _hx_e();
    data.utils = _hx_o({__fields__={auto_listening=true},auto_listening=false});
    data.tutorials = _hx_e();
  end;
end
__shared_project_storage_Storage.migrations = function(data) 
  if (data.stat == nil) then 
    __shared_project_storage_Storage.initNewStorage(data);
    do return end;
  end;
  if (data.stat.version < 3) then 
    __shared_project_storage_Storage.initNewStorage(data, true);
  end;
  data.stat.version = 3;
end
__shared_project_storage_Storage.restore = function(data) 
  local result = __haxe_Json.parse(data);
  if (result.serverStruct == nil) then 
    result.serverStruct = _hx_e();
  end;
  __shared_project_storage_Storage.migrations(result);
  do return result end;
end
__shared_project_storage_Storage.initClientStruct = function(storage) 
  if (storage.clientStruct == nil) then 
    storage.clientStruct = _hx_o({__fields__={timerDeltaClient=true,time=true},timerDeltaClient=0,time=0});
  end;
end

__shared_project_timers_Timers.new = function() 
  local self = _hx_new(__shared_project_timers_Timers.prototype)
  __shared_project_timers_Timers.super(self)
  return self
end
__shared_project_timers_Timers.super = function(self) 
end
__shared_project_timers_Timers.__name__ = true
__shared_project_timers_Timers.prototype = _hx_a();
__shared_project_timers_Timers.prototype.world= nil;
__shared_project_timers_Timers.prototype.init = function(self,world) 
  self.world = world;
end
__shared_project_timers_Timers.prototype.update = function(self,firstTime) 
  if (firstTime == nil) then 
    firstTime = false;
  end;
end

__shared_project_timers_Timers.prototype.__class__ =  __shared_project_timers_Timers

__shared_project_tutorial_TutorialsModel.new = function(world) 
  local self = _hx_new(__shared_project_tutorial_TutorialsModel.prototype)
  __shared_project_tutorial_TutorialsModel.super(self,world)
  return self
end
__shared_project_tutorial_TutorialsModel.super = function(self,world) 
  self.tutorialsOrder = Array.new();
  self.world = world;
  self:storageChanged();
end
_hx_exports["shared"]["project"]["tutorial"]["TutorialsModel"] = __shared_project_tutorial_TutorialsModel
__shared_project_tutorial_TutorialsModel.__name__ = true
__shared_project_tutorial_TutorialsModel.prototype = _hx_a();
__shared_project_tutorial_TutorialsModel.prototype.tutorialsOrder= nil;
__shared_project_tutorial_TutorialsModel.prototype.world= nil;
__shared_project_tutorial_TutorialsModel.prototype.storageChanged = function(self) 
  self:initTutorialsOrder();
end
__shared_project_tutorial_TutorialsModel.prototype.initTutorials = function(self) 
end
__shared_project_tutorial_TutorialsModel.prototype.initTutorialsOrder = function(self) 
  self.tutorialsOrder = _hx_tab_array({}, 0);
end
__shared_project_tutorial_TutorialsModel.prototype.postProcessIntent = function(self,name,code) 
  self:checkAndStart(name, code);
  local _g = 0;
  local _g1 = self.tutorialsOrder;
  while (_g < _g1.length) do 
    local tutorial = _g1[_g];
    _g = _g + 1;
    if (tutorial:canProcess()) then 
      tutorial:postProcessIntent(name, code);
    end;
  end;
end
__shared_project_tutorial_TutorialsModel.prototype.canProcessIntent = function(self,name,data) 
  local _g = 0;
  local _g1 = self.tutorialsOrder;
  while (_g < _g1.length) do 
    local tutorial = _g1[_g];
    _g = _g + 1;
    if (tutorial:canProcess()) then 
      if (name == "tutorial.no") then 
        if (tutorial:canProcessNo()) then 
          do return true end;
        end;
      else
        if (not tutorial:canProcessIntent(name, data)) then 
          do return false end;
        end;
      end;
    end;
  end;
  do return name ~= "tutorial.no" end
end
__shared_project_tutorial_TutorialsModel.prototype.checkAndStart = function(self,name,data) 
  if (not self:tutorialsAnyActive() and (name ~= "main.welcome")) then 
    local _g = 0;
    local _g1 = self.tutorialsOrder;
    while (_g < _g1.length) do 
      local tutorial = _g1[_g];
      _g = _g + 1;
      if (tutorial:canStart()) then 
        if (tutorial:isStarted()) then 
          break;
        end;
      end;
    end;
  end;
end
__shared_project_tutorial_TutorialsModel.prototype.tutorialsDebugGetActive = function(self) 
  local result = Array.new();
  local _g = 0;
  local _g1 = self.tutorialsOrder;
  while (_g < _g1.length) do 
    local tutorial = _g1[_g];
    _g = _g + 1;
    if (tutorial:isStarted()) then 
      result:push(tutorial.def);
    end;
  end;
  do return result end
end
__shared_project_tutorial_TutorialsModel.prototype.tutorialsAnyActive = function(self) 
  do return self:tutorialsDebugGetActive().length > 0 end
end
__shared_project_tutorial_TutorialsModel.prototype.skip = function(self) 
  local _g = 0;
  local _g1 = self.tutorialsOrder;
  while (_g < _g1.length) do 
    local tutorial = _g1[_g];
    _g = _g + 1;
    tutorial:complete(true);
  end;
end
__shared_project_tutorial_TutorialsModel.prototype.updateStorageOnGameRestart = function(self) 
  local _g = 0;
  local _g1 = self.tutorialsOrder;
  while (_g < _g1.length) do 
    local tutorial = _g1[_g];
    _g = _g + 1;
    if (tutorial:isStarted()) then 
      tutorial:checkOnGameRestart();
    end;
  end;
end
__shared_project_tutorial_TutorialsModel.prototype.startTutorialWhenLoadGameDone = function(self) 
end
__shared_project_tutorial_TutorialsModel.prototype.findIntentReplacement = function(self,intent,data) 
  if (__shared_project_configs_GameConfig.PLATFORM == "google") then 
    local _g = 0;
    local _g1 = self.tutorialsOrder;
    while (_g < _g1.length) do 
      local tutor = _g1[_g];
      _g = _g + 1;
      if (tutor:isStarted()) then 
        local tmp = tutor:replaceIntent(intent, data);
        if (tmp.intent ~= intent) then 
          do return tmp end;
        end;
      end;
    end;
  end;
  do return _hx_o({__fields__={intent=true,data=true},intent=intent,data=data}) end
end
__shared_project_tutorial_TutorialsModel.prototype.replaceCurrentIntent = function(self,intent,data) 
  self.world.intent = intent;
  do return self.world.intentProcessor:processIntent(intent) end
end

__shared_project_tutorial_TutorialsModel.prototype.__class__ =  __shared_project_tutorial_TutorialsModel

__shared_project_tutorial_tutorials_TutorialBase.new = function(world,id,parts) 
  local self = _hx_new(__shared_project_tutorial_tutorials_TutorialBase.prototype)
  __shared_project_tutorial_tutorials_TutorialBase.super(self,world,id,parts)
  return self
end
__shared_project_tutorial_tutorials_TutorialBase.super = function(self,world,id,parts) 
  self.world = world;
  self.def = Reflect.field(world:storageGet().tutorials, id);
  if (self.def == nil) then 
    _G.error(Std.string("no def for tutorial:") .. Std.string(id),0);
  end;
  if (self.def.id ~= id) then 
    _G.error(Std.string(Std.string(Std.string("bad id.Excepted:") .. Std.string(id)) .. Std.string(" get:")) .. Std.string(self.def.id),0);
  end;
  self.parts = parts;
end
_hx_exports["shared"]["project"]["tutorial"]["tutorials"]["TutorialBase"] = __shared_project_tutorial_tutorials_TutorialBase
__shared_project_tutorial_tutorials_TutorialBase.__name__ = true
__shared_project_tutorial_tutorials_TutorialBase.prototype = _hx_a();
__shared_project_tutorial_tutorials_TutorialBase.prototype.def= nil;
__shared_project_tutorial_tutorials_TutorialBase.prototype.world= nil;
__shared_project_tutorial_tutorials_TutorialBase.prototype.parts= nil;
__shared_project_tutorial_tutorials_TutorialBase.prototype.start = function(self) 
  local msg = Std.string("can't start tutotial:") .. Std.string(self.def.id);
  if (not self:canStart()) then 
    if (msg == nil) then 
      msg = "assert";
    end;
    _G.error(msg,0);
  end;
  local part = self.parts[0];
  if (part == nil) then 
    _G.error("can't start no part",0);
  end;
  self.def.currentPart = _hx_funcToField(part.id);
  self.world:eventEmit("TUTORIAL_STARTED", _hx_o({__fields__={tutorial=true},tutorial=self.def.id}));
  self.world:eventEmit("TUTORIAL_PART_CHANGED", _hx_o({__fields__={tutorial=true,part=true},tutorial=self.def.id,part=self.def.currentPart}));
  self:onPartChanged(nil);
  self:onStarted();
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.complete = function(self,onlyStorage) 
  if (onlyStorage == nil) then 
    onlyStorage = false;
  end;
  self.def.currentPart = nil;
  self.def.completed = true;
  if (not onlyStorage) then 
    self.world:eventEmit("TUTORIAL_COMPLETED", _hx_o({__fields__={tutorial=true},tutorial=self.def.id}));
    self:onCompleted();
  end;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.getCurrentPart = function(self) 
  do return self.def.currentPart end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.findPartIdxById = function(self,id) 
  if (id == nil) then 
    do return -1 end;
  end;
  local _g = 0;
  local _g1 = self.parts.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self.parts[i].id == id) then 
      do return i end;
    end;
  end;
  do return -1 end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.changeToNextPart = function(self) 
  self:changeToPart(self.parts[self:findPartIdxById(self.def.currentPart) + 1].id);
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.canProcessNo = function(self) 
  do return false end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.changeToPart = function(self,part) 
  local currentIdx = self:findPartIdxById(self.def.currentPart);
  local nextIdx = self:findPartIdxById(part);
  local currentPart = self.def.currentPart;
  if (currentPart ~= nil) then 
    if (currentPart == part) then 
      _G.error("change to current part",0);
    else
      if (currentIdx == -1) then 
        _G.error(Std.string("unknow part state:") .. Std.string(currentPart),0);
      end;
      if (nextIdx == -1) then 
        _G.error(Std.string("unknow new part state:") .. Std.string(nextIdx),0);
      end;
    end;
  end;
  if ((currentIdx + 1) ~= nextIdx) then 
    _G.error(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("can change from part:") .. Std.string(currentPart)) .. Std.string("(")) .. Std.string(currentIdx)) .. Std.string("}) to part:")) .. Std.string(part)) .. Std.string("(")) .. Std.string(nextIdx)) .. Std.string(")}"),0);
  end;
  self.def.currentPart = part;
  self.world:eventEmit("TUTORIAL_PART_CHANGED", _hx_o({__fields__={tutorial=true,part=true,prevPart=true},tutorial=self.def.id,part=self.def.currentPart,prevPart=currentPart}));
  self:onPartChanged(currentPart);
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.onPartChanged = function(self,prev) 
  __shared_project_analytics_AnalyticsHelper.sendTutorialPartChangedEvent(self.world, self.def.id, prev, self.def.currentPart, self:findPartIdxById(prev));
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.onCompleted = function(self) 
  __shared_project_analytics_AnalyticsHelper.sendTutorialFinishedEvent(self.world, self.def.id);
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.onStarted = function(self) 
  __shared_project_analytics_AnalyticsHelper.sendTutorialStartedEvent(self.world, self.def.id);
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.canProcess = function(self) 
  if (self.def.currentPart ~= nil) then 
    do return not self.def.completed end;
  else
    do return false end;
  end;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.isStarted = function(self) 
  do return self.def.currentPart ~= nil end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.isCompleted = function(self) 
  do return self.def.completed end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.reset = function(self) 
  self.def.currentPart = nil;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.resetAll = function(self) 
  self.def.currentPart = nil;
  self.def.completed = false;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.canStart = function(self) 
  if (self.def.currentPart == nil) then 
    do return not self.def.completed end;
  else
    do return false end;
  end;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.postProcessIntentUpdate = function(self,name,code) 
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.checkAndStart = function(self,name,data) 
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.canProcessIntent = function(self,name,data) 
  do return true end
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.postProcessIntent = function(self,name,code) 
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.checkOnGameRestart = function(self) 
  if (self:isStarted()) then 
    self:reset();
  end;
end
__shared_project_tutorial_tutorials_TutorialBase.prototype.replaceIntent = function(self,intent,data) 
  do return _hx_o({__fields__={intent=true,data=true},intent=intent,data=data}) end
end

__shared_project_tutorial_tutorials_TutorialBase.prototype.__class__ =  __shared_project_tutorial_tutorials_TutorialBase

__shared_project_utils_Base64.new = {}
_hx_exports["shared"]["project"]["utils"]["Base64"] = __shared_project_utils_Base64
__shared_project_utils_Base64.__name__ = true
__shared_project_utils_Base64.encode = function(bytes,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  local str = __haxe_crypto_BaseCode.new(__shared_project_utils_Base64.BYTES):encodeBytes(bytes):toString();
  if (complement) then 
    local _g = _G.math.fmod(bytes.length, 3);
    if (_g) == 1 then 
      str = Std.string(str) .. Std.string("==");
    elseif (_g) == 2 then 
      str = Std.string(str) .. Std.string("=");else end;
  end;
  do return str end;
end
__shared_project_utils_Base64.decode = function(str,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  if (complement) then 
    while (__lua_lib_luautf8_Utf8.byte(str, (__lua_lib_luautf8_Utf8.len(str) - 1) + 1) == __lua_lib_luautf8_Utf8.byte("=", 1)) do 
      local len = -1;
      if (-1 > __lua_lib_luautf8_Utf8.len(str)) then 
        len = __lua_lib_luautf8_Utf8.len(str);
      else
        len = __lua_lib_luautf8_Utf8.len(str) + -1;
      end;
      str = __lua_lib_luautf8_Utf8.sub(str, 1, len);
    end;
  end;
  do return __haxe_crypto_BaseCode.new(__shared_project_utils_Base64.BYTES):decodeBytes(__haxe_io_Bytes.ofString(str)) end;
end
__shared_project_utils_Base64.encodeString = function(data) 
  do return __shared_project_utils_Base64.encode(__haxe_zip_Compress.run(__haxe_io_Bytes.ofString(data), 9)) end;
end
__shared_project_utils_Base64.decodeString = function(data) 
  do return __haxe_zip_Uncompress.run(__shared_project_utils_Base64.decode(data)):toString() end;
end

__shared_project_utils_TimeUtils.new = {}
_hx_exports["shared"]["project"]["utils"]["TimeUtils"] = __shared_project_utils_TimeUtils
__shared_project_utils_TimeUtils.__name__ = true
__shared_project_utils_TimeUtils.getCurrentTime = function() 
  do return Sys.time() * 1000 end;
end
__shared_project_utils_TimeUtils.timeToString = function(time) 
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = time / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return __lua_Boot.dateStr(d) end;
end
__shared_project_utils_TimeUtils.timeToStringShort = function(time) 
  local d = _hx_e();
  _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = time / 1000;
  d.d = _G.os.date("*t", Std.int(d.t));
  d.dUTC = _G.os.date("!*t", Std.int(d.t));
  do return DateTools.format(d, "%d %H:%M:%S") end;
end

__shared_project_utils_TranslationUtils.new = {}
__shared_project_utils_TranslationUtils.__name__ = true
__shared_project_utils_TranslationUtils.getSpellCostMap = function(spellName,world) 
  local spell = __shared_project_enums__UnitType_MageType_Impl_.getByName(spellName);
  if (spell ~= nil) then 
    local _g = __haxe_ds_StringMap.new();
    local value = world.levelModel.playerModel:mageGetPower(spell);
    local key = Std.string(spellName) .. Std.string("_cost");
    if (value == nil) then 
      _g.h[key] = __haxe_ds_StringMap.tnull;
    else
      _g.h[key] = value;
    end;
    do return _g end;
  else
    do return __haxe_ds_StringMap.new() end;
  end;
end
_hx_bit_clamp = function(v)
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end

-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit = bit
else
  local bit32name = "bit32"
  local _hx_bit_raw = _G.require(bit32name)
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end

_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  DateTools.DAY_SHORT_NAMES = _hx_tab_array({[0]="Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}, 7);
  
  DateTools.DAY_NAMES = _hx_tab_array({[0]="Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}, 7);
  
  DateTools.MONTH_SHORT_NAMES = _hx_tab_array({[0]="Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}, 12);
  
  DateTools.MONTH_NAMES = _hx_tab_array({[0]="January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}, 12);
  
  __haxe_EntryPoint.pending = Array.new();
  
  __haxe_EntryPoint.threadCount = 0;
  
  __haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  __haxe_crypto_Base64.BYTES = __haxe_io_Bytes.ofString(__haxe_crypto_Base64.CHARS);
  
  __haxe_ds_IntMap.tnull = ({});
  
  __haxe_ds_StringMap.tnull = ({});
  
  __haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = _hx_tab_array({[0]=0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1}, 31);
  
  __haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = _hx_tab_array({[0]=3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258}, 29);
  
  __haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = _hx_tab_array({[0]=0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1}, 32);
  
  __haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = _hx_tab_array({[0]=1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577}, 30);
  
  __haxe_zip_InflateImpl.CODE_LENGTHS_POS = _hx_tab_array({[0]=16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}, 19);
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  __lua_Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  __seedyrng_Xorshift128Plus.SEED_1 = __haxe__Int64____Int64.new(842650776, 685298713);
  
  __shared_project_analytics_AnalyticsHelper.intentExclusions = _hx_tab_array({[0]="main.keep_working"}, 1);
  
  __shared_project_analytics_AnalyticsHelper.tutorNameToStep = (function() 
    local _hx_1
    
    local _g = __haxe_ds_StringMap.new();
    
    _g.h.Level1Battle = 100;
    
    _g.h.Level2Battle = 200;
    
    _g.h.Level3Battle = 300;
    
    _g.h.Help = 400;
    
    _g.h.Level4Battle = 500;
    
    _g.h.Level5Battle = 600;
    
    _hx_1 = _g;
    return _hx_1
  end )();
  
  __shared_project_configs_GameConfig.RANDOM = __seedyrng_Random.new();
  
  __shared_project_configs_GameConfig.INITIAL_VALUES = _hx_e();
  
  __shared_project_configs_GameConfig.PLATFORM = "google";
  
  __shared_project_configs_GameConfig.START_MANA = 60;
  
  __shared_project_configs_GameConfig.START_MONEY = 150;
  
  __shared_project_configs_GameConfig.MONEY_REGEN = 30;
  
  __shared_project_configs_GameConfig.MANA_REGEN = 10;
  
  __shared_project_configs_UnitConfig.scalesByUnitType = (function() 
    local _hx_2
    
    local _g = __haxe_ds_StringMap.new();
    
    _g:set("KNIGHT", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),attackByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),attackRange=1,costByLevel=_hx_tab_array({[0]=100, 100, 100, 100, 100}, 5),rewardByLevel=_hx_tab_array({[0]=50, 50, 50, 50, 50}, 5)}));
    
    _g:set("ARCHER", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),attackByLevel=_hx_tab_array({[0]=1, 1, 1, 1, 1}, 5),attackRange=2,costByLevel=_hx_tab_array({[0]=125, 125, 125, 125, 125}, 5),rewardByLevel=_hx_tab_array({[0]=75, 75, 75, 75, 75}, 5)}));
    
    _g:set("SHIELD", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=4, 4, 4, 4, 4}, 5),attackByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),attackRange=1,costByLevel=_hx_tab_array({[0]=200, 200, 200, 200, 200}, 5),rewardByLevel=_hx_tab_array({[0]=100, 100, 100, 100, 100}, 5)}));
    
    _g:set("SPEARMAN", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=3, 3, 3, 3, 3}, 5),attackByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),attackRange=1,costByLevel=_hx_tab_array({[0]=250, 250, 250, 250, 250}, 5),rewardByLevel=_hx_tab_array({[0]=150, 150, 150, 150, 150}, 5)}));
    
    _g:set("MAGE", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=4, 4, 4, 4, 4}, 5),attackByLevel=_hx_tab_array({[0]=3, 3, 3, 3, 3}, 5),attackRange=2,costByLevel=_hx_tab_array({[0]=400, 400, 400, 400, 400}, 5),rewardByLevel=_hx_tab_array({[0]=250, 250, 250, 250, 250}, 5)}));
    
    _g:set("CASTLE", _hx_o({__fields__={hpByLevel=true,attackByLevel=true,attackRange=true,costByLevel=true,rewardByLevel=true},hpByLevel=_hx_tab_array({[0]=20, 20, 20, 20, 20}, 5),attackByLevel=_hx_tab_array({[0]=1, 1, 1, 1, 1}, 5),attackRange=1,costByLevel=_hx_tab_array({[0]=0, 0, 0, 0, 0}, 5),rewardByLevel=_hx_tab_array({[0]=0, 0, 0, 0, 0}, 5)}));
    
    _hx_2 = _g;
    return _hx_2
  end )();
  
  __shared_project_configs_UnitConfig.resourceScale = _hx_tab_array({[0]=10, 20, 40, 50, 60}, 5);
  
  __shared_project_configs_MageConfig.scalesByMageType = (function() 
    local _hx_3
    
    local _g = __haxe_ds_StringMap.new();
    
    _g:set("FIREBALL", _hx_o({__fields__={costByLevel=true,powerByLevel=true,power2ByLevel=true},costByLevel=_hx_tab_array({[0]=90, 90, 90, 90, 90}, 5),powerByLevel=_hx_tab_array({[0]=1, 1, 1, 1, 1}, 5),power2ByLevel=_hx_tab_array({[0]=0, 0, 0, 0, 0}, 5)}));
    
    _g:set("ICE", _hx_o({__fields__={costByLevel=true,powerByLevel=true,power2ByLevel=true},costByLevel=_hx_tab_array({[0]=150, 150, 150, 150, 150}, 5),powerByLevel=_hx_tab_array({[0]=2, 2, 2, 2, 2}, 5),power2ByLevel=_hx_tab_array({[0]=0, 0, 0, 0, 0}, 5)}));
    
    _g:set("CARAVAN", _hx_o({__fields__={costByLevel=true,powerByLevel=true,power2ByLevel=true},costByLevel=_hx_tab_array({[0]=100, 150, 200, 999}, 4),powerByLevel=_hx_tab_array({[0]=1, 2, 3, 4}, 4),power2ByLevel=_hx_tab_array({[0]=0, 0, 0, 0, 0}, 5)}));
    
    _g:set("MANA", _hx_o({__fields__={costByLevel=true,powerByLevel=true,power2ByLevel=true},costByLevel=_hx_tab_array({[0]=75, 90, 150, 999}, 4),powerByLevel=_hx_tab_array({[0]=15, 20, 30, 40, 2}, 5),power2ByLevel=_hx_tab_array({[0]=100, 125, 150, 200, 250}, 5)}));
    
    _hx_3 = _g;
    return _hx_3
  end )();
  
  __shared_project_enums_Intents.intentContexts = __haxe_ds_StringMap.new();
  
  __shared_project_enums_Intents.ignoreTutorialCheck = __haxe_ds_StringMap.new();
  
  __shared_project_enums_Intents.modalContexts = __haxe_ds_StringMap.new();
  
  __shared_project_enums_Intents.commandCloseOrder = Array.new();
  
  __shared_project_enums__UnitType_UnitType_Impl_.ALL_TYPES = _hx_tab_array({[0]="KNIGHT", "ARCHER", "SHIELD", "SPEARMAN", "MAGE", "CASTLE"}, 6);
  
  __shared_project_utils_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  __shared_project_utils_Base64.BYTES = __haxe_io_Bytes.ofString(__shared_project_utils_Base64.CHARS);
  
  __shared_project_utils_TimeUtils.SECOND = 1000;
  
  __shared_project_utils_TimeUtils.MINUTE = __shared_project_utils_TimeUtils.SECOND * 60;
  
  __shared_project_utils_TimeUtils.HOUR = __shared_project_utils_TimeUtils.MINUTE * 60;
  
  
  String.__name__ = true;
  Array.__name__ = true;
  __haxe_Resource.content = _hx_tab_array({[0]={ name = "speech_commands_en", data = "ewoJInR1dG9yaWFsLnllcyI6IHsKCQkib3JkZXIiOiAxMDAsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJ0dXRvcmlhbC5ubyI6IHsKCQkib3JkZXIiOiAxMDAsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJkZWJ1Zy50b2dnbGUiOiB7CgkJIm9yZGVyIjogMTAwLAoJCSJ0ZXh0IjogIigoZW5hYmxlfHNob3cpXFxzKikrKChkZWJ1Zyl8KGJhY2spfChiYWNoKSkiCgl9LAoJIm1haW4uaGVscCI6IHsKCQkib3JkZXIiOiBudWxsLAoJCSJ0ZXh0IjogIih0ZWxsIG1lIGFib3V0KXwoaSAod2FudCB0byl8KHdhbm5hKSBoZWFyIGFib3V0KXwod2hhdCBpcykiCgl9LAoJInNpbXBsZS51bml0LmtuaWdodCI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIihrbmlnaHQpIgoJfSwKCSJzaW1wbGUudW5pdC5hcmNoZXIiOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoYXJjaGVyKSIKCX0sCgkic2ltcGxlLnVuaXQubWFnZSI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIihtYWdlKSIKCX0sCgkic2ltcGxlLnVuaXQuc3BlYXJtYW4iOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoc3BlYXIpIgoJfSwKCSJzaW1wbGUudW5pdC50YW5rIjogewoJCSJvcmRlciI6IDEsCgkJInRleHQiOiAiKHRhbmspIgoJfSwKCSJsZXZlbC50dXJuLnNraXAiOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoc2tpcCkiCgl9LAoJImxldmVsLnNwYXduLmNhcmF2YW4iOiB7CgkJIm9yZGVyIjogMCwKCQkidGV4dCI6ICIoY2FyYXZhbikiCgl9LAoJInNpbXBsZS5zcGVsbC5maXJlYmFsbCI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIihmaXJlKSIKCX0sCgkic2ltcGxlLnNwZWxsLmljZSI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIihpY2UpIgoJfSwKCSJzaW1wbGUuc3BlbGwudXBncmFkZV9tYW5hIjogewoJCSJvcmRlciI6IDEsCgkJInRleHQiOiAiKHVwZ3JhZGUgbWFuYSkiCgl9LAoJInNpbXBsZS5zcGVsbC51cGdyYWRlX2NhcmF2YW4iOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIodXBncmFkZSBjYXJhdmFuKSIKCX0KfQ"},{ name = "game_configs_en", data = "e30"},{ name = "localization_ru", data = "ewoJImNsaWVudCI6IHsKCQkieWVzIjogItC00LAiLAoJCSJubyI6ICLQvdC10YIiLAoJCSJidXR0b25zX2J1eV90ZXh0IjogItCa0KPQn9CY0KLQrCIsCgkJImJ1dHRvbnNfYnV5IjogIjxiPtCa0KPQn9CY0KLQrCDQl9CQPGI+IDpjb3VudCA8aW1nPWd1aV91aTppY29uX3RleHRfZ29sZC8+IiwKCQkiYnV0dG9uc19wbGF5X2FnYWluIjogItCY0JPQoNCQ0KLQrCDQodCd0J7QktCQIiwKCQkiYnV0dG9uc19vayI6ICJPSyIsCgkJImJ1dHRvbnNfY2FuY2VsIjogItCe0KLQnNCV0J3QkCIsCgkJImJ1dHRvbnNfY29udGludWUiOiAi0J/QoNCe0JTQntCb0JbQmNCi0KwiLAoJCSJidXR0b25zX2V4aXQiOiAi0JLQq9CZ0KLQmCIsCgkJImJ1dHRvbnNfcGxheSI6ICLQmNCT0KDQkNCi0KwiLAoJCSJidXR0b25zX3BsYXlfc3RhcnQiOiAi0JIg0JHQntCZIiwKCQkiYnV0dG9uc19yZXBvcnQiOiAi0J7RgtC/0YDQsNCy0LjRgtGMINC+0YLRh9C10YIiLAoJCSJidG5fb24iOiAi0LLQutC7IiwKCQkiYnRuX29mZiI6ICLQstGL0LrQuyIsCgkJInNlcnZlcl93YXNfdXBkYXRlIjogItCh0LXRgNCy0LXRgCDQsdGL0Lsg0L7QsdC90L7QstC70LXQvS5cbtCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C10YDQtdC30LDQudC00Lgg0LIg0L/RgNC40LvQvtC20LXQvdC40LUsINGH0YLQvtCx0Ysg0LjQs9GA0LDRgtGMINC00LDQu9GM0YjQtS4iCgl9LAoJImNvbnYiOiB7CgkJImZhbGxiYWNrIjogItCd0LUg0L/QvtC90LjQvNCw0Y4g0YLQtdCx0Y8uIiwKCQkicGxheV9tdWx0aXBsZV9kZXZpY2VzIjogItCi0Ysg0L3QtSDQvNC+0LbQtdGI0Ywg0LjQs9GA0LDRgtGMINGBINGA0LDQt9C90YvRhSDRg9GB0YLRgNC+0LnRgdGC0LIg0L7QtNC90L7QstGA0LXQvNC10L3QvdC+LiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQsdGD0LTQtdGCINC30LDQutGA0YvRgtC+LiIsCgkJInNlcnZlcl93YXNfdXBkYXRlIjogItCh0LXRgNCy0LXRgCDQsdGL0Lsg0L7QsdC90L7QstC70LXQvS5cbtCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9C10YDQtdC30LDQudC00Lgg0LIg0L/RgNC40LvQvtC20LXQvdC40LUsINGH0YLQvtCx0Ysg0LjQs9GA0LDRgtGMINC00LDQu9GM0YjQtS4iLAoJCSJ3ZWxjb21lIjogItCU0L7QsdGA0L4g0L/QvtC20LDQu9C+0LLQsNGC0YwsINCl0YDQsNC90LjRgtC10LvRjC4iLAoJCSJnYW1lX2V4aXQiOiAi0JTQviDQvdC+0LLRi9C8INCy0YHRgtGA0LXRhywg0KXRgNCw0L3QuNGC0LXQu9GMISIsCgkJImlhcF9jb21wbGV0ZSI6ICLQo9GB0L/QtdGI0L3QsNGPINC/0L7QutGD0L/QutCwIiwKCQkiaWFwX2ZhaWxlZCI6ICLQndC10YPQtNCw0LvQvtGB0Ywg0LrRg9C/0LjRgtGMIiwKCQkiZXJyb3Jfc2VydmVyX3N5bmMiOiAi0J3QtSDRg9C00LDQu9C+0YHRjCDRgdC40L3RhdGA0L7QvdC40LfQuNGA0L7QstCw0YLRjNGB0Y8uINCS0L7Qt9Cy0YDQsNGJ0LDQudGB0Y8sINCl0YDQsNC90LjRgtC10LvRjCEiLAoJCSJzaG9wX2NhbnRfZ2V0X3ByaWNlcyI6ICLQndC1INGD0LTQsNC70L7RgdGMINC/0L7Qu9GD0YfQuNGC0Ywg0YbQtdC90YsuINCf0L7Qv9GA0L7QsdGD0LnRgtC1INC/0L7Qt9C20LUiLAoJCSJoZWxwX0dBTUUiOiAi0K3RgtC+INC/0L7RiNCw0LPQvtCy0LDRjyDQuNCz0YDQsC4g0JLQsNGI0LAg0YbQtdC70YwgLSDQt9Cw0YXQstCw0YLQuNGC0Ywg0LLRgNCw0LbQtdGB0LrQuNC5INC30LDQvNC+0LouINCS0Ysg0LzQvtC20LXRgtC1INC90LDQvdC40LzQsNGC0Ywg0LLQvtC40L3QvtCyLCDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0LfQsNC60LvQuNC90LDQvdC40Y8g0Lgg0L7RgtC/0YDQsNCy0LvRj9GC0Ywg0LrQsNGA0LDQstCw0L3RiyDQt9CwINC30L7Qu9C+0YLQvtC8LiIsCgkJImhlbHBfS05JR0hUIjogItCt0YLQviDRgdGC0LDQvdC00LDRgNGC0L3Ri9C5INCy0L7QuNC9INGC0LLQvtC10Lkg0LDRgNC80LjQuCwg0YMg0L3QtdCz0L4g0LTQstCwINC+0YfQutCwINC30LTQvtGA0L7QstGM0Y8g0Lgg0LTQstCwINC+0YfQutCwINCw0YLQsNC60LguIiwKCQkiaGVscF9BUkNIRVIiOiAi0JvRg9GH0L3QuNC6INCw0YLQsNC60YPQtdGCINCy0LTQstC+0LUg0LTQsNC70YzRiNC1INGA0YvRhtCw0YDRjywg0L3QviDQtdCz0L4g0LDRgtCw0LrQuCDRgdC70LDQsdC10LUsINGDINC90LXQs9C+INC00LLQsCDQvtGH0LrQsCDQt9C00L7RgNC+0LLRjNGPINC4INC+0LTQvdC+INC+0YfQutC+INCw0YLQsNC60LguIiwKCQkiaGVscF9TSElFTEQiOiAi0JTQvtCy0L7Qu9GM0L3QviDQt9C90LDRh9C40LzQsNGPINCx0L7QtdCy0LDRjyDQtdC00LjQvdC40YbQsCwg0YXQvtGA0L7RiNC+INC30LDRidC40YnQtdC9LCAg0YMg0L3QtdCz0L4g0YfQtdGC0YvRgNC1INC+0YfQutCwINC30LTQvtGA0L7QstGM0Y8g0Lgg0LTQstCwINC+0YfQutCwINCw0YLQsNC60LguIiwKCQkiaGVscF9TUEVBUk1BTiI6ICLQntCx0YvRh9C90YvQuSDQstC+0LjQvSwg0LLQvtC+0YDRg9C20LXQvdC90YvQuSDQtNC70LjQvdC90YvQvCDQutC+0L/RjNC10LwsINC80L7QttC10YIg0LDRgtCw0LrQvtCy0LDRgtGMINC90LAg0LTQstC1INC60LvQtdGC0LrQuCwgINGDINC90LXQs9C+INGC0YDQuCDQvtGH0LrQsCDQt9C00L7RgNC+0LLRjNGPINC4INC00LLQsCDQvtGH0LrQsCDQsNGC0LDQutC4LiIsCgkJImhlbHBfTUFHRSI6ICLQrdC70LjRgtC90YvQuSDQstC+0LjQvS4g0J/QvtC30L3QsNC7INGA0LDQt9GA0YPRiNC40YLQtdC70YzQvdGD0Y4g0LzQsNCz0LjRji4g0KMg0L3QtdCz0L4g0YfQtdGC0YvRgNC1INC+0YfQutCwINC30LTQvtGA0L7QstGM0Y8g0Lgg0YLRgNC4INC+0YfQutCwINCw0YLQsNC60LguIiwKCQkiaGVscF9GSVJFQkFMTCI6ICLQntCz0L3QtdC90L3QvtC1INC30LDQutC70LjQvdCw0L3QuNC1LCDQvdCw0L3QvtGB0LjRgiDQv9C+IDEg0LXQtNC40L3QuNGG0LUg0YPRgNC+0L3QsCDQstGB0LXQvCDQstGA0LDQs9Cw0LwuIiwKCQkiaGVscF9JQ0UiOiAi0JfQsNC80L7RgNCw0LbQuNCy0LDQtdGCINCy0YHQtdGFINCy0YDQsNCz0L7QsiDQvdCwINC00LLQsCDRhdC+0LTQsC4iLAoJCSJNYW5hVXAgTHZsMSI6ICLQo9Cy0LXQu9C40YfQuNCy0LDQtdGCINC80LDQutGB0LjQvNCw0LvRjNC90YvQuSDRg9GA0L7QstC10L3RjCDQvNCw0L3RiyDQuCDQv9GA0LjRhdC+0LQg0LzQsNC90YsiLAoJCSJoZWxwX0NBUkFWQU5VUCI6ICLQo9Cy0LXQu9C40YfQuNCy0LDQtdGCINC80LDQutGB0LjQvNCw0LvRjNC90L7QtSDQutC+0LvQuNGH0LXRgdGC0LLQviDQutCw0YDQsNCy0LDQvdC+0LIg0L3QsCAxLiIsCgkJImZhbGxiYWNrXzEiOiAi0J3QtSDQv9C+0L3QuNC80LDRjiDRgtC10LHRjy4iCgl9LAoJInR1dG9yaWFsIjogewoJCSJoZWxsb193b3JsZCI6ICJoZWxsb193b3JsZCIKCX0KfQ"},{ name = "match_words_en", data = "ewoJInNpbXBsZS51bml0LmFyY2hlciI6IFsKCQkiaGVscCIsCgkJInNvcyIsCgkJImluZm8iLAoJCSJjb21tYW5kIiwKCQkiY29tbWFuZHMiCgldCn0"},{ name = "speech_commands_ru", data = "ewoJInR1dG9yaWFsLnllcyI6IHsKCQkib3JkZXIiOiAxMDAsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJ0dXRvcmlhbC5ubyI6IHsKCQkib3JkZXIiOiAxMDAsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJkZWJ1Zy50b2dnbGUiOiB7CgkJIm9yZGVyIjogMTAwLAoJCSJ0ZXh0IjogIigo0LLQutC70Y7Rh9C40YLRjHzQv9C+0LrQsNC20LgpXFxzKikrKNC00LXQsdCw0LMpIgoJfSwKCSJtYWluLmhlbHAiOiB7CgkJIm9yZGVyIjogbnVsbCwKCQkidGV4dCI6ICIoPyF4KXgiCgl9LAoJInNpbXBsZS51bml0LmtuaWdodCI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIig/IXgpeCIKCX0sCgkic2ltcGxlLnVuaXQuYXJjaGVyIjogewoJCSJvcmRlciI6IDEsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJzaW1wbGUudW5pdC5tYWdlIjogewoJCSJvcmRlciI6IDEsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJzaW1wbGUudW5pdC5zcGVhcm1hbiI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIig/IXgpeCIKCX0sCgkic2ltcGxlLnVuaXQudGFuayI6IHsKCQkib3JkZXIiOiAxLAoJCSJ0ZXh0IjogIig/IXgpeCIKCX0sCgkibGV2ZWwudHVybi5za2lwIjogewoJCSJvcmRlciI6IDEsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJsZXZlbC5zcGF3bi5jYXJhdmFuIjogewoJCSJvcmRlciI6IDAsCgkJInRleHQiOiAiKD8heCl4IgoJfSwKCSJzaW1wbGUuc3BlbGwuZmlyZWJhbGwiOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoPyF4KXgiCgl9LAoJInNpbXBsZS5zcGVsbC5pY2UiOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoPyF4KXgiCgl9LAoJInNpbXBsZS5zcGVsbC51cGdyYWRlX21hbmEiOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoPyF4KXgiCgl9LAoJInNpbXBsZS5zcGVsbC51cGdyYWRlX2NhcmF2YW4iOiB7CgkJIm9yZGVyIjogMSwKCQkidGV4dCI6ICIoPyF4KXgiCgl9Cn0"},{ name = "localization_eng", data = "ewoJImNsaWVudCI6IHsKCQkieWVzIjogInllcyIsCgkJIm5vIjogIm5vIiwKCQkiYnV0dG9uc19idXlfdGV4dCI6ICJCVVkiLAoJCSJidXR0b25zX2J1eSI6ICI8Yj5CVVkgRk9SPGI+IDpjb3VudCA8aW1nPWd1aV91aTppY29uX3RleHRfZ29sZC8+IiwKCQkiYnV0dG9uc19wbGF5X2FnYWluIjogIlBMQVkgQUdBSU4iLAoJCSJidXR0b25zX29rIjogIk9LIiwKCQkiYnV0dG9uc19jYW5jZWwiOiAiQ0FOQ0VMIiwKCQkiYnV0dG9uc19jb250aW51ZSI6ICJDT05USU5VRSIsCgkJImJ1dHRvbnNfZXhpdCI6ICJFWElUIiwKCQkiYnV0dG9uc19wbGF5IjogIlBMQVkiLAoJCSJidXR0b25zX3BsYXlfc3RhcnQiOiAiU1RBUlQiLAoJCSJidXR0b25zX3JlcG9ydCI6ICJTZW5kIHJlcG9ydCIsCgkJImJ0bl9vbiI6ICLQstC60LsiLAoJCSJidG5fb2ZmIjogItCy0YvQutC7IiwKCQkic2VydmVyX3dhc191cGRhdGUiOiAiVGhlIHNlcnZlciBoYXMgYmVlbiB1cGRhdGVkLlxuUGxlYXNlIHJlbG9hZCB0aGUgYXBwbGljYXRpb24gdG8gcGxheSBmdXJ0aGVyLiIKCX0sCgkiY29udiI6IHsKCQkiZmFsbGJhY2siOiAiSSBkbyBub3QgdW5kZXJzdGFuZCB5b3UuIiwKCQkicGxheV9tdWx0aXBsZV9kZXZpY2VzIjogIllvdSBjYW5ub3QgcGxheSBmcm9tIGRpZmZlcmVudCBkZXZpY2VzIGF0IHRoZSBzYW1lIHRpbWUuIFRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIGNsb3NlZCIsCgkJInNlcnZlcl93YXNfdXBkYXRlIjogIlRoZSBzZXJ2ZXIgaGFzIGJlZW4gdXBkYXRlZC5cblBsZWFzZSByZWxvYWQgdGhlIGFwcGxpY2F0aW9uIHRvIHBsYXkgZnVydGhlci4iLAoJCSJ3ZWxjb21lIjogIldlbGNvbWUsIEd1YXJkaWFuLiBUaGUgZ2FtZSBpcyBsb2FkaW5nLCBwbGVhc2Ugd2FpdCBhIHNlY29uZC4iLAoJCSJnYW1lX2V4aXQiOiAiR29vZGJ5ZSwgR3VhcmRpYW4iLAoJCSJpYXBfY29tcGxldGUiOiAiU3VjY2VzcyBwdXJjaGFzZSIsCgkJImlhcF9mYWlsZWQiOiAiRmFpbGVkIHRvIHB1cmNoYXNlIiwKCQkiZXJyb3Jfc2VydmVyX3N5bmMiOiAiRmFpbGVkIHRvIHN5bmNyb25pc2Ugd2l0aCBzZXJ2ZXIuIEdvb2RieWUgR3VhcmRpYW4iLAoJCSJzaG9wX2NhbnRfZ2V0X3ByaWNlcyI6ICJDYW4ndCBnZXQgcHJpY2VzLiBUcnkgYWdhaW4gbGF0ZXIiLAoJCSJoZWxwX0dBTUUiOiAiWW91IGFyZSB0aGUga2luZyBvZiB0aGUgY2FzdGxlLiBUaGlzIGlzIGEgdHVybiBiYXNlZCBnYW1lLiBZb3VyIGdvYWwgaXMgdG8gY2FwdHVyZSB0aGUgZW5lbXkncyBjYXN0bGUuIFlvdSBjYW4gcmVjcnVpdCB3YXJyaW9ycywgdXNlIHNwZWxscywgYW5kIHNlbmQgY2FyYXZhbnMgZm9yIGdvbGQgaW5jb21lLiIsCgkJImhlbHBfS05JR0hUIjogIlRoaXMgaXMgdGhlIHN0YW5kYXJkIHdhcnJpb3Igb2YgeW91ciBhcm15LCBoZSBoYXMgdHdvIGhlYWx0aCBwb2ludHMgYW5kIHR3byBhdHRhY2sgcG9pbnRzLiIsCgkJImhlbHBfQVJDSEVSIjogIlRoZSBhcmNoZXIgYXR0YWNrcyB0d2ljZSBhcyBmYXIgYXMgdGhlIGtuaWdodCwgYnV0IGhpcyBhdHRhY2tzIGFyZSB3ZWFrZXIsIGhlIGhhcyB0d28gaGVhbHRoIHBvaW50cyBhbmQgb25lIGF0dGFjayBwb2ludC4iLAoJCSJoZWxwX1NISUVMRCI6ICJRdWl0ZSBhIHNpZ25pZmljYW50IGNvbWJhdCB1bml0LCB3ZWxsIHByb3RlY3RlZCwgaGUgaGFzIGZvdXIgaGVhbHRoIHBvaW50cyBhbmQgdHdvIGF0dGFjayBwb2ludC4iLAoJCSJoZWxwX1NQRUFSTUFOIjogIkFuIG9yZGluYXJ5IHdhcnJpb3IgYXJtZWQgd2l0aCBhIGxvbmcgc3BlYXIgY2FuIGF0dGFjayB0d28gc3F1YXJlcywgaGUgaGFzIHRocmVlIGhlYWx0aCBwb2ludHMgYW5kIHR3byBhdHRhY2sgcG9pbnQuIiwKCQkiaGVscF9NQUdFIjogIkVsaXRlIHdhcnJpb3IuIExlYXJuZWQgZGVzdHJ1Y3RpdmUgbWFnaWMuIEhlIGhhcyBmb3VyIGhlYWx0aCBwb2ludHMgYW5kIHRocmVlIGF0dGFjayBwb2ludC4iLAoJCSJoZWxwX0ZJUkVCQUxMIjogIkZpcmUgc3BlbGwsIGRlYWxzIDEgcG9pbnQgb2YgZGFtYWdlIHRvIGFsbCBlbmVtaWVzLiIsCgkJImhlbHBfSUNFIjogIkZyZWV6ZXMgYWxsIGVuZW1pZXMgZm9yIHR3byB0dXJucy4iLAoJCSJNYW5hVXAgTHZsMSI6ICJJbmNyZWFzZSBtYXggbWFuYSBsZXZlbCB0byAxMjUgaW5jcmVhc2UgbWFuYSBpbmNvbWUgdG8gMjAiLAoJCSJoZWxwX0NBUkFWQU5VUCI6ICJJbmNyZWFzZSBtYXggY2FyYXZhbiBjb3VudCBieSAxLiIsCgkJImZhbGxiYWNrXzEiOiAiU3Bhd24gdW5pdHMgdG8gZGVmZWF0IGVuZW15LiBGb3IgZXhhbXBsZSBrbmlnaHQiLAoJCSJmYWxsYmFja18yIjogIllvdSBjYW4gc2tpcCB0dXJuIiwKCQkiZmFsbGJhY2tfMyI6ICJVc2Ugc3BlbGwgdG8gZGVmZWF0IGVuZW15LkZvciBleGFtcGxlIGZpcmViYWxsIiwKCQkiZmFsbGJhY2tfNCI6ICJEaWZmZXJlbnQgdW5pdHMgaGF2ZSBkaWZmZXJlbnQgcGFyYW1ldGVycyIKCX0sCgkidHV0b3JpYWwiOiB7CgkJImhlbGxvX3dvcmxkIjogImhlbGxvX3dvcmxkIgoJfQp9"},{ name = "game_configs_ru", data = "e30"},{ name = "match_words_ru", data = "e30"}}, 8);
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();
return _hx_exports
